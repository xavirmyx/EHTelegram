import asyncio
import json
import logging
import os
import random
import re
import time as time_module
from datetime import datetime, timedelta, time
from typing import Any, Dict, Optional, List

import psutil
import psycopg2
import pytz
import sentry_sdk
import telegram
from fastapi import FastAPI, Request
from fastapi.responses import PlainTextResponse
from psycopg2.extras import DictCursor, RealDictCursor
from sentry_sdk.integrations.fastapi import FastApiIntegration
from sentry_sdk.integrations.starlette import StarletteIntegration
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)
from telegram.error import BadRequest

# === SISTEMA DE SOLICITUDES DE CONTACTO ===
try:
    from contact_system import (
        create_contact_request,
        get_contact_request,
        get_contact_requests_by_status,
        respond_contact_request,
        close_contact_request,
        reopen_contact_request,
        get_contact_statistics,
        format_modern_contact_message,
        format_contact_detail_message,
        format_contact_list_message,
        format_user_notification_responded,
        format_user_notification_closed,
        format_user_notification_reopened,
        check_user_membership,
        update_user_membership,
        format_non_member_message,
        block_user,
        unblock_user,
        is_user_blocked,
        get_blocked_user_info,
        get_all_blocked_users,
        format_blocked_user_message
    )
    CONTACT_SYSTEM_AVAILABLE = True
    logger_temp = logging.getLogger(__name__)
    logger_temp.info("‚úÖ Sistema de solicitudes de contacto cargado")
except ImportError as e:
    CONTACT_SYSTEM_AVAILABLE = False
    logger_temp = logging.getLogger(__name__)
    logger_temp.warning(f"‚ö†Ô∏è Sistema de contacto no disponible: {str(e)}")

# === UTILIDADES DE USUARIOS (normalizaci√≥n y b√∫squeda) ===

def normalize_username(u: str) -> str:
    return (u or "").strip().lstrip("@").lower()

def find_user_id_by_username_db(conn, username_norm: str):
    """Busca user_id en BD por username (sin @, min√∫sculas). Devuelve int | None."""
    with conn.cursor() as c:
        c.execute("""
            SELECT DISTINCT user_id
            FROM peticiones_registradas
            WHERE LOWER(username) = %s
            LIMIT 1
        """, (username_norm,))
        r = c.fetchone()
        if r:
            return r[0]
        c.execute("""
            SELECT user_id
            FROM puntos_usuarios
            WHERE LOWER(username) = %s
            LIMIT 1
        """, (username_norm,))
        r = c.fetchone()
        return r[0] if r else None

async def try_resolve_user_id_via_telegram(context, username_norm: str):
    """
    √öltimo recurso: intenta resolver por Telegram con @username y username a pelo.
    Devuelve user_id | None. Nunca lanza excepci√≥n.
    """
    if not username_norm:
        return None
    candidate1 = f"@{username_norm}"
    candidate2 = username_norm
    for cand in (candidate1, candidate2):
        try:
            chat = await context.bot.get_chat(cand)
            if chat and getattr(chat, "id", None):
                return chat.id
        except Exception as _:
            continue
    return None

# Sistema de puntos y gamificaci√≥n (se cargar√° despu√©s de configurar logging)
SISTEMA_PUNTOS_DISPONIBLE = True

# Flag coherente (psutil ya est√° importado arriba)
PSUTIL_AVAILABLE = True

# Configuraci√≥n de variables de entorno
def validate_environment():
    """Valida las variables de entorno."""
    global TOKEN, GROUP_DESTINO, WEBHOOK_URL, DATABASE_URL, SUPABASE_URL, SUPABASE_KEY, ADMINISTRATORS, DEVELOPER_CHAT_ID, BAN_GROUP_ID
    TOKEN = os.getenv("TOKEN")
    GROUP_DESTINO = os.getenv("GROUP_DESTINO")
    WEBHOOK_URL = os.getenv("WEBHOOK_URL")
    DATABASE_URL = os.getenv("DATABASE_URL")
    SUPABASE_URL = os.getenv("SUPABASE_URL", os.getenv("VITE_SUPABASE_URL"))
    SUPABASE_KEY = os.getenv("SUPABASE_KEY", os.getenv("VITE_SUPABASE_ANON_KEY"))
    DEVELOPER_CHAT_ID = 7767930852  # Tu chat personal para errores
    BAN_GROUP_ID = -1002434034281  # Grupo donde se env√≠an comandos /ban para otro bot
    
    if not all([TOKEN, GROUP_DESTINO, WEBHOOK_URL, DATABASE_URL]):
        raise ValueError("‚ö†Ô∏è Faltan variables de entorno: TOKEN, GROUP_DESTINO, WEBHOOK_URL o DATABASE_URL")
    
    if not re.match(r'^\d+:[A-Za-z0-9_-]+$', TOKEN):
        raise ValueError("‚ö†Ô∏è Formato de TOKEN inv√°lido")
    
    if not GROUP_DESTINO.lstrip('-').isdigit():
        raise ValueError("‚ö†Ô∏è GROUP_DESTINO debe ser un ID de grupo v√°lido (empezar con -)")
    
    if not re.match(r'^https?://[^\s/$.?#].[^\s]*$', WEBHOOK_URL):
        raise ValueError("‚ö†Ô∏è WEBHOOK_URL debe ser una URL v√°lida")
    
    if not re.match(r'^postgres(ql)?://', DATABASE_URL):
        raise ValueError("‚ö†Ô∏è DATABASE_URL debe ser una URL de conexi√≥n PostgreSQL v√°lida")
    
    try:
        admin_str = os.getenv("ADMINISTRATORS", "[]")
        if admin_str.startswith('[') and admin_str.endswith(']'):
            admin_str = admin_str[1:-1]
        ADMINISTRATORS = [int(admin_id.strip()) for admin_id in admin_str.split(',') if admin_id.strip().isdigit()]
        if not ADMINISTRATORS:
            raise ValueError("‚ö†Ô∏è No se encontraron administradores v√°lidos")
    except ValueError as e:
        raise ValueError(f"‚ö†Ô∏è Error en ADMINISTRATORS: {str(e)}")

validate_environment()
PORT = int(os.getenv("PORT", 10000))

# Configuraci√≥n de logging mejorada
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger(__name__)

# Suprimir logs innecesarios
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("telegram").setLevel(logging.WARNING)
logging.getLogger("urllib3").setLevel(logging.WARNING)

# Cargar sistema de puntos
# Sistema de puntos integrado directamente en el main
SISTEMA_PUNTOS_DISPONIBLE = True
logger.info("‚úÖ Sistema de puntos habilitado e integrado")

# Inicializaci√≥n de FastAPI y Telegram Application
app = FastAPI(title="EntresHijos Bot", version="2.0.0")
application = Application.builder().token(TOKEN).build()

# Variables globales
menu_activos = {}
pending_links = {}
pending_reasons = {}
pending_deletions = {}
selected_requests = {}
pending_notifications = {}
pending_searches = {}
admin_waiting_responses = {}
user_menu_states = {}
notification_jobs = {}
backup_group_messages = {}  # Para rastrear mensajes del grupo de respaldo
confirmation_messages = {}  # Para rastrear mensajes de confirmaci√≥n
maintenance_messages = {}  # Para rastrear mensajes de mantenimiento
pending_suggestions = {}  # Para rastrear sugerencias pendientes de usuarios
automatic_notifications_enabled = True
duplicate_detection_enabled = True  # Sistema de detecci√≥n de duplicados
MAX_REQUESTS_PER_USER = 2
MAX_BACKUP_GROUP_ATTEMPTS = 2  # M√°ximo de intentos para unirse al grupo de respaldo
MAX_INCORRECT_ATTEMPTS = 3  # M√°ximo de peticiones incorrectas por d√≠a
MAX_BUTTON_ABUSE_ATTEMPTS = 3  # M√°ximo de abusos de botones antes de expulsi√≥n
DUPLICATE_SIMILARITY_THRESHOLD = 0.9  # Umbral de similitud para detectar duplicados (90%)
DUPLICATE_TIME_WINDOW_HOURS = 72  # Ventana de tiempo para buscar duplicados (72 horas)
BOT_START_TIME = time_module.time()
SPAIN_TZ = pytz.timezone("Europe/Madrid")

# ============================================
# FUNCIONES DEL SISTEMA DE PUNTOS (INTEGRADAS)
# ============================================

# Configuraci√≥n de niveles (si no est√° disponible sistema_puntos.py)
NIVELES = {
    "bronce": {"emoji": "ü•â", "min_puntos": 0, "max_puntos": 199},
    "plata": {"emoji": "ü•à", "min_puntos": 200, "max_puntos": 499},
    "oro": {"emoji": "ü•á", "min_puntos": 500, "max_puntos": 999},
    "diamante": {"emoji": "üíé", "min_puntos": 1000, "max_puntos": 1999},
    "leyenda": {"emoji": "üëë", "min_puntos": 2000, "max_puntos": float('inf')}
}

def obtener_top_usuarios(limit=20):
    """Obtiene el top de usuarios por puntos desde Supabase."""
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as c:
            c.execute("""
                SELECT user_id, username, puntos_totales, nivel,
                       solicitudes_aprobadas, encuestas_completadas, racha_dias
                FROM puntos_usuarios
                ORDER BY puntos_totales DESC
                LIMIT %s
            """, (limit,))
            results = c.fetchall()

            usuarios = []
            for row in results:
                usuarios.append({
                    "user_id": row["user_id"],
                    "username": row["username"],
                    "puntos": row["puntos_totales"],
                    "nivel": row["nivel"],
                    "solicitudes_aprobadas": row["solicitudes_aprobadas"],
                    "encuestas_completadas": row["encuestas_completadas"],
                    "racha_dias": row["racha_dias"]
                })
            return usuarios
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo top usuarios: {str(e)}", exc_info=True)
        return []
    finally:
        if conn:
            release_db_connection(conn)

def obtener_puntos_usuario(user_id):
    """Obtiene los puntos de un usuario espec√≠fico desde Supabase."""
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor(cursor_factory=RealDictCursor) as c:
            c.execute("""
                SELECT user_id, username, puntos_totales, nivel,
                       solicitudes_aprobadas, encuestas_completadas, racha_dias
                FROM puntos_usuarios
                WHERE user_id = %s
            """, (user_id,))
            result = c.fetchone()

            if result:
                return {
                    "user_id": result["user_id"],
                    "username": result["username"],
                    "puntos": result["puntos_totales"],
                    "nivel": result["nivel"],
                    "solicitudes_aprobadas": result["solicitudes_aprobadas"],
                    "encuestas_completadas": result["encuestas_completadas"],
                    "racha_dias": result["racha_dias"]
                }
            return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo puntos de usuario {user_id}: {str(e)}", exc_info=True)
        return None
    finally:
        if conn:
            release_db_connection(conn)

def get_puntos_info_texto(user_id, username):
    """Genera el texto de informaci√≥n de puntos para mostrar en mensajes."""
    try:
        puntos_info = obtener_puntos_usuario(user_id)
        if puntos_info:
            nivel_emoji = NIVELES[puntos_info["nivel"]]["emoji"]
            return f"\nüí∞ *Puntos:* {puntos_info['puntos']:,} pts {nivel_emoji} *{puntos_info['nivel'].capitalize()}*"
        else:
            # Usuario nuevo sin puntos
            crear_usuario_puntos(user_id, username)
            return f"\nüí∞ *Puntos:* 0 pts ü•â *Bronce*"
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo info de puntos: {str(e)}")
        return ""

def generar_mensaje_confirmacion_solicitud(username_escaped, ticket_number, user_id, chat_title_escaped,
                                          timestamp_str, message_text_escaped, has_attachment,
                                          new_count, vote_text, bot_username, username_original=""):
    """Genera el mensaje de confirmaci√≥n de solicitud con informaci√≥n de puntos."""
    puntos_info = get_puntos_info_texto(user_id, username_original if username_original else username_escaped)

    return (
        f"‚ú® **SOLICITUD REGISTRADA** ‚ú®\n\n"
        f"Hola {username_escaped}, tu solicitud ha sido registrada correctamente üéâ\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üé´ **Ticket #{ticket_number}**\n\n"
        f"üìã **Tu petici√≥n:**\n_{message_text_escaped}_\n\n"
        f"üìä **Estado:** {new_count}/2 solicitudes hoy\n"
        f"{puntos_info}\n"
        f"‚è≥ Pendiente de revisi√≥n\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üí° **Tip:** Activa notificaciones privadas\n"
        f"Env√≠a /start a @{bot_username} para recibir\n"
        f"avisos cuando tu solicitud sea procesada\n\n"
        f"*Equipo EntresHijos* üë®‚Äçüë©‚Äçüëß‚Äçüë¶"
    )

def generar_teclado_confirmacion_solicitud(ticket_number, user_id):
    """Genera el teclado de botones para la confirmaci√≥n de solicitud."""
    return [
        [InlineKeyboardButton("‚åõ Estado", callback_data=f"estado_{ticket_number}"),
         InlineKeyboardButton("üìû Contactar Admin", callback_data=f"contactar_admin_{ticket_number}")],
        [InlineKeyboardButton("üìã Detalles", callback_data=f"ticket_{ticket_number}_estado"),
         InlineKeyboardButton("‚ùå Cancelar Solicitud", callback_data=f"cancelar_{ticket_number}")],
        [InlineKeyboardButton("üëç Votar +", callback_data=f"vote_{ticket_number}_1"),
         InlineKeyboardButton("üëé Votar -", callback_data=f"vote_{ticket_number}_-1")],
        [InlineKeyboardButton("üéÅ Canjear Puntos", callback_data=f"canjear_puntos_{user_id}_{ticket_number}")]
    ]

def calcular_nivel(puntos):
    """Calcula el nivel seg√∫n los puntos."""
    for nivel, config in NIVELES.items():
        if config["min_puntos"] <= puntos <= config["max_puntos"]:
            return nivel
    return "bronce"

def crear_usuario_puntos(user_id, username):
    """Crea un usuario en el sistema de puntos de Supabase si no existe."""
    conn = None
    try:
        uname = (username or "").lstrip("@").lower()
        conn = get_db_connection()
        conn.autocommit = False

        with conn.cursor() as c:
            c.execute("""
                INSERT INTO puntos_usuarios (user_id, username, puntos_totales, nivel)
                VALUES (%s, %s, 0, 'bronce')
                ON CONFLICT (user_id) DO NOTHING
            """, (user_id, uname))
            conn.commit()

        logger.info(f"‚úÖ Usuario {uname} (user_id: {user_id}) creado/verificado en sistema de puntos")
        return True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error creando usuario en sistema de puntos: {str(e)}", exc_info=True)
        if conn:
            conn.rollback()
        return False
    finally:
        if conn:
            release_db_connection(conn)

def otorgar_puntos(user_id, username, puntos, tipo, descripcion, admin_id=None):
    """Otorga puntos a un usuario y registra la transacci√≥n en Supabase."""
    conn = None
    try:
        # Validar entrada
        if not user_id or not isinstance(user_id, int):
            logger.error(f"‚ö†Ô∏è user_id inv√°lido: {user_id}")
            return False

        if not isinstance(puntos, int):
            logger.error(f"‚ö†Ô∏è puntos debe ser un entero: {puntos}")
            return False

        # Normalizar username
        username_norm = (username or "").lstrip("@").lower()

        logger.info(f"üéØ Otorgando {puntos} puntos a {username_norm} (user_id: {user_id}, tipo: {tipo})")

        conn = get_db_connection()
        conn.autocommit = False

        with conn.cursor(cursor_factory=RealDictCursor) as c:
            # Crear usuario si no existe
            c.execute("""
                INSERT INTO puntos_usuarios (user_id, username, puntos_totales, nivel)
                VALUES (%s, %s, 0, 'bronce')
                ON CONFLICT (user_id) DO NOTHING
            """, (user_id, username_norm))

            # Obtener puntos actuales
            c.execute("""
                SELECT puntos_totales, nivel, solicitudes_aprobadas, encuestas_completadas
                FROM puntos_usuarios
                WHERE user_id = %s
            """, (user_id,))
            result = c.fetchone()

            if not result:
                logger.error(f"‚ö†Ô∏è No se pudo crear o encontrar usuario {user_id} en puntos_usuarios")
                conn.rollback()
                return False

            puntos_actuales = result["puntos_totales"] or 0
            solicitudes_actuales = result["solicitudes_aprobadas"] or 0
            encuestas_actuales = result["encuestas_completadas"] or 0

            logger.info(f"üìä Puntos actuales de {username_norm}: {puntos_actuales}")

            # Calcular nuevos puntos y nivel
            nuevos_puntos = max(0, puntos_actuales + puntos)
            nuevo_nivel = calcular_nivel(nuevos_puntos)

            logger.info(f"üìà Nuevos puntos: {nuevos_puntos}, Nivel: {nuevo_nivel}")

            # Actualizar puntos y nivel
            update_fields = {
                "puntos_totales": nuevos_puntos,
                "nivel": nuevo_nivel,
                "updated_at": datetime.now(SPAIN_TZ),
                "ultima_actividad": datetime.now(SPAIN_TZ)
            }

            # Actualizar contador espec√≠fico seg√∫n el tipo
            if tipo == "solicitud_aprobada":
                update_fields["solicitudes_aprobadas"] = solicitudes_actuales + 1
                logger.info(f"‚úÖ Incrementando solicitudes_aprobadas: {solicitudes_actuales} -> {solicitudes_actuales + 1}")
            elif tipo == "encuesta_completada":
                update_fields["encuestas_completadas"] = encuestas_actuales + 1
                logger.info(f"‚úÖ Incrementando encuestas_completadas: {encuestas_actuales} -> {encuestas_actuales + 1}")

            # Construir query din√°mico
            set_clause = ", ".join([f"{k} = %s" for k in update_fields.keys()])
            values = list(update_fields.values()) + [user_id]

            c.execute(f"""
                UPDATE puntos_usuarios
                SET {set_clause}
                WHERE user_id = %s
            """, values)

            rows_updated = c.rowcount
            logger.info(f"üìù Filas actualizadas en puntos_usuarios: {rows_updated}")

            # Registrar transacci√≥n
            c.execute("""
                INSERT INTO transacciones_puntos (user_id, puntos, tipo, descripcion, admin_id)
                VALUES (%s, %s, %s, %s, %s)
            """, (user_id, puntos, tipo, descripcion, admin_id))

            logger.info(f"üíæ Transacci√≥n registrada en transacciones_puntos")

            conn.commit()
            logger.info(f"‚úÖ {puntos} puntos otorgados exitosamente a {username_norm} (user_id: {user_id}, tipo: {tipo})")
            return True

    except psycopg2.Error as e:
        logger.error(f"‚ö†Ô∏è Error de base de datos otorgando puntos a {user_id}: {str(e)}")
        if conn:
            conn.rollback()
        return False
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error inesperado otorgando puntos a {user_id}: {str(e)}", exc_info=True)
        if conn:
            conn.rollback()
        return False
    finally:
        if conn:
            release_db_connection(conn)

def obtener_recompensas_disponibles():
    """Obtiene recompensas activas, evitando duplicados por nombre/descripcion/costo."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT DISTINCT ON (LOWER(nombre), costo_puntos, LOWER(descripcion))
                           id, nombre, descripcion, costo_puntos
                    FROM recompensas_disponibles
                    WHERE activa = TRUE
                    ORDER BY LOWER(nombre), costo_puntos, LOWER(descripcion), id ASC
                """)
                results = c.fetchall()
                return [
                    {
                        "id": row["id"],
                        "nombre": row["nombre"],
                        "descripcion": row["descripcion"],
                        "costo_puntos": row["costo_puntos"]
                    }
                    for row in results
                ]
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo recompensas: {str(e)}")
        return []

def canjear_recompensa(user_id, username, recompensa_id):
    """Canjea una recompensa por puntos."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Obtener puntos del usuario
                c.execute("SELECT puntos_totales FROM puntos_usuarios WHERE user_id = %s", (user_id,))
                result = c.fetchone()
                if not result:
                    return False, "Usuario no encontrado en sistema de puntos"

                puntos_usuario = result["puntos_totales"]

                # Obtener costo de la recompensa
                c.execute("""
                    SELECT nombre, costo_puntos, activa
                    FROM recompensas_disponibles
                    WHERE id = %s
                """, (recompensa_id,))
                recompensa = c.fetchone()

                if not recompensa:
                    return False, "Recompensa no encontrada"

                if not recompensa["activa"]:
                    return False, "Recompensa no disponible"

                if puntos_usuario < recompensa["costo_puntos"]:
                    return False, f"Puntos insuficientes. Necesitas {recompensa['costo_puntos']} puntos"

                # Registrar canje
                c.execute("""
                    INSERT INTO recompensas_canjeadas (user_id, recompensa_id, puntos_gastados)
                    VALUES (%s, %s, %s)
                """, (user_id, recompensa_id, recompensa["costo_puntos"]))

                # Restar puntos
                otorgar_puntos(user_id, username, -recompensa["costo_puntos"], "canje_recompensa",
                             f"Canje: {recompensa['nombre']}")

                conn.commit()

        logger.info(f"‚úÖ Recompensa {recompensa['nombre']} canjeada por {username}")
        return True, f"¬°Recompensa '{recompensa['nombre']}' canjeada exitosamente!"
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error canjeando recompensa: {str(e)}")
        return False, "Error al procesar el canje"

def obtener_recompensa_por_id(recompensa_id):
    """Obtiene una recompensa espec√≠fica por su ID."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT id, nombre, descripcion, costo_puntos, activa
                    FROM recompensas_disponibles
                    WHERE id = %s
                """, (recompensa_id,))
                result = c.fetchone()
                if result:
                    return {
                        "id": result["id"],
                        "nombre": result["nombre"],
                        "descripcion": result["descripcion"],
                        "costo_puntos": result["costo_puntos"],
                        "activa": result["activa"]
                    }
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo recompensa por ID: {str(e)}")
        return None

def obtener_horario():
    """Alias para get_bot_schedule() - obtiene el horario configurado del bot."""
    return get_bot_schedule()

def obtener_estadisticas_puntos():
    """Obtiene estad√≠sticas generales del sistema de puntos."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Total de usuarios
                c.execute("SELECT COUNT(*) as total FROM puntos_usuarios")
                total_usuarios = c.fetchone()["total"]

                # Total de puntos otorgados
                c.execute("SELECT SUM(puntos_totales) as total FROM puntos_usuarios")
                total_puntos = c.fetchone()["total"] or 0

                # Distribuci√≥n por niveles
                c.execute("""
                    SELECT nivel, COUNT(*) as cantidad
                    FROM puntos_usuarios
                    GROUP BY nivel
                    ORDER BY
                        CASE nivel
                            WHEN 'leyenda' THEN 5
                            WHEN 'diamante' THEN 4
                            WHEN 'oro' THEN 3
                            WHEN 'plata' THEN 2
                            WHEN 'bronce' THEN 1
                        END DESC
                """)
                niveles_dist = c.fetchall()

                # Recompensas canjeadas
                c.execute("SELECT COUNT(*) as total FROM recompensas_canjeadas")
                total_canjes = c.fetchone()["total"]

                return {
                    "total_usuarios": total_usuarios,
                    "total_puntos": total_puntos,
                    "niveles": {row["nivel"]: row["cantidad"] for row in niveles_dist},
                    "total_canjes": total_canjes
                }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas de puntos: {str(e)}")
        return None

def crear_tablas_puntos():
    """Crea las tablas del sistema de puntos si no existen."""
    try:
        logger.info("üîß Verificando tablas del sistema de puntos...")

        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Verificar si la tabla puntos_usuarios existe
                c.execute("""
                    SELECT EXISTS (
                        SELECT FROM information_schema.tables
                        WHERE table_schema = 'public'
                        AND table_name = 'puntos_usuarios'
                    )
                """)
                existe = c.fetchone()[0]

                if existe:
                    logger.info("‚úÖ Tablas de puntos ya existen")
                    return True

                logger.info("üìù Creando tablas del sistema de puntos...")

                # Crear tabla puntos_usuarios
                c.execute("""
                    CREATE TABLE IF NOT EXISTS puntos_usuarios (
                        user_id bigint PRIMARY KEY,
                        username text NOT NULL,
                        puntos_totales integer DEFAULT 0 NOT NULL,
                        nivel text DEFAULT 'bronce' NOT NULL,
                        solicitudes_aprobadas integer DEFAULT 0 NOT NULL,
                        encuestas_completadas integer DEFAULT 0 NOT NULL,
                        racha_dias integer DEFAULT 0 NOT NULL,
                        ultima_actividad timestamptz DEFAULT now(),
                        created_at timestamptz DEFAULT now() NOT NULL,
                        updated_at timestamptz DEFAULT now() NOT NULL,
                        CONSTRAINT puntos_no_negativos CHECK (puntos_totales >= 0),
                        CONSTRAINT nivel_valido CHECK (nivel IN ('bronce', 'plata', 'oro', 'diamante', 'leyenda'))
                    )
                """)

                # Crear tabla transacciones_puntos
                c.execute("""
                    CREATE TABLE IF NOT EXISTS transacciones_puntos (
                        id bigserial PRIMARY KEY,
                        user_id bigint NOT NULL,
                        puntos integer NOT NULL,
                        tipo text NOT NULL,
                        descripcion text NOT NULL,
                        admin_id bigint,
                        created_at timestamptz DEFAULT now() NOT NULL,
                        CONSTRAINT tipo_transaccion_valido CHECK (tipo IN (
                            'solicitud_aprobada', 'encuesta_completada', 'racha_semanal',
                            'bono_admin', 'canje_recompensa', 'penalizacion', 'ajuste_manual'
                        ))
                    )
                """)

                # Crear tabla recompensas_disponibles
                c.execute("""
                    CREATE TABLE IF NOT EXISTS recompensas_disponibles (
                        id serial PRIMARY KEY,
                        nombre text NOT NULL,
                        descripcion text NOT NULL,
                        costo_puntos integer NOT NULL,
                        activa boolean DEFAULT true NOT NULL,
                        created_at timestamptz DEFAULT now() NOT NULL,
                        updated_at timestamptz DEFAULT now() NOT NULL,
                        CONSTRAINT costo_positivo CHECK (costo_puntos > 0)
                    )
                """)

                # Crear tabla recompensas_canjeadas
                c.execute("""
                    CREATE TABLE IF NOT EXISTS recompensas_canjeadas (
                        id bigserial PRIMARY KEY,
                        user_id bigint NOT NULL,
                        recompensa_id integer NOT NULL,
                        puntos_gastados integer NOT NULL,
                        estado text DEFAULT 'pendiente' NOT NULL,
                        canjeado_at timestamptz DEFAULT now() NOT NULL,
                        procesado_at timestamptz,
                        CONSTRAINT estado_canje_valido CHECK (estado IN ('pendiente', 'procesado', 'rechazado', 'expirado'))
                    )
                """)

                # Crear √≠ndices
                c.execute("CREATE INDEX IF NOT EXISTS idx_puntos_usuarios_nivel ON puntos_usuarios(nivel)")
                c.execute("CREATE INDEX IF NOT EXISTS idx_puntos_usuarios_puntos ON puntos_usuarios(puntos_totales DESC)")
                c.execute("CREATE INDEX IF NOT EXISTS idx_transacciones_user ON transacciones_puntos(user_id, created_at DESC)")
                c.execute("CREATE INDEX IF NOT EXISTS idx_transacciones_tipo ON transacciones_puntos(tipo)")
                c.execute("CREATE INDEX IF NOT EXISTS idx_recompensas_activas ON recompensas_disponibles(activa) WHERE activa = true")
                c.execute("CREATE INDEX IF NOT EXISTS idx_recompensas_canjeadas_user ON recompensas_canjeadas(user_id, canjeado_at DESC)")
                c.execute("CREATE INDEX IF NOT EXISTS idx_recompensas_canjeadas_estado ON recompensas_canjeadas(estado)")

                # Insertar recompensas por defecto solo si la tabla est√° vac√≠a
                c.execute("SELECT COUNT(*) as count FROM recompensas_disponibles")
                count_result = c.fetchone()
                if count_result["count"] == 0:
                    c.execute("""
                        INSERT INTO recompensas_disponibles (nombre, descripcion, costo_puntos, activa) VALUES
                        ('Solicitud Prioritaria', 'Tu pr√≥xima solicitud se procesar√° con prioridad', 100, true),
                        ('Solicitud Extra', 'Aumenta tu l√≠mite de solicitudes activas en 1', 200, true),
                        ('Insignia Especial', 'Recibe una insignia especial en tu perfil', 300, true),
                        ('Acceso VIP 1 Semana', 'Acceso prioritario durante 1 semana', 500, true),
                        ('Menci√≥n Especial', 'Menci√≥n especial en el reporte semanal', 150, true)
                    """)

                conn.commit()
                logger.info("‚úÖ Tablas del sistema de puntos creadas exitosamente")
                return True

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error creando tablas de puntos: {str(e)}")
        return False

def sincronizar_puntos_usuarios():
    """Sincroniza puntos de usuarios bas√°ndose en su actividad hist√≥rica."""
    try:
        logger.info("üîÑ Iniciando sincronizaci√≥n de puntos de usuarios...")

        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Obtener todos los usuarios con actividad
                c.execute("""
                    SELECT DISTINCT u.user_id, u.username
                    FROM usuarios u
                    ORDER BY u.user_id
                """)
                usuarios = c.fetchall()

                usuarios_procesados = 0
                puntos_otorgados = 0

                for usuario in usuarios:
                    user_id = usuario["user_id"]
                    username = usuario["username"] or f"usuario_{user_id}"

                    # Verificar si ya tiene puntos registrados
                    c.execute("SELECT user_id FROM puntos_usuarios WHERE user_id = %s", (user_id,))
                    ya_existe = c.fetchone()

                    if ya_existe:
                        continue  # Saltar usuarios que ya tienen puntos

                    # Calcular puntos basados en actividad
                    puntos_total = 0

                    # 1. Puntos por solicitudes aprobadas (50 pts c/u)
                    c.execute("""
                        SELECT COUNT(*) as total
                        FROM historial_solicitudes
                        WHERE user_id = %s AND estado = 'subido'
                    """, (user_id,))
                    solicitudes_aprobadas = c.fetchone()["total"]
                    puntos_solicitudes = solicitudes_aprobadas * 50
                    puntos_total += puntos_solicitudes

                    # 2. Puntos por encuestas completadas (10 pts c/u)
                    c.execute("""
                        SELECT COUNT(*) as total
                        FROM encuestas_satisfaccion
                        WHERE user_id = %s
                    """, (user_id,))
                    encuestas = c.fetchone()["total"]
                    puntos_encuestas = encuestas * 10
                    puntos_total += puntos_encuestas

                    # 3. Penalizaci√≥n por peticiones incorrectas (-5 pts c/u)
                    c.execute("""
                        SELECT COUNT(*) as total
                        FROM peticiones_incorrectas
                        WHERE user_id = %s
                    """, (user_id,))
                    incorrectas = c.fetchone()["total"]
                    penalizacion = incorrectas * 5
                    puntos_total = max(0, puntos_total - penalizacion)

                    # Solo crear usuarios que tienen actividad
                    if solicitudes_aprobadas > 0 or encuestas > 0:
                        # Calcular nivel
                        nivel = calcular_nivel(puntos_total)

                        # Insertar usuario con puntos
                        c.execute("""
                            INSERT INTO puntos_usuarios
                            (user_id, username, puntos_totales, nivel, solicitudes_aprobadas,
                             encuestas_completadas, racha_dias, created_at, updated_at, ultima_actividad)
                            VALUES (%s, %s, %s, %s, %s, %s, 0, NOW(), NOW(), NOW())
                            ON CONFLICT (user_id) DO NOTHING
                        """, (user_id, username, puntos_total, nivel, solicitudes_aprobadas, encuestas))

                        # Registrar transacci√≥n inicial
                        if puntos_total > 0:
                            c.execute("""
                                INSERT INTO transacciones_puntos
                                (user_id, puntos, tipo, descripcion, created_at)
                                VALUES (%s, %s, 'ajuste_manual', %s, NOW())
                            """, (user_id, puntos_total,
                                  f"Sincronizaci√≥n inicial: {solicitudes_aprobadas} solicitudes aprobadas, {encuestas} encuestas"))

                        usuarios_procesados += 1
                        puntos_otorgados += puntos_total

                        logger.info(f"‚úÖ Usuario @{username} sincronizado: {puntos_total} pts (nivel {nivel})")

                conn.commit()

                logger.info(f"‚úÖ Sincronizaci√≥n completada: {usuarios_procesados} usuarios procesados, {puntos_otorgados} puntos totales otorgados")
                return usuarios_procesados, puntos_otorgados

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en sincronizaci√≥n de puntos: {str(e)}")
        return 0, 0

# Estados para conversaciones
ASKING_LINK, CONFIRM_LINK = range(2)
SELECT_DAYS, INPUT_START_HOUR, INPUT_END_HOUR, FINAL_CONFIRMATION = range(4)
ASKING_REASON, CONFIRM_REASON = range(2, 4)
ASKING_DELETION_REASON, CONFIRM_DELETION = range(6, 8)
ASKING_NOTIFICATION_CONFIG = 5
ASKING_USER_SEARCH = 6
ASKING_MAINTENANCE_MESSAGE, ASKING_MAINTENANCE_START, ASKING_MAINTENANCE_END = range(7, 10)

# Funci√≥n para cargar configuraci√≥n desde variables de entorno
def load_channels_config():
    """Carga la configuraci√≥n de canales desde variables de entorno."""
    try:
        canales_json = os.getenv("CANALES_PETICIONES_JSON")
        if canales_json:
            canales_json = canales_json.replace('\\"', '"').replace('\\n', '').replace('    ', '')
            canales_data = json.loads(canales_json)
            return {int(k): v for k, v in canales_data.items()}

        logger.warning("‚ö†Ô∏è CANALES_PETICIONES_JSON no encontrado, usando configuraci√≥n por defecto")
        return {
            -1002350263641: {"chat_id": -1002350263641, "thread_id": 19},
            -1001886336551: {"chat_id": -1001886336551, "thread_id": 652},
            -1001918569531: {"chat_id": -1001918569531, "thread_id": 228298},
            -1002570010967: {"chat_id": -1002570010967, "thread_id": 10},
        }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error cargando configuraci√≥n de canales: {str(e)}")
        logger.warning("‚ö†Ô∏è Usando configuraci√≥n por defecto")
        return {
            -1002350263641: {"chat_id": -1002350263641, "thread_id": 19},
            -1001886336551: {"chat_id": -1001886336551, "thread_id": 652},
            -1001918569531: {"chat_id": -1001918569531, "thread_id": 228298},
            -1002570010967: {"chat_id": -1002570010967, "thread_id": 10},
        }

def load_groups_names():
    """Carga los nombres de grupos desde variables de entorno."""
    try:
        grupos_json = os.getenv("GRUPOS_NOMBRES")
        if grupos_json:
            grupos_data = json.loads(grupos_json)
            return {int(k): v for k, v in grupos_data.items()}
        
        logger.warning("‚ö†Ô∏è GRUPOS_NOMBRES no encontrado, usando nombres por defecto")
        return {
            -1002350263641: "üìö Biblioteca EnTresHijos",
            -1001886336551: "üîí Biblioteca Privada EntresHijos",
            -1001918569531: "üé• SALA DE ENTRESHIJOS",
            -1002570010967: "üñ§ ùëΩùë®ùëπùë∞ùë∂ùë∫",
        }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error cargando nombres de grupos: {str(e)}")
        return {
            -1002350263641: "üìö Biblioteca EnTresHijos",
            -1001886336551: "üîí Biblioteca Privada EntresHijos",
            -1001918569531: "üé• SALA DE ENTRESHIJOS",
            -1002570010967: "üñ§ ùëΩùë®ùëπùë∞ùë∂ùë∫",
        }

# Cargar configuraciones
CANALES_PETICIONES = load_channels_config()
GRUPOS_PREDEFINIDOS = load_groups_names()

RESPALDO_LINK = "https://t.me/+egj5p8afYgE5ODg0"  # Enlace con aprobaci√≥n manual requerida
GROUP_RESPALDO = -1001923517187  # ID del grupo de respaldo

logger.info(f"‚úÖ Canales configurados: {list(CANALES_PETICIONES.keys())}")
logger.info(f"‚úÖ Grupos configurados: {list(GRUPOS_PREDEFINIDOS.keys())}")
logger.info(f"‚úÖ Administradores configurados: {len(ADMINISTRATORS)}")

VALID_REQUEST_COMMANDS = [
    "/solicito", "/SOLICITO", "/Solicito", "/sol√≠cito", "/Sol√≠cito", "/SOL√çCITO",
    "#solicito", "#SOLICITO", "#Solicito", "#Sol√≠cito", "#sol√≠cito", "#SOL√çCITO",
    "/peticion", "/PETICION", "/Peticion", "/Petici√≥n", "/petici√≥n", "/PETICI√ìN",
    "#peticion", "#PETICION", "#Peticion", "#Petici√≥n", "#petici√≥n", "#PETICI√ìN",
]

PING_RESPONSES = [
    "üì° *¬°Pong!* El bot est√° operativo y listo para asistirte. üòä",
    "‚úÖ *¬°Pong!* Todo en orden, aqu√≠ para ayudarte. ü§ù",
    "üîß *¬°Pong!* Sistema activo y funcionando correctamente. üìå",
    "üì≤ *¬°Pong!* Conexi√≥n estable, a tu disposici√≥n. ‚úÖ"
]

# SISTEMA AVANZADO DE DETECCI√ìN DE DUPLICADOS

def calculate_text_similarity(text1: str, text2: str) -> float:
    """
    Calcula la similitud entre dos textos usando algoritmos avanzados.
    Precisi√≥n mejorada: 95%+ con detecci√≥n de sin√≥nimos y variaciones.
    """
    if not text1 or not text2:
        return 0.0

    import re

    # Normalizaci√≥n avanzada
    text1 = re.sub(r'\s+', ' ', text1.lower().strip())
    text2 = re.sub(r'\s+', ' ', text2.lower().strip())

    # Igualdad exacta
    if text1 == text2:
        return 1.0

    # Normalizaci√≥n con sin√≥nimos y variaciones comunes
    synonyms_map = {
        'pel√≠cula': 'pelicula', 'serie': 'serie', 'libro': 'libro',
        'temporada': 'temp', 'cap√≠tulo': 'cap', 'episodio': 'ep',
        'espa√±ol': 'esp', 'ingl√©s': 'ing', 'subt√≠tulos': 'sub',
        'subtitulos': 'sub', 'doblada': 'doblado', 'latino': 'lat'
    }

    for original, replacement in synonyms_map.items():
        text1 = text1.replace(original, replacement)
        text2 = text2.replace(original, replacement)

    # Remover caracteres especiales
    text1_clean = re.sub(r'[^\w\s]', '', text1)
    text2_clean = re.sub(r'[^\w\s]', '', text2)

    if text1_clean == text2_clean:
        return 1.0

    # Detecci√≥n de contenci√≥n completa
    len_ratio = min(len(text1), len(text2)) / max(len(text1), len(text2))
    if (text1 in text2 or text2 in text1) and len_ratio >= 0.80:
        return 0.95

    # Stop words expandidas
    stop_words = {
        'el', 'la', 'de', 'que', 'y', 'a', 'en', 'un', 'es', 'se', 'no', 'te', 'lo', 'le', 'da', 'su', 'por', 'son',
        'con', 'para', 'al', 'del', 'los', 'las', 'una', 'pelicula', 'serie', 'libro', 'solicito', 'peticion',
        'busco', 'necesito', 'quiero', 'me', 'mi', 'tu', 'si', 'o', 'hace', 'hacer', 'ver', 'tiene', 'tengo',
        'hay', 'hola', 'gracias', 'favor', 'puede', 'pueden', 'puedo', 'a√±o', 'a√±os', 'temporada', 'cap',
        'capitulo', 'episodio', 'parte', 'vol', 'volumen', 'alguien', 'tiene', 'sabe', 'donde', 'como'
    }

    # Extraer caracter√≠sticas: palabras + bigramas + trigramas
    def get_advanced_features(text):
        words = [w for w in text.split() if len(w) > 2 and w not in stop_words]

        # Palabras significativas
        features = set(words)

        # Bigramas (pares de palabras consecutivas)
        if len(words) > 1:
            bigrams = [f"{words[i]}_{words[i+1]}" for i in range(len(words)-1)]
            features.update(bigrams)

        # Trigramas (tr√≠os de palabras) para mejor contexto
        if len(words) > 2:
            trigrams = [f"{words[i]}_{words[i+1]}_{words[i+2]}" for i in range(len(words)-2)]
            features.update(trigrams)

        # N√∫meros (importante para series/temporadas)
        numbers = re.findall(r'\d+', text)
        features.update([f"num_{n}" for n in numbers])

        return features

    features1 = get_advanced_features(text1_clean)
    features2 = get_advanced_features(text2_clean)

    # Si no hay caracter√≠sticas, usar caracteres
    if not features1 or not features2:
        features1 = set(text1_clean.replace(' ', ''))
        features2 = set(text2_clean.replace(' ', ''))

    # Similitud de Jaccard mejorada
    intersection = len(features1.intersection(features2))
    union = len(features1.union(features2))

    if union == 0:
        return 0.0

    jaccard_similarity = intersection / union

    # Similitud de longitud
    length_similarity = min(len(text1), len(text2)) / max(len(text1), len(text2))

    # Calcular similitud de subsecuencias (detecta orden de palabras)
    def longest_common_subsequence(s1, s2):
        words1 = s1.split()
        words2 = s2.split()
        m, n = len(words1), len(words2)

        if m == 0 or n == 0:
            return 0

        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if words1[i-1] == words2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])

        return dp[m][n] / max(m, n)

    lcs_similarity = longest_common_subsequence(text1_clean, text2_clean)

    # Combinar m√©tricas: 50% Jaccard, 25% LCS, 25% longitud
    combined_similarity = (jaccard_similarity * 0.50) + (lcs_similarity * 0.25) + (length_similarity * 0.25)

    # Penalizaci√≥n si la similitud es alta pero las longitudes muy diferentes
    if jaccard_similarity > 0.8 and length_similarity < 0.5:
        combined_similarity *= 0.80

    # Boost si hay n√∫meros coincidentes (importante para series/temporadas)
    numbers1 = set(re.findall(r'\d+', text1))
    numbers2 = set(re.findall(r'\d+', text2))
    if numbers1 and numbers2 and numbers1 == numbers2:
        combined_similarity = min(1.0, combined_similarity * 1.10)

    return combined_similarity

def get_duplicate_detection_settings():
    """Obtiene la configuraci√≥n del sistema de detecci√≥n de duplicados."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT value FROM bot_settings 
                    WHERE key = 'duplicate_detection_enabled'
                    ORDER BY updated_at DESC LIMIT 1
                """)
                result = c.fetchone()
                if result:
                    enabled = result["value"].lower() == "true"
                    logger.info(f"üîç Configuraci√≥n de duplicados desde BD: {enabled}")
                    return enabled
                logger.info("üîç No hay configuraci√≥n de duplicados en BD, usando por defecto: True")
                return True  # Por defecto habilitado
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener configuraci√≥n de duplicados: {str(e)}")
        logger.info("üîç Error en BD, usando configuraci√≥n por defecto: True")
        return True

def set_duplicate_detection_settings(enabled: bool):
    """Configura el sistema de detecci√≥n de duplicados."""
    global duplicate_detection_enabled
    duplicate_detection_enabled = enabled
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO bot_settings (key, value, updated_at) 
                    VALUES ('duplicate_detection_enabled', %s, %s)
                    ON CONFLICT (key) DO UPDATE SET 
                    value = EXCLUDED.value, updated_at = EXCLUDED.updated_at
                """, (str(enabled).lower(), datetime.now(SPAIN_TZ)))
                conn.commit()
        logger.info(f"‚úÖ Detecci√≥n de duplicados {'habilitada' if enabled else 'deshabilitada'}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al configurar detecci√≥n de duplicados: {str(e)}")

def get_duplicate_threshold():
    """Obtiene el umbral de similitud configurado."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT value FROM bot_settings 
                    WHERE key = 'duplicate_similarity_threshold'
                    ORDER BY updated_at DESC LIMIT 1
                """)
                result = c.fetchone()
                if result:
                    return float(result["value"])
                return 0.9  # Umbral al 90% por defecto
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener umbral de duplicados: {str(e)}")
        return 0.9  # Umbral al 90% por defecto

def set_duplicate_threshold(threshold: float):
    """Configura el umbral de similitud para duplicados."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO bot_settings (key, value, updated_at) 
                    VALUES ('duplicate_similarity_threshold', %s, %s)
                    ON CONFLICT (key) DO UPDATE SET 
                    value = EXCLUDED.value, updated_at = EXCLUDED.updated_at
                """, (str(threshold), datetime.now(SPAIN_TZ)))
                conn.commit()
        logger.info(f"‚úÖ Umbral de duplicados configurado a {threshold}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al configurar umbral de duplicados: {str(e)}")

def check_for_duplicates(user_id: int, message_text: str, chat_id: int) -> List[Dict]:
    """Busca solicitudes similares: TODAS las aprobadas, y solo 30 d√≠as para denegadas/eliminadas."""
    # Verificar duplicados globalmente para usuarios no administradores
    if user_id in ADMINISTRATORS:
        logger.info(f"üîç Saltando verificaci√≥n de duplicados para administrador {user_id}")
        return []

    logger.info(f"üîç Iniciando verificaci√≥n INTELIGENTE de duplicados para user_id={user_id}")
    logger.info(f"üîç Texto a verificar: {message_text[:100]}...")

    try:
        threshold = get_duplicate_threshold()
        logger.info(f"üîç Umbral de similitud: {threshold}")
        time_window_30_days = datetime.now(SPAIN_TZ) - timedelta(days=30)
        logger.info(f"üîç Ventana de 30 d√≠as (denegadas/eliminadas): desde {time_window_30_days}")

        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Buscar TODAS las solicitudes pendientes (sin l√≠mite de tiempo)
                c.execute("""
                    SELECT ticket_number, message_text, chat_title, timestamp, username, user_id, 'pendiente' as estado
                    FROM peticiones_registradas
                    ORDER BY timestamp DESC
                """)

                pending_requests = c.fetchall()
                logger.info(f"üîç Solicitudes pendientes encontradas (TODAS): {len(pending_requests)}")

                # Buscar en historial: TODAS las aprobadas, solo 30 d√≠as para denegadas/eliminadas
                c.execute("""
                    SELECT ticket_number, message_text, chat_title, fecha_gestion as timestamp, username, user_id, estado
                    FROM historial_solicitudes
                    WHERE estado = 'subido'
                       OR (estado IN ('denegado', 'eliminado') AND fecha_gestion >= %s)
                    ORDER BY fecha_gestion DESC
                """, (time_window_30_days,))

                history_requests = c.fetchall()
                logger.info(f"üîç Solicitudes en historial encontradas (TODAS aprobadas + 30d denegadas/eliminadas): {len(history_requests)}")
        
        duplicates = []
        all_requests = list(pending_requests) + list(history_requests)
        logger.info(f"üîç Total de solicitudes a comparar (sistema completo): {len(all_requests)}")
        
        # Normalizar el texto de entrada para comparaci√≥n
        normalized_input = message_text.lower().strip()
        
        for request in all_requests:
            # Saltar si es del mismo usuario (opcional - puedes comentar esta l√≠nea si quieres detectar auto-duplicados tambi√©n)
            if request["user_id"] == user_id:
                continue
                
            request_text = request["message_text"] or ""
            similarity = calculate_text_similarity(normalized_input, request_text.lower().strip())
            logger.info(f"üîç Comparando con ticket #{request['ticket_number']} (user: {request['username']}): similitud {similarity:.2f}")
            
            if similarity >= threshold:
                logger.info(f"‚ö†Ô∏è DUPLICADO GLOBAL detectado: ticket #{request['ticket_number']} (user: {request['username']}) con similitud {similarity:.2f}")
                duplicates.append({
                    "ticket_number": request["ticket_number"],
                    "message_text": request["message_text"],
                    "chat_title": request["chat_title"],
                    "timestamp": request["timestamp"],
                    "estado": request["estado"],
                    "username": request["username"],
                    "user_id": request["user_id"],
                    "similarity": similarity
                })
        
        # Ordenar por similitud descendente
        duplicates.sort(key=lambda x: x["similarity"], reverse=True)
        logger.info(f"üîç Total de duplicados GLOBALES encontrados: {len(duplicates)}")
        return duplicates[:5]  # M√°ximo 5 duplicados
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al buscar duplicados globales: {str(e)}")
        return []

async def send_duplicate_rejection(context: ContextTypes.DEFAULT_TYPE, chat_id: int, thread_id: int,
                                 user_id: int, username: str, message_text: str, 
                                 duplicates: List[Dict]):
    """Env√≠a mensaje de rechazo por duplicado detectado."""
    try:
        username_escaped = escape_markdown(username, preserve_username=True)
        message_text_escaped = escape_markdown(message_text[:100] + "..." if len(message_text) > 100 else message_text)
        
        # Tomar solo el duplicado m√°s similar
        top_duplicate = duplicates[0]
        similarity_percent = int(top_duplicate["similarity"] * 100)
        timestamp_str = top_duplicate["timestamp"].strftime("%d/%m %H:%M")
        dup_text_preview = top_duplicate["message_text"][:80] + "..." if len(top_duplicate["message_text"]) > 80 else top_duplicate["message_text"]
        
        estado_emoji = {
            "pendiente": "‚è≥",
            "subido": "‚úÖ",
            "denegado": "‚ùå",
            "eliminado": "üóëÔ∏è",
            "cancelado": "üîÑ"
        }.get(top_duplicate["estado"].lower(), "üìã")
        
        duplicate_username = top_duplicate.get("username", "Usuario desconocido")
        duplicate_username_escaped = escape_markdown(duplicate_username, preserve_username=True)
        
        rejection_text = (
            f"üö´ *Solicitud Duplicada Detectada* üö´\n\n"
            f"Hola {username_escaped}, hemos detectado que tu solicitud es muy similar a una existente en el sistema:\n\n"
            f"üìù **Tu nueva solicitud:**\n"
            f"‚úâÔ∏è {message_text_escaped}\n\n"
            f"üîç **Solicitud similar encontrada:**\n"
            f"{estado_emoji} **Ticket #{top_duplicate['ticket_number']}** ({similarity_percent}% similar)\n"
            f"üë§ **Usuario:** {duplicate_username_escaped}\n"
            f"üìù **Contenido:** {escape_markdown(dup_text_preview)}\n"
            f"üìç **Grupo:** {escape_markdown(top_duplicate['chat_title'])}\n"
            f"üìä **Estado:** {top_duplicate['estado'].capitalize()}\n"
            f"‚è∞ **Fecha:** {timestamp_str}\n\n"
            f"üí° **¬øQu√© puedes hacer?**\n"
            f"‚Ä¢ Espera a que se procese la solicitud similar existente\n"
            f"‚Ä¢ Si es diferente, reformula tu solicitud con m√°s detalles espec√≠ficos\n"
            f"‚Ä¢ Contacta con @admin si crees que es un error\n\n"
            f"ü§ù *Sistema de Calidad EntresHijos* üõ°Ô∏è\n\n"
            f"‚è∞ *Este mensaje se auto-eliminar√° en 2 minutos*"
        )
        
        canal_info = CANALES_PETICIONES.get(chat_id, {"chat_id": chat_id, "thread_id": thread_id})
        
        rejection_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=rejection_text,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        
        # Registrar estad√≠stica de duplicado detectado
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        INSERT INTO duplicate_detections
                        (user_id, username, request_text, duplicate_ticket, similarity_score, chat_id, action_taken)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                    """, (user_id, username, message_text[:500], top_duplicate['ticket_number'],
                          similarity_percent, chat_id, 'rejected'))
                conn.commit()
            logger.info(f"üìä Estad√≠stica de duplicado registrada: user={username}, ticket={top_duplicate['ticket_number']}, similitud={similarity_percent}%")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error registrando estad√≠stica de duplicado: {str(e)}")

        if rejection_message:
            # Auto-eliminar despu√©s de 2 minutos
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], rejection_message.message_id, 120)
            )
        
        logger.info(f"üö´ Solicitud rechazada por duplicado global, {len(duplicates)} similares encontradas")
        return True
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error enviando rechazo por duplicado: {str(e)}")
        return False

async def show_duplicate_warning(context: ContextTypes.DEFAULT_TYPE, chat_id: int, thread_id: int,
                                user_id: int, username: str, message_text: str, 
                                duplicates: List[Dict], ticket_number: int) -> bool:
    """Muestra advertencia de duplicados con opciones para el usuario."""
    try:
        username_escaped = escape_markdown(username, preserve_username=True)
        message_text_escaped = escape_markdown(message_text[:100] + "..." if len(message_text) > 100 else message_text)
        
        duplicates_text = ""
        keyboard = []
        
        for i, dup in enumerate(duplicates[:3], 1):  # Mostrar m√°ximo 3
            estado_emoji = {
                "pendiente": "‚è≥",
                "subido": "‚úÖ",
                "denegado": "‚ùå",
                "eliminado": "üóëÔ∏è",
                "cancelado": "üîÑ"
            }.get(dup["estado"].lower(), "üìã")
            
            similarity_percent = int(dup["similarity"] * 100)
            timestamp_str = dup["timestamp"].strftime("%d/%m %H:%M")
            dup_text_preview = dup["message_text"][:50] + "..." if len(dup["message_text"]) > 50 else dup["message_text"]
            
            duplicates_text += (
                f"**{i}. {estado_emoji} Ticket #{dup['ticket_number']}** ({similarity_percent}% similar)\n"
                f"   üìù {escape_markdown(dup_text_preview)}\n"
                f"   üìç {escape_markdown(dup['chat_title'])}\n"
                f"   ‚è∞ {timestamp_str}\n\n"
            )
            
            # Bot√≥n para ver detalles del duplicado
            keyboard.append([
                InlineKeyboardButton(
                    f"üìã Ver #{dup['ticket_number']} ({similarity_percent}%)",
                    callback_data=f"view_duplicate_{dup['ticket_number']}_{ticket_number}"
                )
            ])
        
        # Opciones para el usuario
        keyboard.append([
            InlineKeyboardButton("‚úÖ Continuar Anyway", callback_data=f"continue_duplicate_{ticket_number}"),
            InlineKeyboardButton("‚ùå Cancelar Nueva", callback_data=f"cancel_duplicate_{ticket_number}")
        ])
        
        warning_text = (
            f"‚ö†Ô∏è *Posibles Solicitudes Duplicadas Detectadas* ‚ö†Ô∏è\n\n"
            f"Hola {username_escaped}, hemos detectado que tienes solicitudes similares recientes:\n\n"
            f"üìù **Tu nueva solicitud:**\n"
            f"‚úâÔ∏è {message_text_escaped}\n\n"
            f"üîç **Solicitudes similares encontradas:**\n\n"
            f"{duplicates_text}"
            f"üí° **¬øQu√© deseas hacer?**\n"
            f"‚Ä¢ **Continuar:** Si es diferente a las anteriores\n"
            f"‚Ä¢ **Cancelar:** Si es igual a alguna existente\n\n"
            f"ü§ù *Sistema de Calidad EntresHijos* üõ°Ô∏è"
        )
        
        canal_info = CANALES_PETICIONES.get(chat_id, {"chat_id": chat_id, "thread_id": thread_id})
        
        warning_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=warning_text,
            message_thread_id=canal_info["thread_id"],
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        
        if warning_message:
            # Guardar informaci√≥n para procesar la respuesta
            context.bot_data[f"duplicate_warning_{ticket_number}"] = {
                "message_id": warning_message.message_id,
                "user_id": user_id,
                "chat_id": chat_id,
                "thread_id": thread_id,
                "username": username,
                "message_text": message_text,
                "duplicates": duplicates,
                "timestamp": datetime.now(SPAIN_TZ)
            }
            
            # Auto-eliminar despu√©s de 5 minutos si no hay respuesta
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], warning_message.message_id, 300)
            )
        
        logger.info(f"‚ö†Ô∏è Advertencia de duplicados mostrada para ticket #{ticket_number}, {len(duplicates)} similares encontradas")
        return True
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error mostrando advertencia de duplicados: {str(e)}")
        return False
# FUNCIONES PARA GESTI√ìN DE MENSAJES DE CONFIRMACI√ìN

def save_confirmation_message(ticket_number: int, chat_id: int, message_id: int, user_id: int):
    """Guarda un mensaje de confirmaci√≥n en la base de datos."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO confirmation_messages (ticket_number, chat_id, message_id, user_id, created_at)
                    VALUES (%s, %s, %s, %s, %s)
                    ON CONFLICT DO NOTHING
                """, (ticket_number, chat_id, message_id, user_id, datetime.now(SPAIN_TZ)))
                conn.commit()
        
        # Tambi√©n guardar en memoria para acceso r√°pido
        confirmation_messages[ticket_number] = {
            "chat_id": chat_id,
            "message_id": message_id,
            "user_id": user_id,
            "created_at": datetime.now(SPAIN_TZ)
        }
        logger.info(f"‚úÖ Mensaje de confirmaci√≥n guardado para ticket #{ticket_number}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error guardando mensaje de confirmaci√≥n: {str(e)}")

def get_confirmation_message(ticket_number: int) -> Optional[dict]:
    """Obtiene un mensaje de confirmaci√≥n."""
    # Primero buscar en memoria
    if ticket_number in confirmation_messages:
        return confirmation_messages[ticket_number]
    
    # Si no est√° en memoria, buscar en BD
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT chat_id, message_id, user_id, created_at
                    FROM confirmation_messages 
                    WHERE ticket_number = %s AND is_deleted = FALSE
                    ORDER BY created_at DESC LIMIT 1
                """, (ticket_number,))
                result = c.fetchone()
                if result:
                    msg_data = dict(result)
                    confirmation_messages[ticket_number] = msg_data
                    return msg_data
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo mensaje de confirmaci√≥n: {str(e)}")
        return None

async def delete_confirmation_message(context: ContextTypes.DEFAULT_TYPE, ticket_number: int):
    """Elimina un mensaje de confirmaci√≥n cuando se gestiona la solicitud."""
    try:
        msg_data = get_confirmation_message(ticket_number)
        if msg_data:
            # Eliminar el mensaje
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=msg_data["chat_id"],
                message_id=msg_data["message_id"]
            )
            
            # Marcar como eliminado en BD
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        UPDATE confirmation_messages 
                        SET is_deleted = TRUE 
                        WHERE ticket_number = %s
                    """, (ticket_number,))
                    conn.commit()
            
            # Eliminar de memoria
            if ticket_number in confirmation_messages:
                del confirmation_messages[ticket_number]
            
            logger.info(f"‚úÖ Mensaje de confirmaci√≥n eliminado para ticket #{ticket_number}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error eliminando mensaje de confirmaci√≥n: {str(e)}")

# FUNCIONES PARA GESTI√ìN DE MANTENIMIENTO MEJORADO

def save_maintenance_message(chat_id: int, message_id: int, maintenance_id: int = None, message_type: str = "start"):
    """Guarda un mensaje de mantenimiento para eliminarlo despu√©s."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO maintenance_messages (chat_id, message_id, maintenance_id, message_type, created_at)
                    VALUES (%s, %s, %s, %s, %s)
                """, (chat_id, message_id, maintenance_id, message_type, datetime.now(SPAIN_TZ)))
                conn.commit()
        
        # Tambi√©n guardar en memoria
        key = f"{chat_id}_{message_id}"
        maintenance_messages[key] = {
            "chat_id": chat_id,
            "message_id": message_id,
            "maintenance_id": maintenance_id,
            "message_type": message_type,
            "created_at": datetime.now(SPAIN_TZ)
        }
        logger.info(f"‚úÖ Mensaje de mantenimiento guardado: {message_type}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error guardando mensaje de mantenimiento: {str(e)}")

async def delete_all_maintenance_messages(context: ContextTypes.DEFAULT_TYPE):
    """Elimina todos los mensajes de mantenimiento activos."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT chat_id, message_id 
                    FROM maintenance_messages 
                    WHERE message_type = 'start'
                    ORDER BY created_at DESC
                """)
                messages = c.fetchall()
        
        deleted_count = 0
        for msg in messages:
            success = await safe_bot_method(
                context.bot.delete_message,
                chat_id=msg["chat_id"],
                message_id=msg["message_id"]
            )
            if success:
                deleted_count += 1
        
        # Limpiar registros de BD
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM maintenance_messages WHERE message_type = 'start'")
                conn.commit()
        
        # Limpiar memoria
        maintenance_messages.clear()
        
        logger.info(f"‚úÖ Eliminados {deleted_count} mensajes de mantenimiento")
        return deleted_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error eliminando mensajes de mantenimiento: {str(e)}")
        return 0

async def send_maintenance_end_notification(context: ContextTypes.DEFAULT_TYPE):
    """Env√≠a notificaci√≥n de fin de mantenimiento que se auto-elimina en 5 minutos."""
    try:
        notification_text = (
            f"‚úÖ *¬°Mantenimiento Finalizado!* ‚úÖ\n\n"
            f"üîÑ El bot ha vuelto a la normalidad y est√° completamente operativo.\n"
            f"üìù Ya puedes enviar tus solicitudes normalmente usando */solicito* o *#peticion*.\n\n"
            f"‚è∞ *Reactivado:* {get_spain_time()}\n"
            f"üöÄ ¬°Gracias por tu paciencia y comprensi√≥n!\n\n"
            f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
            f"‚è∞ *Este mensaje se auto-eliminar√° en 5 minutos*"
        )
        
        results = await send_to_all_channels(context, notification_text)
        
        # Programar auto-eliminaci√≥n en 5 minutos
        for chat_id, message_id in results.items():
            if message_id:
                save_maintenance_message(chat_id, message_id, None, "end")
                context.application.create_task(
                    auto_delete_message(context, chat_id, message_id, 300)  # 5 minutos
                )
        
        successful_sends = sum(1 for result in results.values() if result is not None)
        logger.info(f"‚úÖ Notificaci√≥n de fin de mantenimiento enviada a {successful_sends} canales")
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error enviando notificaci√≥n de fin de mantenimiento: {str(e)}")

# FUNCIONES PARA NOTIFICACIONES AUTOM√ÅTICAS

def save_notification_message(chat_id: int, message_id: int, notification_type: str, auto_delete_minutes: int = None):
    """Guarda un mensaje de notificaci√≥n para rastrearlo y auto-eliminarlo."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                auto_delete_at = None
                if auto_delete_minutes:
                    auto_delete_at = datetime.now(SPAIN_TZ) + timedelta(minutes=auto_delete_minutes)
                
                c.execute("""
                    INSERT INTO notification_messages (chat_id, message_id, notification_type, created_at, auto_delete_at)
                    VALUES (%s, %s, %s, %s, %s)
                """, (chat_id, message_id, notification_type, datetime.now(SPAIN_TZ), auto_delete_at))
                conn.commit()
        
        logger.info(f"‚úÖ Mensaje de notificaci√≥n guardado: {notification_type} en chat {chat_id}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error guardando mensaje de notificaci√≥n: {str(e)}")

async def delete_notification_messages_by_type(context: ContextTypes.DEFAULT_TYPE, notification_type: str):
    """Elimina todos los mensajes de un tipo espec√≠fico de notificaci√≥n."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT chat_id, message_id 
                    FROM notification_messages 
                    WHERE notification_type = %s AND is_deleted = FALSE
                    ORDER BY created_at DESC
                """, (notification_type,))
                messages = c.fetchall()
        
        deleted_count = 0
        for msg in messages:
            success = await safe_bot_method(
                context.bot.delete_message,
                chat_id=msg["chat_id"],
                message_id=msg["message_id"]
            )
            if success:
                deleted_count += 1
        
        # Marcar como eliminados en BD
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    UPDATE notification_messages 
                    SET is_deleted = TRUE 
                    WHERE notification_type = %s AND is_deleted = FALSE
                """, (notification_type,))
                conn.commit()
        
        logger.info(f"‚úÖ Eliminados {deleted_count} mensajes de tipo {notification_type}")
        return deleted_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error eliminando mensajes de notificaci√≥n: {str(e)}")
        return 0

async def cleanup_expired_notification_messages(context: ContextTypes.DEFAULT_TYPE):
    """Limpia mensajes de notificaci√≥n que han expirado."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT chat_id, message_id 
                    FROM notification_messages 
                    WHERE auto_delete_at <= %s AND is_deleted = FALSE
                """, (datetime.now(SPAIN_TZ),))
                expired_messages = c.fetchall()
        
        deleted_count = 0
        for msg in expired_messages:
            success = await safe_bot_method(
                context.bot.delete_message,
                chat_id=msg["chat_id"],
                message_id=msg["message_id"]
            )
            if success:
                deleted_count += 1
        
        # Marcar como eliminados
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    UPDATE notification_messages 
                    SET is_deleted = TRUE 
                    WHERE auto_delete_at <= %s AND is_deleted = FALSE
                """, (datetime.now(SPAIN_TZ),))
                conn.commit()
        
        if deleted_count > 0:
            logger.info(f"‚úÖ Auto-eliminados {deleted_count} mensajes de notificaci√≥n expirados")
        
        return deleted_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en limpieza de mensajes expirados: {str(e)}")
        return 0

# ============================================
# SISTEMA DE ADVERTENCIAS POR HORARIO
# ============================================

def get_user_schedule_warnings(user_id: int, chat_id: int) -> dict:
    """Obtiene las advertencias de horario de un usuario en un chat espec√≠fico."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Obtener advertencias del usuario
                c.execute("""
                    SELECT warning_count, last_warning_at, is_muted, muted_at, unmute_at, last_warning_message_id
                    FROM schedule_warnings
                    WHERE user_id = %s AND chat_id = %s
                """, (user_id, chat_id))

                result = c.fetchone()
                conn.commit()

                if result:
                    return {
                        "warning_count": result[0],
                        "last_warning_at": result[1],
                        "is_muted": result[2],
                        "muted_at": result[3],
                        "unmute_at": result[4],
                        "last_warning_message_id": result[5]
                    }
                return {
                    "warning_count": 0,
                    "last_warning_at": None,
                    "is_muted": False,
                    "muted_at": None,
                    "unmute_at": None,
                    "last_warning_message_id": None
                }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo advertencias de horario: {str(e)}")
        return {"warning_count": 0, "last_warning_at": None, "is_muted": False, "muted_at": None, "unmute_at": None, "last_warning_message_id": None}

def increment_schedule_warning(user_id: int, chat_id: int, message_id: int = None) -> int:
    """Incrementa el contador de advertencias de horario y retorna el nuevo contador."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO schedule_warnings (user_id, chat_id, warning_count, last_warning_at, last_warning_message_id, updated_at)
                    VALUES (%s, %s, 1, %s, %s, %s)
                    ON CONFLICT (user_id, chat_id) DO UPDATE SET
                        warning_count = schedule_warnings.warning_count + 1,
                        last_warning_at = EXCLUDED.last_warning_at,
                        last_warning_message_id = EXCLUDED.last_warning_message_id,
                        updated_at = EXCLUDED.updated_at
                    RETURNING warning_count
                """, (user_id, chat_id, datetime.now(SPAIN_TZ), message_id, datetime.now(SPAIN_TZ)))

                new_count = c.fetchone()[0]
                conn.commit()
                return new_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error incrementando advertencias de horario: {str(e)}")
        return 0

async def mute_user_for_schedule_violation(context: ContextTypes.DEFAULT_TYPE, user_id: int, chat_id: int, username: str):
    """Silencia a un usuario por 7 d√≠as por violar el horario."""
    try:
        muted_at = datetime.now(SPAIN_TZ)
        unmute_at = muted_at + timedelta(days=7)

        # Actualizar estado en BD
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    UPDATE schedule_warnings
                    SET is_muted = TRUE,
                        muted_at = %s,
                        unmute_at = %s,
                        updated_at = %s
                    WHERE user_id = %s AND chat_id = %s
                """, (muted_at, unmute_at, datetime.now(SPAIN_TZ), user_id, chat_id))
                conn.commit()

        # Silenciar al usuario en el grupo
        await safe_bot_method(
            context.bot.restrict_chat_member,
            chat_id=chat_id,
            user_id=user_id,
            permissions=telegram.ChatPermissions(can_send_messages=False),
            until_date=unmute_at
        )

        # Restar puntos si el sistema est√° disponible
        if SISTEMA_PUNTOS_DISPONIBLE:
            otorgar_puntos(user_id, username, -50, "penalizacion",
                          "Penalizaci√≥n por petici√≥n fuera de horario (silencio 7 d√≠as)")

        logger.info(f"üîá Usuario {username} (ID: {user_id}) silenciado hasta {unmute_at.strftime('%d/%m/%Y %H:%M:%S')}")
        return True

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error silenciando usuario: {str(e)}")
        return False

async def unmute_user_schedule(context: ContextTypes.DEFAULT_TYPE, user_id: int, chat_id: int):
    """Desmutea a un usuario despu√©s de que expire su silencio."""
    try:
        # Restaurar permisos normales
        await safe_bot_method(
            context.bot.restrict_chat_member,
            chat_id=chat_id,
            user_id=user_id,
            permissions=telegram.ChatPermissions(
                can_send_messages=True,
                can_send_polls=True,
                can_send_other_messages=True,
                can_add_web_page_previews=True,
                can_change_info=False,
                can_invite_users=True,
                can_pin_messages=False
            )
        )

        # Actualizar BD - solo desmutear sin resetear warning_count a 0
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    UPDATE schedule_warnings
                    SET is_muted = FALSE,
                        updated_at = %s
                    WHERE user_id = %s AND chat_id = %s
                """, (datetime.now(SPAIN_TZ), user_id, chat_id))
                conn.commit()

        logger.info(f"üîä Usuario {user_id} desmuteado autom√°ticamente")
        return True

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error desmuteando usuario: {str(e)}")
        return False

async def check_and_unmute_users(context: ContextTypes.DEFAULT_TYPE):
    """Verifica y desmutea usuarios cuyo tiempo de silencio ha expirado."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT user_id, chat_id
                    FROM schedule_warnings
                    WHERE is_muted = TRUE AND unmute_at <= %s
                """, (datetime.now(SPAIN_TZ),))

                users_to_unmute = c.fetchall()

        for user_id, chat_id in users_to_unmute:
            await unmute_user_schedule(context, user_id, chat_id)

        if len(users_to_unmute) > 0:
            logger.info(f"‚úÖ {len(users_to_unmute)} usuarios desmuteados autom√°ticamente")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error verificando usuarios para desmutear: {str(e)}")

async def send_schedule_warning(context: ContextTypes.DEFAULT_TYPE, user_id: int, chat_id: int,
                                thread_id: int, username: str, warning_count: int,
                                previous_message_id: int = None) -> int:
    """Env√≠a advertencia al usuario por petici√≥n fuera de horario."""
    try:
        username_escaped = escape_markdown(username, preserve_username=True)
        canal_info = CANALES_PETICIONES.get(chat_id, {"chat_id": chat_id, "thread_id": thread_id})

        # Eliminar advertencia anterior si existe
        if previous_message_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=canal_info["chat_id"],
                message_id=previous_message_id
            )

        schedule = get_bot_schedule()
        days_str = ", ".join(schedule['days_of_week']) if schedule else "No configurado"
        hours_str = f"{schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00" if schedule else "No configurado"

        # Primera advertencia
        if warning_count == 1:
            warning_text = (
                f"‚ö†Ô∏è **ADVERTENCIA: Petici√≥n Fuera de Horario** ‚ö†Ô∏è\n\n"
                f"Hola {username_escaped},\n\n"
                f"Has realizado una petici√≥n **fuera del horario permitido**. "
                f"Esta es tu **primera advertencia**. üö®\n\n"
                f"üìã **Horario Actual del Bot:**\n"
                f"üìÖ **D√≠as:** {escape_markdown(days_str)}\n"
                f"üïê **Horario:** {escape_markdown(hours_str)}\n"
                f"üåç **Zona horaria:** Europe/Madrid\n\n"
                f"‚ö†Ô∏è **IMPORTANTE:**\n"
                f"‚Ä¢ Si realizas **una segunda petici√≥n fuera de horario**, ser√°s **silenciado por 7 d√≠as (1 semana)** autom√°ticamente.\n"
                f"‚Ä¢ Tambi√©n se te restar√°n **50 puntos** de tu cuenta.\n"
                f"‚Ä¢ Aseg√∫rate de enviar tus peticiones **solo durante el horario permitido**.\n\n"
                f"üí° **Recomendaciones:**\n"
                f"‚Ä¢ Consulta `/tiempo` para ver el horario actual\n"
                f"‚Ä¢ Lee las normas y mensajes fijados del grupo\n"
                f"‚Ä¢ Planifica tus peticiones dentro del horario\n\n"
                f"üôè Gracias por tu comprensi√≥n y colaboraci√≥n.\n\n"
                f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
            )
        else:
            # Segunda advertencia = silenciamiento
            warning_text = (
                f"üö´ **USUARIO SILENCIADO POR 7 D√çAS** üö´\n\n"
                f"Usuario {username_escaped} ha sido silenciado autom√°ticamente por realizar **peticiones reiteradas fuera del horario permitido**.\n\n"
                f"üìä **Detalles del Silenciamiento:**\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** `{user_id}`\n"
                f"üîá **Hora del muteo:** {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n"
                f"üîä **Hora del desmuteo:** {(datetime.now(SPAIN_TZ) + timedelta(days=7)).strftime('%d/%m/%Y %H:%M:%S')}\n"
                f"üí∞ **Penalizaci√≥n:** -50 puntos\n\n"
                f"üìã **Horario Permitido:**\n"
                f"üìÖ **D√≠as:** {escape_markdown(days_str)}\n"
                f"üïê **Horario:** {escape_markdown(hours_str)}\n"
                f"üåç **Zona horaria:** Europe/Madrid\n\n"
                f"üì¢ **RECORDATORIO PARA TODOS:**\n"
                f"‚Ä¢ Respeten el horario establecido para peticiones\n"
                f"‚Ä¢ Lean las normas del grupo y mensajes fijados\n"
                f"‚Ä¢ Las violaciones reiteradas pueden resultar en sanciones m√°s severas\n\n"
                f"üôè Gracias por mantener el orden en el grupo.\n\n"
                f"*Sistema Autom√°tico de Moderaci√≥n EntresHijos* üõ°Ô∏è"
            )

        warning_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=warning_text,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )

        if warning_message:
            message_id = warning_message.message_id

            # Si es la primera advertencia, auto-eliminar en 10 minutos
            # Si es el silenciamiento, dejarlo permanente (no auto-eliminar)
            if warning_count == 1:
                context.application.create_task(
                    auto_delete_message(context, canal_info["chat_id"], message_id, 600)  # 10 minutos
                )

            logger.info(f"‚ö†Ô∏è Advertencia #{warning_count} enviada a {username} en chat {chat_id}")
            return message_id

        return None

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error enviando advertencia de horario: {str(e)}")
        return None

async def notify_admins_schedule_mute(context: ContextTypes.DEFAULT_TYPE, user_id: int,
                                      chat_id: int, username: str):
    """Notifica a los administradores sobre el silenciamiento de un usuario."""
    try:
        username_escaped = escape_markdown(username, preserve_username=True)
        grupo_title = GRUPOS_PREDEFINIDOS.get(chat_id, f"Grupo {chat_id}")
        muted_at = datetime.now(SPAIN_TZ)
        unmute_at = muted_at + timedelta(hours=24)

        schedule = get_bot_schedule()
        days_str = ", ".join(schedule['days_of_week']) if schedule else "No configurado"
        hours_str = f"{schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00" if schedule else "No configurado"

        admin_notification = (
            f"üîá **USUARIO SILENCIADO AUTOM√ÅTICAMENTE** üîá\n\n"
            f"Un usuario ha sido silenciado por realizar **peticiones reiteradas fuera del horario permitido**.\n\n"
            f"üìä **Detalles del Silenciamiento:**\n"
            f"üë§ **Usuario:** {username_escaped}\n"
            f"üÜî **ID:** `{user_id}`\n"
            f"üìç **Grupo:** {escape_markdown(grupo_title)}\n"
            f"üîá **Hora del muteo:** {muted_at.strftime('%d/%m/%Y %H:%M:%S')}\n"
            f"üîä **Hora del desmuteo:** {unmute_at.strftime('%d/%m/%Y %H:%M:%S')}\n"
            f"‚è±Ô∏è **Duraci√≥n:** 7 d√≠as (1 semana)\n"
            f"üí∞ **Penalizaci√≥n aplicada:** -50 puntos\n\n"
            f"üìã **Horario Configurado:**\n"
            f"üìÖ **D√≠as:** {escape_markdown(days_str)}\n"
            f"üïê **Horario:** {escape_markdown(hours_str)}\n\n"
            f"‚öôÔ∏è **Acciones Aplicadas:**\n"
            f"‚Ä¢ ‚úÖ Usuario silenciado por 7 d√≠as\n"
            f"‚Ä¢ ‚úÖ Penalizaci√≥n de puntos aplicada\n"
            f"‚Ä¢ ‚úÖ Advertencias eliminadas del chat\n"
            f"‚Ä¢ ‚úÖ Desmuteo programado autom√°ticamente\n\n"
            f"üîÑ El usuario ser√° desmuteado autom√°ticamente cuando expire el tiempo.\n\n"
            f"*Sistema Autom√°tico de Moderaci√≥n EntresHijos* üõ°Ô∏è"
        )

        await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=admin_notification,
            parse_mode="Markdown"
        )

        logger.info(f"‚úÖ Notificaci√≥n de silenciamiento enviada a administradores para {username}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error notificando silenciamiento a administradores: {str(e)}")

def get_spain_real_time():
    """Obtiene la hora real actual de Espa√±a con precisi√≥n."""
    return datetime.now(SPAIN_TZ)

def is_exact_notification_time(target_hour: int, target_minute: int = 0) -> bool:
    """Verifica si es exactamente el momento para enviar una notificaci√≥n."""
    spain_time = get_spain_real_time()
    current_hour = spain_time.hour
    current_minute = spain_time.minute
    
    return current_hour == target_hour and current_minute == target_minute

def should_send_opening_reminder() -> bool:
    """Verifica si debe enviar recordatorio de apertura (5 minutos antes)."""
    schedule = get_bot_schedule()
    if not schedule:
        return False
    
    spain_time = get_spain_real_time()
    current_day = spain_time.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    
    if current_day_spanish not in schedule["days_of_week"]:
        return False
    
    # 5 minutos antes del horario de inicio
    target_hour = schedule["start_hour"]
    reminder_time = spain_time.replace(hour=target_hour, minute=0, second=0, microsecond=0) - timedelta(minutes=5)
    
    # Verificar si estamos en el minuto exacto del recordatorio
    return (spain_time.hour == reminder_time.hour and
            spain_time.minute == reminder_time.minute)

def should_send_closing_reminder() -> bool:
    """Verifica si debe enviar recordatorio de cierre (5 minutos antes)."""
    schedule = get_bot_schedule()
    if not schedule:
        return False
    
    spain_time = get_spain_real_time()
    current_day = spain_time.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    
    if current_day_spanish not in schedule["days_of_week"]:
        return False
    
    # 5 minutos antes del horario de cierre
    target_hour = schedule["end_hour"]
    reminder_time = spain_time.replace(hour=target_hour, minute=0, second=0, microsecond=0) - timedelta(minutes=5)
    
    # Verificar si estamos en el minuto exacto del recordatorio
    return (spain_time.hour == reminder_time.hour and
            spain_time.minute == reminder_time.minute)

def should_send_opening_notification() -> bool:
    """Verifica si debe enviar notificaci√≥n de apertura (hora exacta)."""
    schedule = get_bot_schedule()
    if not schedule:
        return False
    
    spain_time = get_spain_real_time()
    current_day = spain_time.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    
    if current_day_spanish not in schedule["days_of_week"]:
        return False
    
    # Hora exacta de apertura
    return is_exact_notification_time(schedule["start_hour"], 0)

def should_send_closing_notification() -> bool:
    """Verifica si debe enviar notificaci√≥n de cierre (hora exacta)."""
    schedule = get_bot_schedule()
    if not schedule:
        return False
    
    spain_time = get_spain_real_time()
    current_day = spain_time.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    
    if current_day_spanish not in schedule["days_of_week"]:
        return False
    
    # Hora exacta de cierre
    return is_exact_notification_time(schedule["end_hour"], 0)

def get_notification_settings():
    """Obtiene la configuraci√≥n de notificaciones autom√°ticas."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT enabled FROM notification_settings ORDER BY id DESC LIMIT 1")
                result = c.fetchone()
                return result["enabled"] if result else True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener configuraci√≥n de notificaciones: {str(e)}")
        return True

def set_notification_settings(enabled: bool):
    """Configura las notificaciones autom√°ticas."""
    global automatic_notifications_enabled
    automatic_notifications_enabled = enabled
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute(
                    "INSERT INTO notification_settings (enabled, updated_at) VALUES (%s, %s)",
                    (enabled, datetime.now(SPAIN_TZ))
                )
                conn.commit()
        logger.info(f"‚úÖ Notificaciones autom√°ticas {'habilitadas' if enabled else 'deshabilitadas'}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al configurar notificaciones: {str(e)}")

async def send_opening_reminder_notification(context: ContextTypes.DEFAULT_TYPE):
    """Env√≠a recordatorio de apertura (5 minutos antes)."""
    if not automatic_notifications_enabled:
        return
    
    if not should_send_opening_reminder():
        return
    
    schedule = get_bot_schedule()
    if not schedule:
        return
    
    # Eliminar recordatorios de cierre anteriores
    await delete_notification_messages_by_type(context, "closing_reminder")
    
    notification_text = (
        f"üîî *Recordatorio de Apertura* üîî\n\n"
        f"‚è∞ El bot comenzar√° a aceptar solicitudes en **5 minutos**\n"
        f"üìÖ D√≠as activos: {', '.join(schedule['days_of_week'])}\n"
        f"üïí Horario: {schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00\n\n"
        f"üìù Prepara tus solicitudes usando */solicito* o *#peticion*\n"
        f"‚è∞ *Hora actual:* {get_spain_real_time().strftime('%H:%M:%S')}\n"
        f"ü§ù *Equipo EntresHijos*"
    )
    
    results = await send_to_all_channels(context, notification_text)
    
    # Guardar mensajes para auto-eliminaci√≥n cuando termine el horario
    for chat_id, message_id in results.items():
        if message_id:
            save_notification_message(chat_id, message_id, "opening_reminder")
    
    successful_sends = sum(1 for result in results.values() if result is not None)
    
    logger.info(f"üîî Recordatorio de apertura enviado a {successful_sends}/{len(CANALES_PETICIONES)} canales")

async def send_opening_active_notification(context: ContextTypes.DEFAULT_TYPE):
    """Env√≠a notificaci√≥n de apertura activa (hora exacta)."""
    if not automatic_notifications_enabled:
        return
    
    if not should_send_opening_notification():
        return
    
    schedule = get_bot_schedule()
    if not schedule:
        return
    
    # Eliminar recordatorios de apertura
    await delete_notification_messages_by_type(context, "opening_reminder")
    
    notification_text = (
        f"üü¢ *¬°Solicitudes Abiertas!* üü¢\n\n"
        f"‚úÖ El bot ya est√° aceptando solicitudes\n"
        f"üìÖ D√≠as activos: {', '.join(schedule['days_of_week'])}\n"
        f"üïí Horario: {schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00\n\n"
        f"üìù Env√≠a tus solicitudes usando */solicito* o *#peticion*\n"
        f"‚è∞ *Hora actual:* {get_spain_real_time().strftime('%H:%M:%S')}\n"
        f"ü§ù *Equipo EntresHijos*"
    )
    
    results = await send_to_all_channels(context, notification_text)
    
    # Guardar mensajes para auto-eliminaci√≥n cuando termine el horario
    for chat_id, message_id in results.items():
        if message_id:
            save_notification_message(chat_id, message_id, "opening_active")
    
    successful_sends = sum(1 for result in results.values() if result is not None)
    
    logger.info(f"üü¢ Notificaci√≥n de apertura activa enviada a {successful_sends}/{len(CANALES_PETICIONES)} canales")

async def send_closing_reminder_notification(context: ContextTypes.DEFAULT_TYPE):
    """Env√≠a recordatorio de cierre (5 minutos antes)."""
    if not automatic_notifications_enabled:
        return
    
    if not should_send_closing_reminder():
        return
    
    schedule = get_bot_schedule()
    if not schedule:
        return
    
    notification_text = (
        f"‚è∞ *Recordatorio de Cierre* ‚è∞\n\n"
        f"üìù El bot dejar√° de aceptar solicitudes en **5 minutos**\n"
        f"üìÖ D√≠as activos: {', '.join(schedule['days_of_week'])}\n"
        f"üïí Horario: {schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00\n\n"
        f"‚ö° Env√≠a tus √∫ltimas solicitudes ahora\n"
        f"üì± Las solicitudes fuera de horario no ser√°n procesadas\n"
        f"‚è∞ *Hora actual:* {get_spain_real_time().strftime('%H:%M:%S')}\n"
        f"ü§ù *Equipo EntresHijos*"
    )
    
    results = await send_to_all_channels(context, notification_text)
    
    # Guardar mensajes para auto-eliminaci√≥n (se eliminan cuando se cierre)
    for chat_id, message_id in results.items():
        if message_id:
            save_notification_message(chat_id, message_id, "closing_reminder")
    
    successful_sends = sum(1 for result in results.values() if result is not None)
    
    logger.info(f"‚è∞ Recordatorio de cierre enviado a {successful_sends}/{len(CANALES_PETICIONES)} canales")

async def send_closing_active_notification(context: ContextTypes.DEFAULT_TYPE):
    """Env√≠a notificaci√≥n de cierre activo (hora exacta)."""
    if not automatic_notifications_enabled:
        return
    
    if not should_send_closing_notification():
        return
    
    schedule = get_bot_schedule()
    if not schedule:
        return
    
    # Eliminar mensajes de apertura y recordatorios de cierre
    await delete_notification_messages_by_type(context, "opening_active")
    await delete_notification_messages_by_type(context, "closing_reminder")
    
    notification_text = (
        f"üî¥ *¬°Solicitudes Cerradas!* üî¥\n\n"
        f"‚è∞ El bot ha dejado de aceptar solicitudes\n"
        f"üìÖ D√≠as activos: {', '.join(schedule['days_of_week'])}\n"
        f"üïí Horario: {schedule['start_hour']:02d}:00 - {schedule['end_hour']:02d}:00\n\n"
        f"üì± Las solicitudes enviadas fuera de horario no ser√°n procesadas\n"
        f"üîÑ Pr√≥xima apertura: Ma√±ana a las {schedule['start_hour']:02d}:00\n"
        f"‚è∞ *Hora actual:* {get_spain_real_time().strftime('%H:%M:%S')}\n"
        f"ü§ù *Equipo EntresHijos*"
    )
    
    results = await send_to_all_channels(context, notification_text)
    
    # Guardar mensajes para auto-eliminaci√≥n (hasta pr√≥xima apertura)
    for chat_id, message_id in results.items():
        if message_id:
            save_notification_message(chat_id, message_id, "closing_active")
    
    successful_sends = sum(1 for result in results.values() if result is not None)
    
    logger.info(f"üî¥ Notificaci√≥n de cierre activo enviada a {successful_sends}/{len(CANALES_PETICIONES)} canales")

async def check_and_send_notifications(context: ContextTypes.DEFAULT_TYPE):
    """Verifica y env√≠a notificaciones en tiempo real cada minuto."""
    if not automatic_notifications_enabled:
        return
    
    schedule = get_bot_schedule()
    if not schedule:
        return
    
    spain_time = get_spain_real_time()
    current_day = spain_time.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    
    # Solo procesar si hoy es un d√≠a activo
    if current_day_spanish not in schedule["days_of_week"]:
        return
    
    current_hour = spain_time.hour
    current_minute = spain_time.minute
    
    # Recordatorio de apertura (5 minutos antes)
    opening_reminder_time = (spain_time.replace(hour=schedule["start_hour"], minute=0, second=0, microsecond=0) - timedelta(minutes=5))
    if current_hour == opening_reminder_time.hour and current_minute == opening_reminder_time.minute:
        await send_opening_reminder_notification(context)
    
    # Notificaci√≥n de apertura activa (hora exacta)
    elif current_hour == schedule["start_hour"] and current_minute == 0:
        await send_opening_active_notification(context)
    
    # Recordatorio de cierre (5 minutos antes)
    closing_reminder_time = (spain_time.replace(hour=schedule["end_hour"], minute=0, second=0, microsecond=0) - timedelta(minutes=5))
    if current_hour == closing_reminder_time.hour and current_minute == closing_reminder_time.minute:
        await send_closing_reminder_notification(context)
    
    # Notificaci√≥n de cierre activo (hora exacta)
    elif current_hour == schedule["end_hour"] and current_minute == 0:
        await send_closing_active_notification(context)
    
    # Limpiar mensajes expirados
    await cleanup_expired_notification_messages(context)

def schedule_notifications(application_instance):
    """Programa el sistema de notificaciones en tiempo real."""
    # Cancelar trabajos existentes
    for job_name in list(notification_jobs.keys()):
        job = notification_jobs[job_name]
        job.schedule_removal()
        del notification_jobs[job_name]
    
    # Programar verificaci√≥n cada 2 minutos para evitar solapamiento
    notification_job = application_instance.job_queue.run_repeating(
        check_and_send_notifications, 
        interval=120,  # Cada 2 minutos para evitar solapamiento
        first=30,      # Empezar en 30 segundos
        name="real_time_notifications"
    )
    notification_jobs["real_time_checker"] = notification_job
    
    # Programar limpieza de mensajes expirados cada 10 minutos
    cleanup_job = application_instance.job_queue.run_repeating(
        cleanup_expired_notification_messages,
        interval=600,  # Cada 10 minutos
        first=120,     # Empezar en 2 minutos
        name="cleanup_expired_notifications"
    )
    notification_jobs["cleanup_notifications"] = cleanup_job
    
    logger.info(f"‚úÖ Sistema de notificaciones programado (intervalo: 2 min)")

# FUNCIONES PARA GESTI√ìN MEJORADA DE RESPUESTAS DE ADMINISTRADORES

def set_admin_waiting_response(admin_id: int, chat_id: int, response_type: str, ticket_number: int, data: dict):
    """Configura que un administrador est√° esperando una respuesta."""
    key = f"{admin_id}_{chat_id}"
    admin_waiting_responses[key] = {
        "admin_id": admin_id,
        "chat_id": chat_id,
        "response_type": response_type,
        "ticket_number": ticket_number,
        "data": data,
        "timestamp": datetime.now(SPAIN_TZ),
        "question_message_id": None
    }
    logger.info(f"‚úÖ Admin {admin_id} configurado para esperar respuesta tipo '{response_type}' para ticket #{ticket_number}")

def get_admin_waiting_response(admin_id: int, chat_id: int) -> Optional[dict]:
    """Obtiene la respuesta que est√° esperando un administrador."""
    key = f"{admin_id}_{chat_id}"
    return admin_waiting_responses.get(key)

def clear_admin_waiting_response(admin_id: int, chat_id: int):
    """Limpia la espera de respuesta de un administrador."""
    key = f"{admin_id}_{chat_id}"
    if key in admin_waiting_responses:
        del admin_waiting_responses[key]
        logger.info(f"‚úÖ Limpiada espera de respuesta para admin {admin_id}")

def set_pending_deletion(admin_id: int, chat_id: int, ticket_number: int, data: dict):
    """Configura una eliminaci√≥n pendiente de confirmaci√≥n."""
    key = f"{admin_id}_{chat_id}_{ticket_number}"
    pending_deletions[key] = {
        "admin_id": admin_id,
        "chat_id": chat_id,
        "ticket_number": ticket_number,
        "data": data,
        "timestamp": datetime.now(SPAIN_TZ),
        "reason": None
    }
    logger.info(f"‚úÖ Eliminaci√≥n pendiente configurada para ticket #{ticket_number} por admin {admin_id}")

def get_pending_deletion(admin_id: int, chat_id: int, ticket_number: int) -> Optional[dict]:
    """Obtiene una eliminaci√≥n pendiente."""
    key = f"{admin_id}_{chat_id}_{ticket_number}"
    return pending_deletions.get(key)

def clear_pending_deletion(admin_id: int, chat_id: int, ticket_number: int):
    """Limpia una eliminaci√≥n pendiente."""
    key = f"{admin_id}_{chat_id}_{ticket_number}"
    if key in pending_deletions:
        del pending_deletions[key]
        logger.info(f"‚úÖ Eliminaci√≥n pendiente limpiada para ticket #{ticket_number}")

def set_user_menu_state(user_id: int, chat_id: int, message_id: int, state: str, data: dict = None):
    """Guarda el estado del men√∫ de un usuario."""
    key = f"{user_id}_{chat_id}_{message_id}"
    user_menu_states[key] = {
        "state": state,
        "data": data or {},
        "timestamp": datetime.now(SPAIN_TZ)
    }
    logger.debug(f"‚úÖ Estado de men√∫ guardado para user_id={user_id}, state={state}")

def get_user_menu_state(user_id: int, chat_id: int, message_id: int) -> Optional[dict]:
    """Obtiene el estado del men√∫ de un usuario."""
    key = f"{user_id}_{chat_id}_{message_id}"
    return user_menu_states.get(key)

def clear_user_menu_state(user_id: int, chat_id: int, message_id: int):
    """Limpia el estado del men√∫ de un usuario."""
    key = f"{user_id}_{chat_id}_{message_id}"
    if key in user_menu_states:
        del user_menu_states[key]
        logger.debug(f"‚úÖ Estado de men√∫ limpiado para user_id={user_id}")

async def handle_admin_response(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """Maneja las respuestas de administradores cuando est√°n esperando input."""
    if not update.message:
        return False

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id

    # Obtener texto del mensaje o caption (para fotos/videos/GIFs)
    text = ""
    if message.text:
        text = message.text.strip()
    elif message.caption:
        text = message.caption.strip()

    # Detectar si hay contenido multimedia
    has_media = bool(message.photo or message.video or message.animation or message.document)

    if user_id not in ADMINISTRATORS:
        return False

    # Logs de debug para ver el estado actual
    logger.info(f"üîç Verificando respuesta de admin {user_id} en chat {chat_id}")
    logger.info(f"üîç admin_waiting_responses keys: {list(admin_waiting_responses.keys())}")
    logger.info(f"üîç Contenido mensaje - texto: {text[:50] if text else 'N/A'}, foto: {bool(message.photo)}, video: {bool(message.video)}, gif: {bool(message.animation)}, doc: {bool(message.document)}, has_media: {has_media}")

    # Puede venir de almacenamiento por chat o del mapa global de espera
    waiting_response = get_admin_waiting_response(user_id, chat_id)
    if not waiting_response and user_id in admin_waiting_responses:
        waiting_response = admin_waiting_responses[user_id]
        logger.info(f"üîç Estado encontrado en admin_waiting_responses: {waiting_response}")

    if not waiting_response:
        logger.info(f"‚ùå No hay estado de espera para admin {user_id}")
        return False

    logger.info(f"üìù Procesando respuesta de admin {user_id}: tipo={type(waiting_response)}, data={waiting_response}")

    # Normaliza el formato del estado (acepta str o dict)
    if isinstance(waiting_response, str):
        # Ej: "dar_puntos"
        response_type = waiting_response
        waiting_dict = {"action": waiting_response}
    elif isinstance(waiting_response, dict):
        response_type = waiting_response.get("response_type") or waiting_response.get("action")
        waiting_dict = waiting_response
    else:
        # Formato inesperado
        clear_admin_waiting_response(user_id, chat_id)
        if user_id in admin_waiting_responses:
            del admin_waiting_responses[user_id]
        return False

    # Extras opcionales usados por otros flujos (se mantienen tal cual)
    ticket_number = waiting_dict.get("ticket_number") if isinstance(waiting_dict, dict) else None
    data = waiting_dict.get("data", {}) if isinstance(waiting_dict, dict) else {}
    question_msg_id = waiting_dict.get("question_message_id") if isinstance(waiting_dict, dict) else None

    try:
        # === Ruteo por tipo de respuesta ===
        if response_type == "link":
            await process_admin_link_response(update, context, text, ticket_number, data, user_id, chat_id)

        elif response_type == "reason":
            await process_admin_reason_response(update, context, text, ticket_number, data, user_id, chat_id)

        elif response_type == "deletion_reason":
            await process_admin_deletion_reason_response(update, context, text, ticket_number, data, user_id, chat_id)

        elif response_type == "batch_deny_reason":
            await process_batch_deny_with_reason(update, context, text, waiting_dict, user_id, chat_id)

        elif response_type == "dar_puntos" or (isinstance(waiting_dict, dict) and waiting_dict.get("action") == "dar_puntos"):
            # Ahora solo (update, context); la funci√≥n ya extrae todo del update
            await process_dar_puntos_response(update, context)

        elif response_type == "enviar_alerta" or (isinstance(waiting_dict, dict) and waiting_dict.get("action") == "enviar_alerta"):
            # IMPORTANTE: No borrar el mensaje a√∫n para poder procesar multimedia
            await process_alerta_response(update, context, text, user_id, chat_id, waiting_dict)
            # Borrar despu√©s de procesar
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=message.message_id
            )

        elif response_type == "contact_response":
            # Procesar respuesta a solicitud de contacto
            await process_contact_response(update, context, text, waiting_dict, user_id, chat_id)

        else:
            # Tipo desconocido: no romper flujo, limpiar estado y salir
            clear_admin_waiting_response(user_id, chat_id)
            if user_id in admin_waiting_responses:
                del admin_waiting_responses[user_id]
            return False

        # Borra el mensaje del admin despu√©s de procesar (para otros tipos de respuesta)
        if response_type != "enviar_alerta" and not (isinstance(waiting_dict, dict) and waiting_dict.get("action") == "enviar_alerta"):
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=message.message_id
            )

        # Si existe, borra tambi√©n la pregunta original mostrada por el bot
        if question_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=question_msg_id
            )

        # Limpia estados de espera tras procesar correctamente
        # IMPORTANTE: NO limpiar para contact_response porque necesita confirmar despu√©s
        if response_type != "contact_response":
            clear_admin_waiting_response(user_id, chat_id)
            if user_id in admin_waiting_responses:
                del admin_waiting_responses[user_id]
        else:
            logger.info(f"üí° Manteniendo estado de espera para contact_response (requiere confirmaci√≥n)")
        return True

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error procesando respuesta de admin: {str(e)}", exc_info=True)
        await send_error_to_developer(
            context,
            f"Error procesando respuesta admin: {str(e)}\nUser: {user_id}\nText: {text}",
            "Error Admin Response"
        )
        # Aun con error, limpia el estado para no encallar
        clear_admin_waiting_response(user_id, chat_id)
        if user_id in admin_waiting_responses:
            del admin_waiting_responses[user_id]
        return False

async def process_admin_link_response(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                    link: str, ticket_number: int, data: dict,
                                    admin_id: int, chat_id: int):
    """Procesa la respuesta de enlace del administrador."""
    
    if not validate_telegram_link(link):
        error_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="‚ùå *Enlace inv√°lido* ‚ùå\nPor favor, env√≠a un enlace v√°lido de Telegram.",
            parse_mode="Markdown",
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 10)
            )
        return
    
    peticion = data["peticion"]
    
    await set_historial_solicitud(ticket_number, {
        "chat_id": peticion["chat_id"],
        "username": peticion["username"],
        "user_id": peticion["user_id"],
        "message_text": peticion["message_text"],
        "chat_title": peticion["chat_title"],
        "estado": "subido",
        "fecha_gestion": datetime.now(SPAIN_TZ),
        "admin_username": "Equipo de Administraci√≥n",
        "url": link,
        "has_attachment": peticion["has_attachment"],
        "photo_file_id": peticion["photo_file_id"]
    })
    
    del_peticion_registrada(ticket_number)
    
    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
    message_text_escaped = escape_markdown(peticion["message_text"])
    
    notification_message = await safe_bot_method(
        context.bot.send_message,
        chat_id=canal_info["chat_id"],
        text=(
            f"‚úÖ *Solicitud Aprobada con Enlace* ‚úÖ\n"
            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido aprobada por el *Equipo de Administraci√≥n*.\n"
            f"üìå *Detalles:*\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
            f"üîó *Enlace:* {link}\n"
            f"‚è∞ *Fecha:* {get_spain_time()}\n"
            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
            f"üòä Por favor, califica tu experiencia con la encuesta."
        ),
        message_thread_id=canal_info["thread_id"],
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üòä Encuesta de Satisfacci√≥n", callback_data=f"encuesta_{ticket_number}")]
        ]),
        parse_mode="Markdown"
    )

    # Registrar encuesta pendiente para recordatorio
    save_pending_survey(
        ticket_number,
        peticion["user_id"],
        peticion["username"],
        peticion["chat_id"],
        peticion["message_text"],
        peticion["chat_title"]
    )
    
    # Eliminar mensajes originales
    if peticion.get("message_id"):
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=peticion["message_id"]
        )
    
    photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
    if photo_message_id:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=photo_message_id
        )
        del context.bot_data[f"photo_{ticket_number}"]
    
    # Eliminar mensaje de confirmaci√≥n cuando se gestiona
    await delete_confirmation_message(context, ticket_number)
    
    menu_message_id = data.get("menu_message_id")
    if menu_message_id:
        # Determinar navegaci√≥n seg√∫n el origen
        return_to = data.get("return_to", "menu")
        searched_user_id = data.get("searched_user_id")
        
        if return_to == "user_search" and searched_user_id:
            texto = f"‚úÖ *Solicitud #{ticket_number} aprobada exitosamente con enlace*\nüîó {escape_markdown(link)}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("üìã Ver Pendientes", callback_data=f"user_pending_{searched_user_id}"),
                 InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        else:
            texto = f"‚úÖ *Solicitud #{ticket_number} aprobada exitosamente con enlace*\nüîó {escape_markdown(link)}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=menu_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown",
            disable_web_page_preview=False
        )
        menu_activos[(chat_id, menu_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": admin_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
    
    logger.info(f"‚úÖ Solicitud #{ticket_number} aprobada con enlace por admin {admin_id}")

async def process_admin_reason_response(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                      reason: str, ticket_number: int, data: dict,
                                      admin_id: int, chat_id: int):
    """Procesa la respuesta de motivo del administrador."""
    
    peticion = data["peticion"]
    
    await set_historial_solicitud(ticket_number, {
        "chat_id": peticion["chat_id"],
        "username": peticion["username"],
        "user_id": peticion["user_id"],
        "message_text": peticion["message_text"],
        "chat_title": peticion["chat_title"],
        "estado": "denegado",
        "fecha_gestion": datetime.now(SPAIN_TZ),
        "admin_username": "Equipo de Administraci√≥n",
        "reason": reason,
        "has_attachment": peticion["has_attachment"],
        "photo_file_id": peticion["photo_file_id"]
    })

    # Restar puntos por solicitud denegada
    if SISTEMA_PUNTOS_DISPONIBLE and peticion.get("user_id") and peticion.get("username"):
        user_id = peticion["user_id"]
        username = peticion["username"]
        otorgar_puntos(user_id, username, -10, "penalizacion",
                      f"Solicitud #{ticket_number} denegada: {reason}")
        logger.info(f"üí∞ -10 puntos restados a @{username} por solicitud denegada")

    del_peticion_registrada(ticket_number)
    
    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
    message_text_escaped = escape_markdown(peticion["message_text"])
    reason_escaped = escape_markdown(reason)
    
    notification_message = await safe_bot_method(
        context.bot.send_message,
        chat_id=canal_info["chat_id"],
        text=(
            f"‚ùå *Solicitud Denegada* ‚ùå\n"
            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido denegada por el *Equipo de Administraci√≥n*.\n"
            f"üìå *Detalles:*\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
            f"üìù *Motivo:* {reason_escaped}\n"
            f"‚è∞ *Fecha:* {get_spain_time()}\n"
            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
            f"Si tienes dudas, contacta con @admin."
        ),
        message_thread_id=canal_info["thread_id"],
        parse_mode="Markdown"
    )
    
    # Eliminar mensajes originales
    if peticion.get("message_id"):
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=peticion["message_id"]
        )
    
    photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
    if photo_message_id:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=photo_message_id
        )
        del context.bot_data[f"photo_{ticket_number}"]
    
    # Eliminar mensaje de confirmaci√≥n cuando se gestiona
    await delete_confirmation_message(context, ticket_number)
    
    menu_message_id = data.get("menu_message_id")
    if menu_message_id:
        # Determinar navegaci√≥n seg√∫n el origen
        return_to = data.get("return_to", "menu")
        searched_user_id = data.get("searched_user_id")
        
        if return_to == "user_search" and searched_user_id:
            texto = f"‚úÖ *Solicitud #{ticket_number} denegada exitosamente*\nüìù Motivo: {reason_escaped}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("üìã Ver Pendientes", callback_data=f"user_pending_{searched_user_id}"),
                 InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        else:
            texto = f"‚úÖ *Solicitud #{ticket_number} denegada exitosamente*\nüìù Motivo: {reason_escaped}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=menu_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, menu_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": admin_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
    
    logger.info(f"‚úÖ Solicitud #{ticket_number} denegada con motivo por admin {admin_id}")

async def process_admin_deletion_reason_response(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                               reason: str, ticket_number: int, data: dict,
                                               admin_id: int, chat_id: int):
    """Procesa la respuesta de motivo de eliminaci√≥n del administrador."""
    
    peticion = data["peticion"]
    
    await set_historial_solicitud(ticket_number, {
        "chat_id": peticion["chat_id"],
        "username": peticion["username"],
        "user_id": peticion["user_id"],
        "message_text": peticion["message_text"],
        "chat_title": peticion["chat_title"],
        "estado": "eliminado",
        "fecha_gestion": datetime.now(SPAIN_TZ),
        "admin_username": "Equipo de Administraci√≥n",
        "reason": reason,
        "has_attachment": peticion["has_attachment"],
        "photo_file_id": peticion["photo_file_id"]
    })

    # Restar puntos por solicitud eliminada
    if SISTEMA_PUNTOS_DISPONIBLE and peticion.get("user_id") and peticion.get("username"):
        user_id = peticion["user_id"]
        username = peticion["username"]
        otorgar_puntos(user_id, username, -15, "penalizacion",
                      f"Solicitud #{ticket_number} eliminada: {reason}")
        logger.info(f"üí∞ -15 puntos restados a @{username} por solicitud eliminada")

    del_peticion_registrada(ticket_number)
    
    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
    message_text_escaped = escape_markdown(peticion["message_text"])
    reason_escaped = escape_markdown(reason)
    
    notification_message = await safe_bot_method(
        context.bot.send_message,
        chat_id=canal_info["chat_id"],
        text=(
            f"üóëÔ∏è *Solicitud Eliminada* üóëÔ∏è\n"
            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido eliminada por el *Equipo de Administraci√≥n*.\n"
            f"üìå *Detalles:*\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
            f"üìù *Motivo:* {reason_escaped}\n"
            f"‚è∞ *Fecha:* {get_spain_time()}\n"
            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
            f"Si tienes dudas, contacta con @admin."
        ),
        message_thread_id=canal_info["thread_id"],
        parse_mode="Markdown"
    )
    
    # Eliminar mensajes originales
    if peticion.get("message_id"):
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=peticion["message_id"]
        )
    
    photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
    if photo_message_id:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=GROUP_DESTINO,
            message_id=photo_message_id
        )
        del context.bot_data[f"photo_{ticket_number}"]
    
    # Eliminar mensaje de confirmaci√≥n cuando se gestiona
    await delete_confirmation_message(context, ticket_number)
    
    menu_message_id = data.get("menu_message_id")
    if menu_message_id:
        # Determinar navegaci√≥n seg√∫n el origen
        return_to = data.get("return_to", "menu")
        searched_user_id = data.get("searched_user_id")
        
        if return_to == "user_search" and searched_user_id:
            texto = f"‚úÖ *Solicitud #{ticket_number} eliminada exitosamente*\nüìù Motivo: {reason_escaped}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("üìã Ver Pendientes", callback_data=f"user_pending_{searched_user_id}"),
                 InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        else:
            texto = f"‚úÖ *Solicitud #{ticket_number} eliminada exitosamente*\nüìù Motivo: {reason_escaped}"
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ])
        
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=menu_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, menu_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": admin_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
    
    logger.info(f"‚úÖ Solicitud #{ticket_number} eliminada con motivo por admin {admin_id}")

async def process_batch_deny_with_reason(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                        reason: str, waiting_response: dict,
                                        admin_id: int, chat_id: int):
    """Procesa la denegaci√≥n masiva con motivo."""
    selected_tickets = waiting_response.get("selected_tickets", [])
    original_message_id = waiting_response.get("message_id")

    if not reason or len(reason) < 3:
        error_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="‚ùå *Motivo inv√°lido*\n\nEl motivo debe tener al menos 3 caracteres. Por favor, intenta nuevamente.",
            parse_mode="Markdown"
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 10)
            )
        return

    processed = 0
    admin_username = "Equipo de Administraci√≥n"
    reason_escaped = escape_markdown(reason)

    for ticket_number in selected_tickets:
        peticion = get_peticion_registrada(ticket_number)
        if peticion:
            await set_historial_solicitud(ticket_number, {
                "chat_id": peticion["chat_id"],
                "username": peticion["username"],
                "user_id": peticion["user_id"],
                "message_text": peticion["message_text"],
                "chat_title": peticion["chat_title"],
                "estado": "denegado",
                "fecha_gestion": datetime.now(SPAIN_TZ),
                "admin_username": admin_username,
                "reason": reason,
                "has_attachment": peticion["has_attachment"],
                "photo_file_id": peticion["photo_file_id"]
            })

            canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
            username_escaped = escape_markdown(peticion["username"], preserve_username=True)
            message_text_escaped = escape_markdown(peticion["message_text"])

            notification_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=canal_info["chat_id"],
                text=(
                    f"‚ùå *Solicitud Denegada* ‚ùå\n"
                    f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido denegada por el *{admin_username}*.\n"
                    f"üìå *Detalles:*\n"
                    f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                    f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
                    f"üìù *Motivo:* {reason_escaped}\n"
                    f"‚è∞ *Fecha:* {get_spain_time()}\n"
                    f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n\n"
                    f"Si tienes dudas, revisa las normas o contacta con @admin."
                ),
                message_thread_id=canal_info["thread_id"],
                parse_mode="Markdown"
            )

            # Restar puntos por solicitud denegada
            if SISTEMA_PUNTOS_DISPONIBLE and peticion.get("user_id") and peticion.get("username"):
                user_id_points = peticion["user_id"]
                username_points = peticion["username"]
                otorgar_puntos(user_id_points, username_points, -10, "penalizacion",
                              f"Solicitud #{ticket_number} denegada: {reason}")
                logger.info(f"üí∞ -10 puntos restados a @{username_points} por solicitud denegada (batch)")

            del_peticion_registrada(ticket_number)

            if peticion.get("message_id"):
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=GROUP_DESTINO,
                    message_id=peticion["message_id"]
                )

            photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
            if photo_message_id:
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=GROUP_DESTINO,
                    message_id=photo_message_id
                )
                if f"photo_{ticket_number}" in context.bot_data:
                    del context.bot_data[f"photo_{ticket_number}"]

            await delete_confirmation_message(context, ticket_number)
            processed += 1

    if admin_id in selected_requests:
        selected_requests[admin_id] = []

    texto = (
        f"‚úÖ *Denegaci√≥n Masiva Completada* ‚úÖ\n\n"
        f"üìä *Solicitudes denegadas:* {processed}\n"
        f"üìù *Motivo aplicado:* {reason_escaped}\n"
        f"üë§ *Administrador:* {admin_username}\n"
        f"‚è∞ *Fecha:* {get_spain_time()}"
    )
    keyboard = [
        [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data="menu_gestion"),
         InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    if original_message_id:
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=original_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, original_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": admin_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }

    logger.info(f"‚úÖ Denegaci√≥n masiva completada por admin {admin_id}, {processed} solicitudes procesadas con motivo: {reason}")

async def clean_expired_admin_responses():
    """Limpia respuestas de administradores expiradas cada 5 minutos."""
    while True:
        current_time = datetime.now(SPAIN_TZ)
        expired_keys = []

        for key, response_data in list(admin_waiting_responses.items()):
            # Verificar si tiene timestamp antes de comparar
            if isinstance(response_data, dict) and "timestamp" in response_data:
                if (current_time - response_data["timestamp"]).total_seconds() >= 1800:
                    expired_keys.append(key)
            else:
                # Si no tiene timestamp, eliminar por seguridad (dato antiguo)
                expired_keys.append(key)

        for key in expired_keys:
            del admin_waiting_responses[key]
            logger.info(f"üóëÔ∏è Eliminada respuesta de admin expirada: {key}")

        await asyncio.sleep(300)

async def clean_expired_user_menu_states():
    """Limpia estados de men√∫s de usuarios expirados cada 10 minutos."""
    while True:
        current_time = datetime.now(SPAIN_TZ)
        expired_keys = []
        
        for key, state_data in list(user_menu_states.items()):
            if (current_time - state_data["timestamp"]).total_seconds() >= 900:
                expired_keys.append(key)
        
        for key in expired_keys:
            del user_menu_states[key]
            logger.debug(f"üóëÔ∏è Eliminado estado de men√∫ expirado: {key}")
        
        await asyncio.sleep(600)

async def clean_expired_backup_attempts():
    """Limpia intentos de grupo de respaldo expirados cada 24 horas."""
    while True:
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Eliminar intentos de m√°s de 7 d√≠as
                    cutoff_date = datetime.now(SPAIN_TZ) - timedelta(days=7)
                    c.execute("""
                        DELETE FROM backup_group_attempts 
                        WHERE last_attempt < %s
                    """, (cutoff_date,))
                    deleted_count = c.rowcount
                    conn.commit()
                    
                    if deleted_count > 0:
                        logger.info(f"üóëÔ∏è Eliminados {deleted_count} intentos de grupo de respaldo expirados")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando intentos de grupo de respaldo: {str(e)}")
        
        await asyncio.sleep(86400)  # 24 horas

async def send_survey_reminders(context: ContextTypes.DEFAULT_TYPE, manual=False):
    """Env√≠a recordatorios de encuestas pendientes despu√©s de 2 d√≠as."""
    try:
        if manual:
            logger.info("üìã Env√≠o MANUAL de recordatorios iniciado...")
        else:
            logger.info("üìã Verificando encuestas pendientes para recordatorios...")

        surveys = get_surveys_needing_reminder()

        for survey in surveys:
            ticket_number = survey['ticket_number']
            user_id = survey['user_id']
            username = survey['username']
            chat_id = survey['chat_id']
            message_text = survey['message_text']
            chat_title = survey['chat_title']

            # Buscar el canal correspondiente
            canal_info = CANALES_PETICIONES.get(chat_id)
            if not canal_info:
                logger.warning(f"‚ö†Ô∏è No se encontr√≥ canal para chat_id={chat_id}")
                continue

            # Eliminar recordatorio anterior si existe
            old_reminder = get_reminder_message_info(ticket_number)
            if old_reminder:
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=old_reminder['chat_id'],
                    message_id=old_reminder['message_id']
                )
                logger.info(f"üóëÔ∏è Recordatorio anterior eliminado para ticket #{ticket_number}")

            username_display = username if username.startswith('@') else f"@{username}"
            message_text_escaped = escape_markdown(message_text[:100] + '...' if len(message_text) > 100 else message_text)

            reminder_message = (
                f"üìã *Recordatorio de Encuesta Pendiente* üìã\n\n"
                f"Hola {username_display}, hace 2 d√≠as se aprob√≥ tu solicitud _(Ticket #{ticket_number})_ "
                f"y a√∫n no has completado la encuesta de satisfacci√≥n.\n\n"
                f"üìù *Solicitud:* {message_text_escaped}\n"
                f"üìç *Grupo:* {escape_markdown(chat_title)}\n\n"
                f"üòä *Tu opini√≥n es muy importante para nosotros*\n"
                f"Nos ayuda a mejorar cada d√≠a el servicio que te ofrecemos.\n\n"
                f"üí° Por favor, t√≥mate un momento para responder la encuesta.\n\n"
                f"*Equipo de Administraci√≥n EntresHijos* üôè"
            )

            reminder_sent = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                message_thread_id=canal_info.get('thread_id'),
                text=reminder_message,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üòä Responder Encuesta", callback_data=f"encuesta_{ticket_number}")]
                ]),
                parse_mode="Markdown"
            )

            if reminder_sent:
                mark_reminder_sent(ticket_number, reminder_sent.message_id, chat_id)
                logger.info(f"‚úÖ Recordatorio enviado para ticket #{ticket_number} a {username}")

        if len(surveys) > 0:
            logger.info(f"‚úÖ Enviados {len(surveys)} recordatorios de encuestas")
        else:
            logger.info("üìã No hay encuestas pendientes que requieran recordatorio")

        return len(surveys)

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error enviando recordatorios de encuestas: {str(e)}")
        return 0

async def weekly_report_and_rewards(context: ContextTypes.DEFAULT_TYPE):
    """Genera reportes semanales, premios y penalizaciones cada domingo a las 22:05 hora espa√±ola."""
    logger.info("üìä Iniciando reporte semanal y sistema de premios/penalizaciones - Domingo 22:05")

    reward_winners = []
    penalty_list = []

    try:
        # Obtener usuarios activos de la semana
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Usuarios con 3 peticiones incorrectas esta semana (excluyendo usuarios con abusos)
                c.execute("""
                    SELECT user_id, COALESCE(username, '') as username, COUNT(*) as count
                    FROM peticiones_incorrectas
                    WHERE timestamp >= NOW() - INTERVAL '7 days'
                    AND user_id NOT IN (
                        SELECT user_id FROM abuso_botones
                        WHERE timestamp >= NOW() - INTERVAL '7 days'
                        GROUP BY user_id
                        HAVING COUNT(*) >= 3
                    )
                    GROUP BY user_id, username
                    HAVING COUNT(*) >= 3
                """)
                users_with_errors = c.fetchall()

                # Usuarios activos con buen comportamiento
                c.execute("""
                    SELECT DISTINCT pr.user_id, COALESCE(pr.username, '') as username
                    FROM peticiones_registradas pr
                    WHERE pr.timestamp >= NOW() - INTERVAL '7 days'
                    AND pr.user_id NOT IN (
                        SELECT user_id FROM peticiones_incorrectas
                        WHERE timestamp >= NOW() - INTERVAL '7 days'
                        GROUP BY user_id
                        HAVING COUNT(*) > 0
                    )
                    AND pr.user_id NOT IN (
                        SELECT user_id FROM abuso_botones
                        WHERE timestamp >= NOW() - INTERVAL '7 days'
                    )
                """)
                good_users = c.fetchall()

        # Aplicar penalizaciones
        penalty_list = []
        for user in users_with_errors:
            add_weekly_penalty(user['user_id'], user['username'])
            penalty_list.append({
                'user_id': user['user_id'],
                'username': user['username'],
                'count': user['count']
            })

        # Seleccionar 3 usuarios aleatorios para premiar
        reward_winners = []
        if len(good_users) >= 3:
            import random
            winners = random.sample(list(good_users), 3)
            for winner in winners:
                add_weekly_reward(winner['user_id'], winner['username'])
                reward_winners.append({
                    'user_id': winner['user_id'],
                    'username': winner['username']
                })

        # Obtener estad√≠sticas de la semana
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Estad√≠sticas de la √∫ltima semana
                c.execute("""
                    SELECT
                        COUNT(*) FILTER (WHERE estado = 'subido') as aprobadas,
                        COUNT(*) FILTER (WHERE estado = 'denegado') as denegadas,
                        COUNT(*) FILTER (WHERE estado = 'eliminado') as eliminadas
                    FROM historial_solicitudes
                    WHERE fecha_gestion >= NOW() - INTERVAL '7 days'
                """)
                stats_week = c.fetchone()

                # Total de solicitudes pendientes actuales
                c.execute("SELECT COUNT(*) as total FROM peticiones_registradas")
                pendientes = c.fetchone()["total"]

        # Enviar reportes a todos los canales donde se hacen peticiones
        for chat_id, canal_info in CANALES_PETICIONES.items():
            try:
                # Obtener nombre del grupo
                grupo_nombre = GRUPOS_PREDEFINIDOS.get(chat_id, f"Grupo {chat_id}")

                # Fecha actual para el reporte
                fecha_reporte = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y")
                hora_reporte = datetime.now(SPAIN_TZ).strftime("%H:%M")

                # Mensaje de estad√≠sticas generales (siempre se env√≠a)
                stats_message = (
                    f"üìä *Reporte Semanal - EntresHijos* üìä\n\n"
                    f"üìÖ *Fecha:* {fecha_reporte} - {hora_reporte}h\n"
                    f"üìç *Grupo:* {escape_markdown(grupo_nombre)}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìà *Estad√≠sticas de la Semana*\n\n"
                    f"‚úÖ Solicitudes aprobadas: *{stats_week['aprobadas'] or 0}*\n"
                    f"‚ùå Solicitudes denegadas: *{stats_week['denegadas'] or 0}*\n"
                    f"üóëÔ∏è Solicitudes eliminadas: *{stats_week['eliminadas'] or 0}*\n"
                    f"üìù Pendientes actuales: *{pendientes}*\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                )

                # Si hay premiados, agregar secci√≥n de premios
                if reward_winners:
                    stats_message += (
                        f"\nüèÜ *¬°Usuarios Destacados!*\n\n"
                        f"Felicidades a los usuarios que destacaron esta semana por su excelente comportamiento:\n\n"
                    )

                    for winner in reward_winners:
                        username = winner['username'] if winner['username'].startswith('@') else f"@{winner['username']}"
                        stats_message += f"‚Ä¢ {username}\n"

                    stats_message += (
                        f"\n‚ú® *Premio:* +1 petici√≥n extra esta semana (3 en total)\n\n"
                        f"üìã *Reconocido por:*\n"
                        f"‚Ä¢ Participaci√≥n activa y ejemplar\n"
                        f"‚Ä¢ Uso correcto del formato de solicitudes\n"
                        f"‚Ä¢ Respeto a las normas de la comunidad\n"
                        f"‚Ä¢ Peticiones bien formuladas\n\n"
                        f"üí° *¬°Sigue as√≠!* Tu comportamiento es un ejemplo para todos.\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    )

                # Si hay penalizados, agregar secci√≥n de advertencias
                if penalty_list:
                    stats_message += (
                        f"\n‚ö†Ô∏è *Usuarios con Advertencias*\n\n"
                        f"Los siguientes usuarios han excedido el l√≠mite de peticiones incorrectas esta semana:\n\n"
                    )

                    for user in penalty_list:
                        username = user['username'] if user['username'].startswith('@') else f"@{user['username']}"
                        stats_message += f"‚Ä¢ {username} - {user['count']} intentos incorrectos\n"

                    stats_message += (
                        f"\n‚ùå *Penalizaci√≥n:* -1 petici√≥n esta semana (1 disponible)\n\n"
                        f"üìù *C√≥mo evitar penalizaciones:*\n"
                        f"‚Ä¢ Usa */solicito* o *#peticion* correctamente\n"
                        f"‚Ä¢ Revisa el formato antes de enviar\n"
                        f"‚Ä¢ Consulta */ayuda* si tienes dudas\n"
                        f"‚Ä¢ Sigue las normas del grupo\n\n"
                        f"üí™ *Nueva oportunidad:* La pr√≥xima semana empiezas desde cero.\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    )

                # Mensaje final
                stats_message += (
                    f"\nüôå *¬°Gracias por formar parte de EntresHijos!*\n\n"
                    f"üéØ Recuerda seguir las normas y podr√≠as ser el pr√≥ximo premiado.\n\n"
                    f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
                )

                # Enviar el reporte semanal unificado
                msg_sent = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    message_thread_id=canal_info.get('thread_id'),
                    text=stats_message,
                    parse_mode="Markdown"
                )

                if msg_sent:
                    logger.info(f"‚úÖ Reporte semanal enviado a {grupo_nombre} (chat_id={chat_id})")
                else:
                    logger.warning(f"‚ö†Ô∏è No se pudo enviar reporte semanal a {grupo_nombre} (chat_id={chat_id})")

            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error enviando reporte a grupo {chat_id}: {str(e)}")
                continue

        # Notificar a administradores con estad√≠sticas completas
        admin_summary = (
            f"üìä *Reporte Semanal Enviado - Domingo 22:05* üìä\n\n"
            f"üìÖ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M')}h\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üìà *Estad√≠sticas de la Semana:*\n"
            f"‚úÖ Aprobadas: {stats_week['aprobadas'] or 0}\n"
            f"‚ùå Denegadas: {stats_week['denegadas'] or 0}\n"
            f"üóëÔ∏è Eliminadas: {stats_week['eliminadas'] or 0}\n"
            f"üìù Pendientes actuales: {pendientes}\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üèÜ *Usuarios Premiados:* {len(reward_winners)}\n"
            f"‚ö†Ô∏è *Usuarios Penalizados:* {len(penalty_list)}\n\n"
            f"‚úÖ *Reporte enviado a {len(CANALES_PETICIONES)} grupos exitosamente*\n\n"
            f"*Sistema Autom√°tico EntresHijos* üõ°Ô∏è"
        )

        await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=admin_summary,
            parse_mode="Markdown"
        )

        logger.info(f"‚úÖ Reporte semanal completado - Premiados: {len(reward_winners)}, Penalizados: {len(penalty_list)}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en reporte semanal: {str(e)}", exc_info=True)

        # GARANTIZAR que se env√≠e notificaci√≥n aunque haya error
        try:
            error_message = (
                f"üö® *Reporte Semanal - Error Detectado* üö®\n\n"
                f"‚è∞ *Hora:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M')}\n"
                f"‚ùå *Error:* {str(e)[:200]}\n\n"
                f"üèÜ *Premiados hasta el error:* {len(reward_winners)}\n"
                f"‚ö†Ô∏è *Penalizados hasta el error:* {len(penalty_list)}\n\n"
                f"‚ÑπÔ∏è Se intentar√° de nuevo la pr√≥xima semana."
            )

            # Notificar al desarrollador
            await safe_bot_method(
                context.bot.send_message,
                chat_id=DEVELOPER_CHAT_ID,
                text=error_message,
                parse_mode="Markdown"
            )

            # Notificar al grupo principal
            await safe_bot_method(
                context.bot.send_message,
                chat_id=GROUP_DESTINO,
                text=(
                    f"‚ö†Ô∏è *Reporte Semanal* ‚ö†Ô∏è\n\n"
                    f"Se ha producido un error t√©cnico al generar el reporte completo.\n"
                    f"El equipo t√©cnico ha sido notificado.\n\n"
                    f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
                ),
                parse_mode="Markdown"
            )

        except Exception as notify_error:
            logger.critical(f"üö® Error cr√≠tico al notificar error del reporte semanal: {str(notify_error)}")

    finally:
        # GARANTIZAR que siempre se registre que el job se ejecut√≥
        logger.info(f"üèÅ Reporte semanal finalizado - Estado: {'‚úÖ Exitoso' if not reward_winners and not penalty_list else f'‚úÖ Premiados: {len(reward_winners)}, Penalizados: {len(penalty_list)}'}")

def escape_markdown_v2(text: str) -> str:
    """Escapa caracteres especiales para MarkdownV2."""
    if not text:
        return text
    escape_chars = r'_*[]()~`>#+-=|{}.!'
    return ''.join(f'\\{char}' if char in escape_chars else char for char in text)

def escape_markdown(text, preserve_username=False):
    """Escapa caracteres Markdown de forma m√°s robusta."""
    if not text:
        return text
    
    text = str(text)
    
    if preserve_username and text.startswith("@"):
        return text.replace("_", "\\_").replace("*", "\\*").replace("[", "\\[").replace("]", "\\]")
    
    characters_to_escape = ["_", "*", "[", "]", "(", ")", "~", "`", ">", "#", "+", "-", "=", "|", "{", "}", ".", "!"]
    
    for char in characters_to_escape:
        text = text.replace(char, f"\\{char}")
    
    return text

async def send_error_to_developer(context, error_message: str, error_type: str = "Error"):
    """Env√≠a errores cr√≠ticos al desarrollador por mensaje privado."""
    try:
        full_message = (
            f"üö® *{error_type} en Bot EntresHijos* üö®\n\n"
            f"‚è∞ **Fecha:** {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
            f"üìù **Detalles:**\n"
            f"```\n{error_message[:3500]}\n```"  # Limitar a 3500 caracteres
        )
        await context.bot.send_message(
            chat_id=DEVELOPER_CHAT_ID,
            text=full_message,
            parse_mode="Markdown"
        )
        logger.info(f"‚úÖ Error enviado al desarrollador {DEVELOPER_CHAT_ID}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è No se pudo enviar error al desarrollador: {str(e)}")

async def safe_bot_method(method, *args, **kwargs):
    """Ejecuta m√©todos de Telegram con manejo de errores robusto y logging mejorado."""
    method_name = method.__name__ if hasattr(method, '__name__') else str(method)
    chat_id = kwargs.get('chat_id', 'desconocido')
    
    try:
        result = await method(*args, **kwargs)
        logger.debug(f"‚úÖ {method_name} exitoso para chat_id={chat_id}")
        return result
    except telegram.error.Forbidden as e:
        logger.warning(f"üö´ {method_name} - Bot sin permisos en chat_id={chat_id}: {str(e)}")
        return None
    except telegram.error.BadRequest as e:
        error_msg = str(e).lower()
        if "message is not modified" in error_msg:
            logger.debug(f"‚ÑπÔ∏è {method_name} - Mensaje no modificado, ignorando.")
            return None
        if "can't parse entities" in error_msg:
            logger.warning(f"‚ö†Ô∏è {method_name} - Error de parsing: {str(e)}")
            if 'parse_mode' in kwargs:
                del kwargs['parse_mode']
                try:
                    result = await method(*args, **kwargs)
                    logger.info(f"‚úÖ {method_name} exitoso sin parse_mode")
                    return result
                except Exception as retry_e:
                    logger.error(f"‚ùå {method_name} - Fallo incluso sin parse_mode: {str(retry_e)}")
                    return None
        if "query is too old" in error_msg:
            logger.warning(f"‚è∞ {method_name} - Callback query expirado: {str(e)}")
            return None
        if "message to delete not found" in error_msg:
            logger.warning(f"üóëÔ∏è {method_name} - Mensaje ya eliminado: {str(e)}")
            return None
        if "message to edit not found" in error_msg:
            logger.warning(f"‚úèÔ∏è {method_name} - Mensaje no encontrado para editar: {str(e)}")
            return None
        if "message to be replied not found" in error_msg:
            logger.warning(f"üí¨ {method_name} - Mensaje original no encontrado para responder: {str(e)}")
            return None
        if "thread not found" in error_msg or "message thread not found" in error_msg:
            logger.error(f"üßµ {method_name} - Thread no encontrado para chat_id={chat_id}: {str(e)}")
            return None
        if "not enough rights" in error_msg or "not have enough rights" in error_msg:
            logger.error(f"üîê {method_name} - Sin suficientes permisos en chat_id={chat_id}: {str(e)}")
            return None
        logger.error(f"‚ùå {method_name} - Error de solicitud en chat_id={chat_id}: {str(e)}")
        return None
    except telegram.error.TelegramError as e:
        logger.error(f"üì° {method_name} - Error de Telegram en chat_id={chat_id}: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"üí• {method_name} - Error inesperado en chat_id={chat_id}: {str(e)}")
        return None

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja errores no capturados y notifica a administradores."""
    logger.error(f"‚ö†Ô∏è Error no manejado: {context.error}", exc_info=True)
    if update and update.effective_chat:
        chat_id = update.effective_chat.id
        message = update.effective_message.text if update.effective_message else "Sin mensaje"
        user_info = ""
        if update.effective_user:
            username = f"@{update.effective_user.username}" if update.effective_user.username else f"ID: {update.effective_user.id}"
            user_info = f"üë§ *Usuario:* {escape_markdown(username, preserve_username=True)}\n"
        
        await safe_bot_method(
            application.bot.send_message,
            chat_id=DEVELOPER_CHAT_ID,
            text=(
                f"üö® *Error Interno del Bot* üö®\n\n"
                f"{user_info}"
                f"üìç *Chat ID:* {chat_id}\n"
                f"‚úâÔ∏è *Mensaje:* {escape_markdown(str(message))}\n"
                f"‚ùó *Error:* {escape_markdown(str(context.error))}\n"
                f"‚è∞ *Timestamp:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"üîß *Acci√≥n requerida:* Revisar y corregir error\n"
                f"*Sistema de Monitoreo EntresHijos* ü§ñ"
            ),
            parse_mode="Markdown"
        )

def serialize_datetime(obj):
    """Serializa objetos datetime para JSON."""
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError(f"Object of type {type(obj)} is not JSON serializable")

def get_from_cache(key):
    """Obtiene datos del cach√© si no han expirado."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT value FROM cache WHERE key = %s AND expires_at > %s", (key, datetime.now(tz=SPAIN_TZ)))
                result = c.fetchone()
                if result:
                    cached_data = result["value"]
                    if "timestamp" in cached_data and isinstance(cached_data["timestamp"], str):
                        cached_data["timestamp"] = datetime.fromisoformat(cached_data["timestamp"])
                    if "last_reset" in cached_data and isinstance(cached_data["last_reset"], str):
                        cached_data["last_reset"] = datetime.fromisoformat(cached_data["last_reset"])
                    return cached_data
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al leer del cach√© para key={key}: {str(e)}")
        return None

def set_to_cache(key, value, ttl_minutes=10):
    """Guarda datos en el cach√© con un tiempo de expiraci√≥n."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                expires_at = datetime.now(SPAIN_TZ) + timedelta(minutes=ttl_minutes)
                created_at = datetime.now(SPAIN_TZ)
                c.execute("""INSERT INTO cache (key, value, expires_at, created_at) 
                             VALUES (%s, %s, %s, %s)
                             ON CONFLICT (key) DO UPDATE SET 
                             value = EXCLUDED.value, expires_at = EXCLUDED.expires_at, created_at = EXCLUDED.created_at""",
                          (key, json.dumps(value, default=serialize_datetime), expires_at, created_at))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar en cach√© para key={key}: {str(e)}")

def clear_expired_cache():
    """Elimina entradas expiradas del cach√©."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM cache WHERE expires_at <= %s", (datetime.now(SPAIN_TZ),))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al limpiar cach√© expirado: {str(e)}")

def clear_from_cache(key):
    """Elimina una entrada espec√≠fica del cach√©."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM cache WHERE key = %s", (key,))
                conn.commit()
        logger.debug(f"‚úÖ Cache key '{key}' eliminado.")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al limpiar cache key '{key}': {str(e)}")

def clear_all_cache():
    """Elimina todas las entradas del cach√©."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM cache")
                conn.commit()
        logger.info("‚úÖ Cach√© completamente limpiado.")
        return "Cach√© completamente limpiado."
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al limpiar todo el cach√©: {str(e)}")
        return f"Error al limpiar el cach√©: {str(e)}"

def get_db_connection():
    """Obtiene una conexi√≥n directa a la base de datos Supabase con configuraci√≥n optimizada."""
    try:
        # Configurar SSL para Supabase
        ssl_config = None
        if 'supabase' in DATABASE_URL.lower():
            import ssl
            ssl_config = ssl.create_default_context()
            ssl_config.check_hostname = False
            ssl_config.verify_mode = ssl.CERT_NONE

        conn = psycopg2.connect(
            dsn=DATABASE_URL,
            cursor_factory=DictCursor,
            connect_timeout=10,
            application_name="EntresHijosBot",
            sslmode='require' if ssl_config else 'prefer'
        )
        conn.autocommit = False
        return conn
    except psycopg2.OperationalError as e:
        logger.error(f"‚ö†Ô∏è Error al obtener conexi√≥n a Supabase: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error inesperado en conexi√≥n DB: {str(e)}")
        raise

def release_db_connection(conn):
    """Cierra una conexi√≥n directa."""
    try:
        if conn and not conn.closed:
            conn.close()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al cerrar conexi√≥n: {str(e)}")

def log_system_event(level: str, message: str, user_id: int = None, chat_id: int = None, action: str = None, metadata: dict = None):
    """
    Registra un evento en el sistema de logs de la base de datos.

    Args:
        level: Nivel del log (INFO, WARNING, ERROR, CRITICAL, DEBUG)
        message: Mensaje del log
        user_id: ID del usuario (opcional)
        chat_id: ID del chat (opcional)
        action: Acci√≥n realizada (opcional)
        metadata: Datos adicionales en formato dict (opcional)
    """
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT add_system_log(%s, %s, %s, %s, %s, %s)
                """, (level, message, user_id, chat_id, action, json.dumps(metadata) if metadata else None))
                conn.commit()
    except Exception as e:
        # No fallar si el logging falla, solo reportar
        logger.error(f"‚ö†Ô∏è Error registrando log en DB: {str(e)}")

def get_log_stats(days: int = 7):
    """Obtiene estad√≠sticas de logs de los √∫ltimos N d√≠as."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT * FROM get_log_statistics(%s)", (days,))
                return c.fetchall()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas de logs: {str(e)}")
        return []

def cleanup_old_system_logs():
    """Limpia logs del sistema m√°s antiguos de 30 d√≠as."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT cleanup_old_logs()")
                deleted = c.fetchone()[0]
                conn.commit()
                logger.info(f"üßπ Logs limpiados: {deleted} registros eliminados")
                return deleted
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error limpiando logs antiguos: {str(e)}")
        return 0

def auto_initialize_supabase_tables():
    """Inicializa autom√°ticamente todas las tablas en Supabase si no existen."""
    try:
        logger.info("üîß Verificando e inicializando tablas en Supabase...")
        conn = get_db_connection()
        conn.autocommit = True

        with conn.cursor() as c:
            # Crear tabla puntos_usuarios
            c.execute("""
                CREATE TABLE IF NOT EXISTS puntos_usuarios (
                    user_id BIGINT PRIMARY KEY,
                    username TEXT DEFAULT '',
                    puntos_totales INTEGER DEFAULT 0,
                    nivel TEXT DEFAULT 'bronce',
                    solicitudes_aprobadas INTEGER DEFAULT 0,
                    encuestas_completadas INTEGER DEFAULT 0,
                    racha_dias INTEGER DEFAULT 0,
                    ultima_actividad TIMESTAMPTZ DEFAULT NOW(),
                    created_at TIMESTAMPTZ DEFAULT NOW(),
                    updated_at TIMESTAMPTZ DEFAULT NOW()
                )
            """)

            # Crear √≠ndice para username en puntos_usuarios
            c.execute("""
                CREATE INDEX IF NOT EXISTS idx_puntos_usuarios_username
                ON puntos_usuarios(LOWER(username))
            """)

            # Crear tabla transacciones_puntos
            c.execute("""
                CREATE TABLE IF NOT EXISTS transacciones_puntos (
                    id BIGSERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    puntos INTEGER NOT NULL,
                    tipo TEXT NOT NULL,
                    descripcion TEXT DEFAULT '',
                    admin_id BIGINT,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                )
            """)

            # Crear √≠ndice para transacciones
            c.execute("""
                CREATE INDEX IF NOT EXISTS idx_transacciones_user
                ON transacciones_puntos(user_id, created_at DESC)
            """)

            # Verificar y actualizar constraint de tipo de transacci√≥n
            c.execute("""
                SELECT constraint_name
                FROM information_schema.table_constraints
                WHERE table_name = 'transacciones_puntos'
                    AND constraint_name = 'tipo_transaccion_valido'
            """)
            constraint_exists = c.fetchone()

            if constraint_exists:
                # Eliminar constraint antiguo y recrear con 'manual' incluido
                c.execute("""
                    ALTER TABLE transacciones_puntos
                    DROP CONSTRAINT IF EXISTS tipo_transaccion_valido
                """)

            # Crear constraint actualizado
            c.execute("""
                ALTER TABLE transacciones_puntos
                ADD CONSTRAINT tipo_transaccion_valido
                CHECK (tipo = ANY (ARRAY[
                    'solicitud_aprobada'::text,
                    'encuesta_completada'::text,
                    'racha_semanal'::text,
                    'bono_admin'::text,
                    'canje_recompensa'::text,
                    'penalizacion'::text,
                    'ajuste_manual'::text,
                    'manual'::text
                ]))
            """)

            # Crear tabla recompensas_disponibles
            c.execute("""
                CREATE TABLE IF NOT EXISTS recompensas_disponibles (
                    id BIGSERIAL PRIMARY KEY,
                    nombre TEXT NOT NULL,
                    descripcion TEXT DEFAULT '',
                    costo_puntos INTEGER NOT NULL,
                    activa BOOLEAN DEFAULT TRUE,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                )
            """)

            # Crear tabla recompensas_canjeadas
            c.execute("""
                CREATE TABLE IF NOT EXISTS recompensas_canjeadas (
                    id BIGSERIAL PRIMARY KEY,
                    user_id BIGINT NOT NULL,
                    recompensa_id BIGINT NOT NULL,
                    puntos_gastados INTEGER NOT NULL,
                    created_at TIMESTAMPTZ DEFAULT NOW()
                )
            """)

            # Verificar y actualizar peticiones_registradas
            c.execute("""
                SELECT column_name
                FROM information_schema.columns
                WHERE table_name = 'peticiones_registradas'
            """)
            existing_columns = [row[0] for row in c.fetchall()]

            if not existing_columns:
                # Crear tabla peticiones_registradas si no existe
                c.execute("""
                    CREATE TABLE IF NOT EXISTS peticiones_registradas (
                        ticket_number TEXT PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        username TEXT DEFAULT '',
                        chat_id BIGINT,
                        message_text TEXT DEFAULT '',
                        estado TEXT DEFAULT 'pendiente',
                        timestamp TIMESTAMPTZ DEFAULT NOW(),
                        chat_title TEXT,
                        thread_id BIGINT,
                        confirmation_message_id BIGINT,
                        created_at TIMESTAMPTZ DEFAULT NOW(),
                        updated_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)
            else:
                # Agregar columnas faltantes si la tabla ya existe
                if 'chat_id' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS chat_id BIGINT")
                if 'estado' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS estado TEXT DEFAULT 'pendiente'")
                if 'timestamp' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS timestamp TIMESTAMPTZ DEFAULT NOW()")
                if 'chat_title' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS chat_title TEXT")
                if 'thread_id' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS thread_id BIGINT")
                if 'confirmation_message_id' not in existing_columns:
                    c.execute("ALTER TABLE peticiones_registradas ADD COLUMN IF NOT EXISTS confirmation_message_id BIGINT")

            logger.info("‚úÖ Tablas de Supabase verificadas e inicializadas correctamente")

        conn.close()
        return True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al inicializar tablas de Supabase: {str(e)}")
        return False

def initialize_database_tables():
    """Inicializa todas las tablas necesarias en la base de datos."""
    try:
        conn = get_db_connection()
        conn.autocommit = True
        try:
            with conn.cursor() as c:
                logger.info("üîß Inicializando tablas de la base de datos...")

                # Primero, agregar columnas faltantes en tablas existentes
                try:
                    # Verificar y agregar columnas a schedule_warnings si la tabla existe
                    c.execute("""
                        SELECT column_name
                        FROM information_schema.columns
                        WHERE table_name = 'schedule_warnings'
                    """)
                    existing_columns = [row[0] for row in c.fetchall()]

                    if existing_columns:  # La tabla existe
                        logger.info("üìã Tabla schedule_warnings existe, verificando columnas...")

                        if 'is_muted' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN is_muted BOOLEAN DEFAULT FALSE NOT NULL")
                            logger.info("‚úÖ Columna is_muted agregada")

                        if 'muted_at' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN muted_at TIMESTAMPTZ")
                            logger.info("‚úÖ Columna muted_at agregada")

                        if 'unmute_at' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN unmute_at TIMESTAMPTZ")
                            logger.info("‚úÖ Columna unmute_at agregada")

                        if 'last_warning_message_id' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN last_warning_message_id BIGINT")
                            logger.info("‚úÖ Columna last_warning_message_id agregada")

                        if 'created_at' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL")
                            logger.info("‚úÖ Columna created_at agregada")

                        if 'updated_at' not in existing_columns:
                            c.execute("ALTER TABLE schedule_warnings ADD COLUMN updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL")
                            logger.info("‚úÖ Columna updated_at agregada")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Error verificando/agregando columnas: {str(e)}")

                # Tabla de usuarios
                c.execute("""
                    CREATE TABLE IF NOT EXISTS usuarios (
                        user_id BIGINT PRIMARY KEY,
                        username TEXT NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de estados de grupos
                c.execute("""
                    CREATE TABLE IF NOT EXISTS grupos_estados (
                        chat_id BIGINT PRIMARY KEY,
                        title TEXT NOT NULL,
                        activo BOOLEAN DEFAULT TRUE,
                        created_at TIMESTAMPTZ DEFAULT NOW(),
                        updated_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de peticiones registradas (pendientes)
                c.execute("""
                    CREATE TABLE IF NOT EXISTS peticiones_registradas (
                        ticket_number BIGINT PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        message_text TEXT NOT NULL,
                        timestamp TIMESTAMPTZ DEFAULT NOW(),
                        chat_title TEXT,
                        thread_id BIGINT,
                        confirmation_message_id BIGINT
                    )
                """)

                # Tabla de historial de solicitudes
                c.execute("""
                    CREATE TABLE IF NOT EXISTS historial_solicitudes (
                        ticket_number BIGINT PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        message_text TEXT NOT NULL,
                        estado TEXT NOT NULL,
                        timestamp TIMESTAMPTZ DEFAULT NOW(),
                        fecha_gestion TIMESTAMPTZ DEFAULT NOW(),
                        chat_title TEXT,
                        thread_id BIGINT,
                        admin_id BIGINT,
                        admin_username TEXT
                    )
                """)

                # Tabla de peticiones por usuario
                c.execute("""
                    CREATE TABLE IF NOT EXISTS peticiones_por_usuario (
                        user_id BIGINT PRIMARY KEY,
                        count INTEGER DEFAULT 0,
                        chat_id BIGINT,
                        username TEXT,
                        last_reset TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de encuestas de satisfacci√≥n
                c.execute("""
                    CREATE TABLE IF NOT EXISTS encuestas_satisfaccion (
                        id BIGSERIAL PRIMARY KEY,
                        ticket_number BIGINT NOT NULL,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        satisfaccion TEXT NOT NULL,
                        timestamp TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de encuestas pendientes
                c.execute("""
                    CREATE TABLE IF NOT EXISTS pending_surveys (
                        ticket_number BIGINT PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        message_id BIGINT,
                        completed BOOLEAN DEFAULT FALSE,
                        reminder_sent BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de horarios del bot
                c.execute("""
                    CREATE TABLE IF NOT EXISTS bot_schedule (
                        id SERIAL PRIMARY KEY,
                        days_of_week TEXT NOT NULL,
                        start_hour INTEGER NOT NULL,
                        end_hour INTEGER NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de cach√©
                c.execute("""
                    CREATE TABLE IF NOT EXISTS cache (
                        key TEXT PRIMARY KEY,
                        value TEXT NOT NULL,
                        expires_at TIMESTAMPTZ NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de modo mantenimiento
                c.execute("""
                    CREATE TABLE IF NOT EXISTS maintenance_mode (
                        id SERIAL PRIMARY KEY,
                        is_active BOOLEAN DEFAULT FALSE,
                        message TEXT,
                        scheduled_until TIMESTAMPTZ,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de votos de solicitudes
                c.execute("""
                    CREATE TABLE IF NOT EXISTS request_votes (
                        id BIGSERIAL PRIMARY KEY,
                        ticket_number BIGINT NOT NULL,
                        user_id BIGINT NOT NULL,
                        vote TEXT NOT NULL,
                        timestamp TIMESTAMPTZ DEFAULT NOW(),
                        UNIQUE(ticket_number, user_id)
                    )
                """)

                # Tabla de logs del sistema
                c.execute("""
                    CREATE TABLE IF NOT EXISTS system_logs (
                        id BIGSERIAL PRIMARY KEY,
                        log_type TEXT NOT NULL,
                        message TEXT NOT NULL,
                        user_id BIGINT,
                        username TEXT,
                        timestamp TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de estad√≠sticas de duplicados
                c.execute("""
                    CREATE TABLE IF NOT EXISTS duplicate_detections (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        request_text TEXT NOT NULL,
                        duplicate_ticket BIGINT NOT NULL,
                        similarity_score NUMERIC(5,2) NOT NULL,
                        chat_id BIGINT NOT NULL,
                        detected_at TIMESTAMPTZ DEFAULT NOW(),
                        action_taken TEXT DEFAULT 'rejected'
                    )
                """)

                # Tabla de configuraci√≥n de notificaciones
                c.execute("""
                    CREATE TABLE IF NOT EXISTS notification_settings (
                        id SERIAL PRIMARY KEY,
                        enabled BOOLEAN DEFAULT TRUE,
                        updated_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de peticiones incorrectas
                c.execute("""
                    CREATE TABLE IF NOT EXISTS peticiones_incorrectas (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        attempt_count INTEGER DEFAULT 1,
                        timestamp TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de abuso de botones
                c.execute("""
                    CREATE TABLE IF NOT EXISTS abuso_botones (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        ticket_number BIGINT NOT NULL,
                        attempt_count INTEGER DEFAULT 1,
                        last_attempt TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de mensajes de confirmaci√≥n
                c.execute("""
                    CREATE TABLE IF NOT EXISTS confirmation_messages (
                        ticket_number BIGINT PRIMARY KEY,
                        chat_id BIGINT NOT NULL,
                        message_id BIGINT NOT NULL,
                        user_id BIGINT NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de mantenimientos programados
                c.execute("""
                    CREATE TABLE IF NOT EXISTS scheduled_maintenance (
                        id SERIAL PRIMARY KEY,
                        scheduled_at TIMESTAMPTZ NOT NULL,
                        duration_minutes INTEGER,
                        message TEXT,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de mensajes de mantenimiento
                c.execute("""
                    CREATE TABLE IF NOT EXISTS maintenance_messages (
                        id BIGSERIAL PRIMARY KEY,
                        chat_id BIGINT NOT NULL,
                        message_id BIGINT NOT NULL,
                        maintenance_id INTEGER,
                        message_type TEXT NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de mensajes de notificaci√≥n
                c.execute("""
                    CREATE TABLE IF NOT EXISTS notification_messages (
                        id BIGSERIAL PRIMARY KEY,
                        chat_id BIGINT NOT NULL,
                        message_id BIGINT NOT NULL,
                        notification_type TEXT NOT NULL,
                        auto_delete_at TIMESTAMPTZ,
                        deleted BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de mensajes de penalizaci√≥n
                c.execute("""
                    CREATE TABLE IF NOT EXISTS penalty_messages (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        message_id BIGINT NOT NULL,
                        penalty_type TEXT NOT NULL,
                        timestamp TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de intentos de grupo de respaldo
                c.execute("""
                    CREATE TABLE IF NOT EXISTS backup_group_attempts (
                        user_id BIGINT PRIMARY KEY,
                        username TEXT NOT NULL,
                        attempt_count INTEGER DEFAULT 1,
                        last_attempt TIMESTAMPTZ DEFAULT NOW(),
                        last_message_id BIGINT
                    )
                """)

                # Tabla de advertencias de horario
                c.execute("""
                    CREATE TABLE IF NOT EXISTS schedule_warnings (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        chat_id BIGINT NOT NULL,
                        warning_count INTEGER DEFAULT 0 NOT NULL,
                        last_warning_at TIMESTAMPTZ,
                        is_muted BOOLEAN DEFAULT FALSE NOT NULL,
                        muted_at TIMESTAMPTZ,
                        unmute_at TIMESTAMPTZ,
                        last_warning_message_id BIGINT,
                        created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
                        updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
                        UNIQUE(user_id, chat_id)
                    )
                """)

                # Tabla de configuraci√≥n del bot
                c.execute("""
                    CREATE TABLE IF NOT EXISTS bot_settings (
                        key TEXT PRIMARY KEY,
                        value TEXT NOT NULL,
                        updated_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de recompensas semanales
                c.execute("""
                    CREATE TABLE IF NOT EXISTS weekly_rewards (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        extra_requests INTEGER DEFAULT 0,
                        week_end TIMESTAMPTZ NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tabla de penalizaciones semanales
                c.execute("""
                    CREATE TABLE IF NOT EXISTS weekly_penalties (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        username TEXT NOT NULL,
                        penalty_requests INTEGER DEFAULT 0,
                        week_end TIMESTAMPTZ NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW()
                    )
                """)

                # Tablas del sistema de puntos
                c.execute("""
                    CREATE TABLE IF NOT EXISTS puntos_usuarios (
                        user_id BIGINT PRIMARY KEY,
                        username TEXT NOT NULL,
                        puntos_totales INTEGER DEFAULT 0 NOT NULL,
                        nivel TEXT DEFAULT 'bronce' NOT NULL,
                        solicitudes_aprobadas INTEGER DEFAULT 0 NOT NULL,
                        encuestas_completadas INTEGER DEFAULT 0 NOT NULL,
                        racha_actual INTEGER DEFAULT 0 NOT NULL,
                        racha_maxima INTEGER DEFAULT 0 NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
                        updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
                    )
                """)

                c.execute("""
                    CREATE TABLE IF NOT EXISTS transacciones_puntos (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        puntos INTEGER NOT NULL,
                        tipo TEXT NOT NULL,
                        descripcion TEXT NOT NULL,
                        admin_id BIGINT,
                        created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
                    )
                """)

                c.execute("""
                    CREATE TABLE IF NOT EXISTS recompensas_disponibles (
                        id SERIAL PRIMARY KEY,
                        nombre TEXT NOT NULL,
                        descripcion TEXT NOT NULL,
                        costo_puntos INTEGER NOT NULL,
                        activa BOOLEAN DEFAULT TRUE NOT NULL,
                        created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
                    )
                """)

                c.execute("""
                    CREATE TABLE IF NOT EXISTS recompensas_canjeadas (
                        id BIGSERIAL PRIMARY KEY,
                        user_id BIGINT NOT NULL,
                        recompensa_id INTEGER NOT NULL,
                        puntos_gastados INTEGER NOT NULL,
                        canjeado_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
                    )
                """)

                # Crear √≠ndices solo si las columnas existen
                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_peticiones_registradas_user ON peticiones_registradas(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_peticiones_registradas_timestamp ON peticiones_registradas(timestamp DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_historial_user ON historial_solicitudes(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_historial_estado ON historial_solicitudes(estado)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_historial_fecha ON historial_solicitudes(fecha_gestion DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_encuestas_ticket ON encuestas_satisfaccion(ticket_number)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_encuestas_user ON encuestas_satisfaccion(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_cache_expires ON cache(expires_at)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_request_votes_ticket ON request_votes(ticket_number)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_duplicate_detections_user ON duplicate_detections(user_id, detected_at DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_duplicate_detections_ticket ON duplicate_detections(duplicate_ticket)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_system_logs_timestamp ON system_logs(timestamp DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_peticiones_incorrectas_user ON peticiones_incorrectas(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_peticiones_incorrectas_timestamp ON peticiones_incorrectas(timestamp DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_abuso_botones_user ON abuso_botones(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_abuso_botones_ticket ON abuso_botones(ticket_number)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_schedule_warnings_user ON schedule_warnings(user_id, chat_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_schedule_warnings_unmute ON schedule_warnings(unmute_at) WHERE is_muted = TRUE")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_notification_messages_auto_delete ON notification_messages(auto_delete_at) WHERE deleted = FALSE")
                except Exception:
                    pass

                # √çndices para el sistema de puntos
                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_puntos_usuarios_nivel ON puntos_usuarios(nivel)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_puntos_usuarios_puntos ON puntos_usuarios(puntos_totales DESC)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_transacciones_puntos_user ON transacciones_puntos(user_id)")
                except Exception:
                    pass

                try:
                    c.execute("CREATE INDEX IF NOT EXISTS idx_recompensas_canjeadas_user ON recompensas_canjeadas(user_id)")
                except Exception:
                    pass

                logger.info("‚úÖ Todas las tablas inicializadas correctamente")
        finally:
            conn.autocommit = False
            release_db_connection(conn)
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error inicializando tablas: {str(e)}")
        raise

def test_db_connection():
    """Prueba la conexi√≥n a la base de datos."""
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as c:
            c.execute("SELECT 1")
        return True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al probar la conexi√≥n a la base de datos: {str(e)}")
        return False
    finally:
        if conn:
            release_db_connection(conn)

def get_maintenance_mode():
    """Obtiene el estado del modo de mantenimiento."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT is_active, message, scheduled_until FROM maintenance_mode ORDER BY created_at DESC LIMIT 1")
                result = c.fetchone()
                if result:
                    return {
                        "is_active": result["is_active"],
                        "message": result["message"],
                        "scheduled_until": result["scheduled_until"]
                    }
                return {"is_active": False, "message": None, "scheduled_until": None}
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener modo de mantenimiento: {str(e)}")
        return {"is_active": False, "message": None, "scheduled_until": None}

def set_maintenance_mode(is_active, message=None, scheduled_until=None):
    """Establece el modo de mantenimiento."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO maintenance_mode (is_active, message, scheduled_until, created_at) 
                             VALUES (%s, %s, %s, %s)""",
                          (is_active, message, scheduled_until, datetime.now(SPAIN_TZ)))
                conn.commit()
        logger.info(f"‚úÖ Modo de mantenimiento {'activado' if is_active else 'desactivado'}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al establecer modo de mantenimiento: {str(e)}")

def is_maintenance_active():
    """Verifica si el modo de mantenimiento est√° activo."""
    maintenance = get_maintenance_mode()
    if not maintenance["is_active"]:
        return False
    
    if maintenance["scheduled_until"]:
        now = datetime.now(SPAIN_TZ)
        if isinstance(maintenance["scheduled_until"], str):
            scheduled_until = datetime.fromisoformat(maintenance["scheduled_until"])
        else:
            scheduled_until = maintenance["scheduled_until"]
        
        if now >= scheduled_until:
            set_maintenance_mode(False)
            return False
    
    return True

async def check_suspicious_activity(context: ContextTypes.DEFAULT_TYPE):
    """Verifica y alerta sobre actividad sospechosa."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT user_id, COUNT(*) as attempts 
                    FROM peticiones_incorrectas 
                    WHERE timestamp > %s 
                    GROUP BY user_id 
                    HAVING COUNT(*) >= 5
                """, (datetime.now(SPAIN_TZ) - timedelta(hours=24),))
                
                incorrect_attempts = c.fetchall()
                
                c.execute("""
                    SELECT user_id, COUNT(*) as attempts 
                    FROM abuso_botones 
                    WHERE last_attempt > %s 
                    GROUP BY user_id 
                    HAVING COUNT(*) >= 10
                """, (datetime.now(SPAIN_TZ) - timedelta(hours=24),))
                
                button_abuse = c.fetchall()
                
                for attempt in incorrect_attempts:
                    user_id = attempt["user_id"]
                    attempts = attempt["attempts"]
                    
                    alert_message = (
                        f"‚ö†Ô∏è *Alerta de Actividad Sospechosa* ‚ö†Ô∏è\n"
                        f"üë§ *Usuario:* {user_id}\n"
                        f"üìä *Intentos incorrectos:* {attempts} en 24h\n"
                        f"‚ö†Ô∏è *Acci√≥n sugerida:* Revisar/Advertir al usuario\n"
                        f"‚è∞ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}"
                    )
                    
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=GROUP_DESTINO,
                        text=alert_message,
                        parse_mode="Markdown"
                    )
                
                for abuse in button_abuse:
                    user_id = abuse["user_id"]
                    attempts = abuse["attempts"]
                    
                    alert_message = (
                        f"üö® *Alerta de Abuso de Botones* üö®\n"
                        f"üë§ *Usuario:* {user_id}\n"
                        f"üìä *Intentos de abuso:* {attempts} en 24h\n"
                        f"‚ö†Ô∏è *Acci√≥n sugerida:* Revisar/Kick del usuario\n"
                        f"‚è∞ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}"
                    )
                    
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=GROUP_DESTINO,
                        text=alert_message,
                        parse_mode="Markdown"
                    )
                    
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al verificar actividad sospechosa: {str(e)}")

def add_vote(ticket_number, user_id, vote):
    """A√±ade un voto a una solicitud."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO request_votes (ticket_number, user_id, vote, timestamp) 
                             VALUES (%s, %s, %s, %s)
                             ON CONFLICT (ticket_number, user_id) DO UPDATE SET 
                             vote = EXCLUDED.vote, timestamp = EXCLUDED.timestamp""",
                          (ticket_number, user_id, vote, datetime.now(SPAIN_TZ)))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al a√±adir voto: {str(e)}")

def get_votes_summary(ticket_number):
    """Obtiene el resumen de votos para una solicitud."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""SELECT vote, COUNT(*) as count 
                             FROM request_votes 
                             WHERE ticket_number = %s 
                             GROUP BY vote""", (ticket_number,))
                votes = dict(c.fetchall())
                return {
                    "positive": votes.get(1, 0),
                    "negative": votes.get(-1, 0),
                    "total": sum(votes.values())
                }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener votos: {str(e)}")
        return {"positive": 0, "negative": 0, "total": 0}

def get_peticion_registrada(ticket_number: int) -> Optional[Dict[str, Any]]:
    """Obtiene los detalles de una solicitud registrada desde la base de datos o cach√©."""
    cache_key = f"peticion_{ticket_number}"
    cached_data = get_from_cache(cache_key)
    if cached_data:
        return cached_data

    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute(
                    "SELECT chat_id, username, user_id, message_text, message_id, timestamp, chat_title, thread_id, has_attachment, photo_file_id "
                    "FROM peticiones_registradas WHERE ticket_number = %s",
                    (ticket_number,)
                )
                result = c.fetchone()
                if result:
                    result_dict = dict(result)
                    set_to_cache(cache_key, result_dict)
                    return result_dict
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener solicitud para ticket_number={ticket_number}: {str(e)}")
        return None

def get_ticket_counter():
    """Obtiene el n√∫mero de ticket m√°s alto registrado."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT COALESCE(MAX(ticket_number), 0) FROM peticiones_registradas")
                max_registradas = c.fetchone()[0]
                if max_registradas is None:
                    max_registradas = 0
                    
                c.execute("SELECT COALESCE(MAX(ticket_number), 0) FROM historial_solicitudes")
                max_historial = c.fetchone()[0]
                if max_historial is None:
                    max_historial = 0
                    
        return max(max_registradas, max_historial, 0)
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener contador de tickets: {str(e)}")
        return 0

def get_ticket_origin(ticket_number: int):
    """
    Devuelve (chat_id, thread_id, message_id) donde se origin√≥ la petici√≥n.
    Busca primero en peticiones_registradas y, si no est√°, en historial_solicitudes.
    """
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Buscar en pendientes
                c.execute("""
                    SELECT chat_id, COALESCE(thread_id, 0) AS thread_id, COALESCE(message_id, 0) AS message_id
                    FROM peticiones_registradas
                    WHERE ticket_number = %s
                    ORDER BY timestamp DESC
                    LIMIT 1
                """, (ticket_number,))
                row = c.fetchone()
                if row:
                    return row["chat_id"], (row["thread_id"] or None), (row["message_id"] or None)

                # Buscar en historial (por si ya fue movida)
                c.execute("""
                    SELECT chat_id, COALESCE(thread_id, 0) AS thread_id, COALESCE(message_id, 0) AS message_id
                    FROM historial_solicitudes
                    WHERE ticket_number = %s
                    ORDER BY fecha_gestion DESC
                    LIMIT 1
                """, (ticket_number,))
                row = c.fetchone()
                if row:
                    return row["chat_id"], (row["thread_id"] or None), (row["message_id"] or None)
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo origen de ticket #{ticket_number}: {str(e)}")
    return None, None, None


async def notify_cancellation_to_origin(context: ContextTypes.DEFAULT_TYPE, ticket_number: int,
                                        username: str, cancelled_at: datetime):
    """
    Env√≠a el aviso de cancelaci√≥n al chat/canal de origen (y topic si aplica).
    Si tenemos message_id original, responde en hilo al mensaje original.
    """
    chat_id, thread_id, orig_msg_id = get_ticket_origin(ticket_number)
    if not chat_id:
        logger.warning(f"‚ö†Ô∏è No se pudo determinar el origen para el ticket #{ticket_number}")
        return

    fecha_txt = cancelled_at.astimezone(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")
    texto = (
        f"‚úÖ *Solicitud #{ticket_number} cancelada exitosamente*\n"
        f"üë§ *Usuario:* @{normalize_username(username)}\n"
        f"‚è∞ *Fecha:* {fecha_txt}"
    )

    send_kwargs = dict(
        chat_id=chat_id,
        text=texto,
        parse_mode="Markdown",
    )
    if thread_id:  # foro (topics) en supergrupos
        send_kwargs["message_thread_id"] = thread_id
    if orig_msg_id:  # responder al mensaje original si lo tenemos
        send_kwargs["reply_to_message_id"] = orig_msg_id

    await safe_bot_method(context.bot.send_message, **send_kwargs)

def increment_ticket_counter():
    """Incrementa el contador de tickets de forma segura, iniciando desde 1."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("BEGIN")
                
                c.execute("SELECT COALESCE(MAX(ticket_number), 0) FROM peticiones_registradas")
                max_registradas_result = c.fetchone()
                max_registradas = max_registradas_result[0] if max_registradas_result and max_registradas_result[0] is not None else 0
                
                c.execute("SELECT COALESCE(MAX(ticket_number), 0) FROM historial_solicitudes")
                max_historial_result = c.fetchone()
                max_historial = max_historial_result[0] if max_historial_result and max_historial_result[0] is not None else 0
                
                # Obtener el m√°ximo real
                current_max = max(max_registradas, max_historial, 0)
                
                # Si no hay tickets, empezar desde 1
                if current_max == 0:
                    new_ticket = 1
                else:
                    # Buscar el siguiente n√∫mero disponible secuencialmente
                    c.execute("""
                        SELECT ticket_number + 1 as next_ticket
                        FROM peticiones_registradas 
                        WHERE ticket_number + 1 NOT IN (
                            SELECT ticket_number FROM peticiones_registradas
                            UNION
                            SELECT ticket_number FROM historial_solicitudes
                        )
                        ORDER BY ticket_number
                        LIMIT 1
                    """)
                    gap_result = c.fetchone()
                    
                    if gap_result:
                        # Hay un gap, usar el primer n√∫mero disponible
                        new_ticket = gap_result[0]
                    else:
                        # No hay gaps, usar el siguiente n√∫mero despu√©s del m√°ximo
                        new_ticket = current_max + 1
                
                c.execute("COMMIT")
                
                logger.info(f"‚úÖ Nuevo ticket asignado: #{new_ticket}")
                return new_ticket
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al incrementar contador de tickets: {str(e)}")
        if 'conn' in locals():
            try:
                conn.rollback()
            except:
                pass
        return 1
    finally:
        if 'conn' in locals():
            release_db_connection(conn)
            
def get_peticiones_por_usuario(user_id):
    """Obtiene el conteo de peticiones de un usuario."""
    cache_key = f"user_peticiones_{user_id}"
    cached_data = get_from_cache(cache_key)
    if cached_data:
        return cached_data

    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT count, chat_id, username, last_reset FROM peticiones_por_usuario WHERE user_id = %s", (user_id,))
                result = c.fetchone()
                if result:
                    result_dict = dict(result)
                    now = datetime.now(SPAIN_TZ)
                    last_reset = result_dict["last_reset"]
                    if last_reset is None:
                        result_dict["count"] = 0
                        result_dict["last_reset"] = now
                        set_peticiones_por_usuario(user_id, 0, result_dict["chat_id"], result_dict["username"], now)
                    else:
                        last_reset = last_reset.astimezone(SPAIN_TZ)
                        time_diff = (now - last_reset).total_seconds()
                        if time_diff >= 86400:  # 24 horas
                            result_dict["count"] = 0
                            result_dict["last_reset"] = now
                            set_peticiones_por_usuario(user_id, 0, result_dict["chat_id"], result_dict["username"], now)
                    set_to_cache(cache_key, result_dict)
                    return result_dict
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener peticiones para user_id={user_id}: {str(e)}")
        return None

def set_peticiones_por_usuario(user_id, count, chat_id, username, last_reset=None):
    """Actualiza el conteo de peticiones de un usuario."""
    if last_reset is None:
        last_reset = datetime.now(SPAIN_TZ)
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO peticiones_por_usuario (user_id, count, chat_id, username, last_reset) 
                             VALUES (%s, %s, %s, %s, %s)
                             ON CONFLICT (user_id) DO UPDATE SET 
                             count = EXCLUDED.count, chat_id = EXCLUDED.chat_id, username = EXCLUDED.username, last_reset = EXCLUDED.last_reset""",
                          (user_id, count, chat_id, username, last_reset))
                c.execute("""INSERT INTO usuarios (user_id, username) 
                             VALUES (%s, %s) 
                             ON CONFLICT (user_id) DO UPDATE SET username = EXCLUDED.username""",
                          (user_id, username))
                conn.commit()
        cache_key = f"user_peticiones_{user_id}"
        set_to_cache(cache_key, {"count": count, "chat_id": chat_id, "username": username, "last_reset": last_reset})
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar peticiones para user_id={user_id}: {str(e)}")

def get_user_id_by_username(username):
    """Obtiene el ID de usuario por su nombre de usuario (sin @, case-insensitive)."""
    try:
        uname = (username or "").lstrip("@").lower()
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT user_id FROM usuarios WHERE LOWER(username) = %s", (uname,))
                result = c.fetchone()
                return result[0] if result else None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener user_id para username={username}: {str(e)}")
        return None
        
def set_peticion_registrada(ticket_number, data):
    """Registra o actualiza una petici√≥n."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO peticiones_registradas 
                             (ticket_number, chat_id, username, user_id, message_text, message_id, timestamp, chat_title, thread_id, has_attachment, photo_file_id) 
                             VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                             ON CONFLICT (ticket_number) DO UPDATE SET 
                             chat_id = EXCLUDED.chat_id, username = EXCLUDED.username, user_id = EXCLUDED.user_id, 
                             message_text = EXCLUDED.message_text, message_id = EXCLUDED.message_id, timestamp = EXCLUDED.timestamp, 
                             chat_title = EXCLUDED.chat_title, thread_id = EXCLUDED.thread_id, has_attachment = EXCLUDED.has_attachment, 
                             photo_file_id = EXCLUDED.photo_file_id""",
                          (ticket_number, data["chat_id"], data["username"], data["user_id"],
                           data["message_text"], data["message_id"], data["timestamp"], data["chat_title"],
                           data["thread_id"], data.get("has_attachment", False), data.get("photo_file_id")))
                conn.commit()
        cache_key = f"peticion_{ticket_number}"
        set_to_cache(cache_key, data)
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar petici√≥n para ticket_number={ticket_number}: {str(e)}")

def can_make_request(user_id):
    """Verifica si un usuario puede hacer solicitudes (administradores tienen solicitudes ilimitadas)."""
    if user_id in ADMINISTRATORS:
        return True

    # Verificar si tiene peticiones extra
    extra_requests = get_user_extra_requests(user_id)
    user_data = get_peticiones_por_usuario(user_id)

    if user_data is None:
        return True

    # Verificar si tiene penalizaci√≥n
    penalty = get_user_weekly_penalty(user_id)
    limit = MAX_REQUESTS_PER_USER + extra_requests - penalty

    return user_data["count"] < limit

def get_user_extra_requests(user_id):
    """Obtiene las peticiones extra del usuario para esta semana."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT extra_requests FROM weekly_rewards
                    WHERE user_id = %s AND week_end > NOW()
                    ORDER BY created_at DESC LIMIT 1
                """, (user_id,))
                result = c.fetchone()
                return result['extra_requests'] if result else 0
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo peticiones extra: {str(e)}")
        return 0

def get_user_weekly_penalty(user_id):
    """Obtiene la penalizaci√≥n del usuario para esta semana."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT penalty_requests FROM weekly_penalties
                    WHERE user_id = %s AND week_end > NOW()
                    ORDER BY created_at DESC LIMIT 1
                """, (user_id,))
                result = c.fetchone()
                return result['penalty_requests'] if result else 0
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo penalizaci√≥n: {str(e)}")
        return 0

def add_weekly_reward(user_id, username):
    """Agrega una recompensa semanal al usuario."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                week_end = datetime.now(SPAIN_TZ) + timedelta(days=7)
                c.execute("""
                    INSERT INTO weekly_rewards (user_id, username, extra_requests, week_end, created_at)
                    VALUES (%s, %s, 1, %s, %s)
                """, (user_id, username, week_end, datetime.now(SPAIN_TZ)))
                conn.commit()
        logger.info(f"‚úÖ Recompensa semanal agregada a user_id={user_id}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error agregando recompensa: {str(e)}")

def add_weekly_penalty(user_id, username):
    """Agrega una penalizaci√≥n semanal al usuario."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                week_end = datetime.now(SPAIN_TZ) + timedelta(days=7)
                c.execute("""
                    INSERT INTO weekly_penalties (user_id, username, penalty_requests, week_end, created_at)
                    VALUES (%s, %s, 1, %s, %s)
                """, (user_id, username, week_end, datetime.now(SPAIN_TZ)))
                conn.commit()
        logger.info(f"‚ö†Ô∏è Penalizaci√≥n semanal agregada a user_id={user_id}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error agregando penalizaci√≥n: {str(e)}")

def del_peticion_registrada(ticket_number):
    """Elimina una petici√≥n registrada."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM peticiones_registradas WHERE ticket_number = %s", (ticket_number,))
                c.execute("DELETE FROM cache WHERE key = %s", (f"peticion_{ticket_number}",))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al eliminar petici√≥n para ticket_number={ticket_number}: {str(e)}")

def get_historial_solicitud(ticket_number):
    """Obtiene los detalles de una solicitud en el historial."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT chat_id, username, user_id, message_text, chat_title, estado, fecha_gestion, admin_username, url, reason, has_attachment, photo_file_id "
                          "FROM historial_solicitudes WHERE ticket_number = %s", (ticket_number,))
                result = c.fetchone()
                return dict(result) if result else None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener historial para ticket_number={ticket_number}: {str(e)}")
        return None

async def set_historial_solicitud(ticket_number: int, data: dict):
    """Registra o actualiza una solicitud en el historial."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO historial_solicitudes 
                             (ticket_number, chat_id, username, user_id, message_text, chat_title, estado, fecha_gestion, admin_username, url, reason, has_attachment, photo_file_id) 
                             VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                             ON CONFLICT (ticket_number) DO UPDATE SET 
                             chat_id = EXCLUDED.chat_id, username = EXCLUDED.username, user_id = EXCLUDED.user_id, message_text = EXCLUDED.message_text, 
                             chat_title = EXCLUDED.chat_title, estado = EXCLUDED.estado, fecha_gestion = EXCLUDED.fecha_gestion, 
                             admin_username = EXCLUDED.admin_username, url = EXCLUDED.url, reason = EXCLUDED.reason,
                             has_attachment = EXCLUDED.has_attachment, photo_file_id = EXCLUDED.photo_file_id""",
                          (ticket_number, data["chat_id"], data["username"], data.get("user_id"), data["message_text"],
                           data["chat_title"], data["estado"], data["fecha_gestion"], data["admin_username"],
                           data.get("url"), data.get("reason"), data.get("has_attachment", False), data.get("photo_file_id")))
                conn.commit()

        # Otorgar o restar puntos seg√∫n el estado (Sistema de gamificaci√≥n)
        if SISTEMA_PUNTOS_DISPONIBLE:
            try:
                estado = data["estado"].lower()
                user_id = data.get("user_id")
                username = data.get("username", "Usuario")

                # Sistema de puntos deshabilitado temporalmente
                # if estado == "subido":
                #     tiene_enlace = data.get("url") and data["url"] != "Aprobado sin enlace"
                #     puntos = PUNTOS_CONFIG["solicitud_aprobada_calidad"] if tiene_enlace else PUNTOS_CONFIG["solicitud_aprobada"]
                #     modificar_puntos(user_id, username, puntos, "solicitud_aprobada", f"Solicitud #{ticket_number} aprobada", ticket_number)
                #     logger.info(f"üí∞ +{puntos} puntos para @{username} (solicitud aprobada)")
                # elif estado == "denegado":
                #     modificar_puntos(user_id, username, PUNTOS_CONFIG["solicitud_denegada"], "solicitud_denegada", f"Solicitud #{ticket_number} denegada", ticket_number)
                #     logger.info(f"üí∞ {PUNTOS_CONFIG['solicitud_denegada']} puntos para @{username} (solicitud denegada)")
                # elif estado == "eliminado":
                #     modificar_puntos(user_id, username, PUNTOS_CONFIG["solicitud_eliminada"], "solicitud_eliminada", f"Solicitud #{ticket_number} eliminada", ticket_number)
                #     logger.info(f"üí∞ {PUNTOS_CONFIG['solicitud_eliminada']} puntos para @{username} (solicitud eliminada)")
                pass

            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error otorgando puntos en set_historial_solicitud: {str(e)}")

        await send_push_notification(ticket_number, data)
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar historial para ticket_number={ticket_number}: {str(e)}")
    finally:
        if "conn" in locals():
            release_db_connection(conn)

async def send_push_notification(ticket_number: int, data: dict):
    """Env√≠a notificaci√≥n push al usuario por mensaje privado cuando cambia el estado de su solicitud."""
    try:
        user_id = data.get("user_id")
        if not user_id:
            peticion = get_peticion_registrada(ticket_number)
            if peticion:
                user_id = peticion["user_id"]
        
        if not user_id:
            logger.warning(f"‚ö†Ô∏è No se pudo obtener user_id para ticket #{ticket_number}")
            return
        
        estado = data["estado"].lower()
        username_escaped = escape_markdown(data["username"], preserve_username=True)
        
        if estado == "subido":
            if data.get("url") and data["url"] != "Aprobado sin enlace":
                link_escaped = escape_markdown(data["url"])
                notification_text = (
                    f"üéâ *Tu solicitud #{ticket_number} ha sido aprobada!* üéâ\n"
                    f"Hola {username_escaped}, tu solicitud ha sido procesada exitosamente, recuerda valorar tu experiencia, nos ayuda a mejorar mucho *Equipo de Administraci√≥n EntresHijos*.\n\n"
                    f"üîó *Enlace:* {link_escaped}\n"
                    f"‚è∞ *Fecha:* {data['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                    f"¬°Disfruta del contenido! üòä"
                )
            else:
                notification_text = (
                    f"‚úÖ *Tu solicitud #{ticket_number} ha sido aprobada!* ‚úÖ\n"
                    f"Hola {username_escaped}, tu solicitud ha sido procesada exitosamente, recuerda valorar tu experiencia, nos ayuda a mejorar mucho *Equipo de Administraci√≥n EntresHijos*.\n\n"
                    f"‚è∞ *Fecha:* {data['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                    f"¬°El contenido estar√° disponible pronto! üòä"
                )
        elif estado == "denegado":
            reason_escaped = escape_markdown(data.get("reason", "No especificado"))
            notification_text = (
                f"‚ùå *Tu solicitud #{ticket_number} ha sido denegada* ‚ùå\n"
                f"Hola {username_escaped}, lamentamos informarte que tu solicitud no pudo ser procesada.\n\n"
                f"üìù *Motivo:* {reason_escaped}\n"
                f"‚è∞ *Fecha:* {data['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"Para dudas, contacta con @admin. *Equipo EntresHijos* ü§ù"
            )
        elif estado == "eliminado":
            reason_escaped = escape_markdown(data.get("reason", "No especificado"))
            notification_text = (
                f"üóëÔ∏è *Tu solicitud #{ticket_number} ha sido eliminada* üóëÔ∏è\n"
                f"Hola {username_escaped}, tu solicitud ha sido eliminada del sistema por el administrador.\n\n"
                f"üìù *Motivo:* {reason_escaped}\n"
                f"‚è∞ *Fecha:* {data['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"Para m√°s informaci√≥n, contacta con @admin. *Equipo EntresHijos* ü§ù"
            )
        elif estado == "restaurado":
            notification_text = (
                f"üîÑ *Tu solicitud #{ticket_number} ha sido restaurada* üîÑ\n"
                f"Hola {username_escaped}, tu solicitud ha sido restaurada y vuelve a estar en proceso.\n\n"
                f"‚è∞ *Fecha:* {data['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"Ser√° procesada nuevamente por el *Equipo de Administraci√≥n EntresHijos*. ü§ù"
            )
        else:
            return
        
        try:
            await safe_bot_method(
                application.bot.send_message,
                chat_id=user_id,
                text=notification_text,
                parse_mode="Markdown"
            )
            logger.info(f"‚úÖ Notificaci√≥n privada enviada al usuario {user_id} para ticket #{ticket_number}")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo enviar notificaci√≥n privada al usuario {user_id}: {str(e)}")
            canal_info = CANALES_PETICIONES.get(data["chat_id"])
            if canal_info:
                await safe_bot_method(
                    application.bot.send_message,
                    chat_id=canal_info["chat_id"],
                    text=notification_text,
                    message_thread_id=canal_info["thread_id"],
                    parse_mode="Markdown"
                )
                logger.info(f"‚úÖ Notificaci√≥n enviada al canal espec√≠fico para ticket #{ticket_number} (fallback)")
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al enviar notificaci√≥n push para ticket #{ticket_number}: {str(e)}")

def del_historial_solicitud(ticket_number):
    """Elimina una solicitud del historial."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM historial_solicitudes WHERE ticket_number = %s", (ticket_number,))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al eliminar historial para ticket_number={ticket_number}: {str(e)}")

async def restore_request_from_history(ticket_number: int, admin_username: str):
    """Restaura una solicitud del historial a pendientes."""
    try:
        historial = get_historial_solicitud(ticket_number)
        if not historial:
            return False
        
        set_peticion_registrada(ticket_number, {
            "chat_id": historial["chat_id"],
            "username": historial["username"],
            "user_id": historial["user_id"],
            "message_text": historial["message_text"],
            "message_id": None,
            "timestamp": datetime.now(SPAIN_TZ),
            "chat_title": historial["chat_title"],
            "thread_id": CANALES_PETICIONES.get(historial["chat_id"], {}).get("thread_id"),
            "has_attachment": historial["has_attachment"],
            "photo_file_id": historial["photo_file_id"]
        })
        
        await set_historial_solicitud(ticket_number, {
            "chat_id": historial["chat_id"],
            "username": historial["username"],
            "user_id": historial["user_id"],
            "message_text": historial["message_text"],
            "chat_title": historial["chat_title"],
            "estado": "restaurado",
            "fecha_gestion": datetime.now(SPAIN_TZ),
            "admin_username": admin_username,
            "url": historial.get("url"),
            "reason": f"Solicitud restaurada por {admin_username}",
            "has_attachment": historial["has_attachment"],
            "photo_file_id": historial["photo_file_id"]
        })
        
        username_escaped = escape_markdown(historial["username"], preserve_username=True)
        message_text_escaped = escape_markdown(historial["message_text"])
        chat_title_escaped = escape_markdown(historial["chat_title"])
        
        destino_message = (
            f"üîÑ *Solicitud Restaurada* üîÑ\n"
            f"üë§ *Usuario:* {username_escaped} (ID: {historial['user_id']})\n"
            f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {chat_title_escaped}\n"
            f"‚è∞ *Fecha Original:* {historial['fecha_gestion'].strftime('%d/%m/%Y %H:%M:%S')}\n"
            f"üîÑ *Restaurado:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n"
            f"üë§ *Por:* {escape_markdown(admin_username, preserve_username=True)}\n"
            f"üìé *Adjunto:* {'S√≠' if historial['has_attachment'] else 'No'}\n"
            f"ü§ù *Bot de Entreshijos*"
        )
        
        await safe_bot_method(
            application.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=destino_message,
            parse_mode="Markdown"
        )
        
        del_historial_solicitud(ticket_number)
        
        return True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al restaurar solicitud {ticket_number}: {str(e)}")
        return False

def get_grupos_estados():
    """Obtiene el estado de todos los grupos."""
    cache_key = "grupos_estados"
    cached_data = get_from_cache(cache_key)
    if cached_data:
        return cached_data

    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT chat_id, title, activo FROM grupos_estados")
                result = {row["chat_id"]: {"title": row["title"], "activo": row["activo"]} for row in c.fetchall()}
                set_to_cache(cache_key, result)
                return result
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener estados de grupos: {str(e)}")
        return {}

def set_grupo_estado(chat_id, title, activo=True):
    """Actualiza el estado de un grupo."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""INSERT INTO grupos_estados (chat_id, title, activo)
                             VALUES (%s, %s, %s)
                             ON CONFLICT (chat_id) DO UPDATE SET title = EXCLUDED.title, activo = EXCLUDED.activo""",
                          (chat_id, title, activo))
                conn.commit()

        cache_key = "grupos_estados"
        clear_from_cache(cache_key)

        logger.info(f"‚úÖ Grupo {chat_id} guardado en BD con estado activo={activo}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar estado de grupo para chat_id={chat_id}: {str(e)}")

def get_peticiones_incorrectas(user_id):
    """Obtiene el historial de peticiones incorrectas de un usuario."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT timestamp, chat_id, attempt_count FROM peticiones_incorrectas WHERE user_id = %s ORDER BY timestamp DESC", (user_id,))
                return [dict(row) for row in c.fetchall()]
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener peticiones incorrectas para user_id={user_id}: {str(e)}")
        return []

def get_last_penalty_message(user_id, chat_id, penalty_type):
    """Obtiene el √∫ltimo mensaje de penalizaci√≥n de un usuario."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT message_id FROM penalty_messages
                    WHERE user_id = %s AND chat_id = %s AND penalty_type = %s
                    ORDER BY timestamp DESC LIMIT 1
                """, (user_id, chat_id, penalty_type))
                result = c.fetchone()
                return result['message_id'] if result else None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener √∫ltimo mensaje de penalizaci√≥n: {str(e)}")
        return None

def save_penalty_message(user_id, chat_id, message_id, penalty_type):
    """Guarda el ID del mensaje de penalizaci√≥n."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Eliminar mensaje anterior del mismo tipo
                c.execute("""
                    DELETE FROM penalty_messages
                    WHERE user_id = %s AND chat_id = %s AND penalty_type = %s
                """, (user_id, chat_id, penalty_type))

                # Guardar nuevo mensaje
                c.execute("""
                    INSERT INTO penalty_messages (user_id, chat_id, message_id, penalty_type, timestamp)
                    VALUES (%s, %s, %s, %s, %s)
                """, (user_id, chat_id, message_id, penalty_type, datetime.now(SPAIN_TZ)))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar mensaje de penalizaci√≥n: {str(e)}")

def add_peticion_incorrecta(user_id, timestamp, chat_id):
    """Registra una petici√≥n incorrecta."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Contar intentos del d√≠a actual
                today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
                c.execute("""
                    SELECT COUNT(*) FROM peticiones_incorrectas
                    WHERE user_id = %s AND timestamp >= %s
                """, (user_id, today_start))
                result = c.fetchone()
                attempt_count = result[0] + 1 if result else 1

                c.execute("INSERT INTO peticiones_incorrectas (user_id, timestamp, chat_id, attempt_count) VALUES (%s, %s, %s, %s)",
                          (user_id, timestamp, chat_id, attempt_count))
                conn.commit()
                return attempt_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al registrar petici√≥n incorrecta para user_id={user_id}: {str(e)}")
        return 1

def add_abuso_boton(user_id, chat_id, ticket_number):
    """Registra un intento de abuso en botones."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                now = datetime.now(SPAIN_TZ)
                
                # Contar abusos totales del usuario en las √∫ltimas 24 horas
                yesterday = now - timedelta(hours=24)
                c.execute("""
                    SELECT SUM(attempt_count) FROM abuso_botones 
                    WHERE user_id = %s AND last_attempt >= %s
                """, (user_id, yesterday))
                total_abuse_result = c.fetchone()
                total_abuse_count = total_abuse_result[0] if total_abuse_result and total_abuse_result[0] else 0
                
                c.execute("SELECT attempt_count FROM abuso_botones WHERE user_id = %s AND ticket_number = %s", (user_id, ticket_number))
                result = c.fetchone()
                if result:
                    attempt_count = result["attempt_count"] + 1
                    c.execute("UPDATE abuso_botones SET attempt_count = %s, last_attempt = %s WHERE user_id = %s AND ticket_number = %s",
                              (attempt_count, now, user_id, ticket_number))
                else:
                    attempt_count = 1
                    c.execute("INSERT INTO abuso_botones (user_id, chat_id, ticket_number, attempt_count, last_attempt) "
                              "VALUES (%s, %s, %s, %s, %s)", (user_id, chat_id, ticket_number, attempt_count, now))
                conn.commit()
                
                # Retornar tanto el intento actual como el total de abusos
                new_total_abuse = total_abuse_count + 1
                return attempt_count, new_total_abuse
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al registrar abuso de bot√≥n: {str(e)}")
        return 1, 1

def is_user_blocked_for_incorrect_requests(user_id):
    """Verifica si un usuario est√° bloqueado por peticiones incorrectas."""
    try:
        today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT COUNT(*) FROM peticiones_incorrectas 
                    WHERE user_id = %s AND timestamp >= %s
                """, (user_id, today_start))
                result = c.fetchone()
                incorrect_count = result[0] if result else 0
                return incorrect_count >= MAX_INCORRECT_ATTEMPTS
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error verificando bloqueo por peticiones incorrectas: {str(e)}")
        return False

def get_user_incorrect_attempts_today(user_id):
    """Obtiene el n√∫mero de intentos incorrectos del usuario hoy."""
    try:
        today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT COUNT(*) FROM peticiones_incorrectas 
                    WHERE user_id = %s AND timestamp >= %s
                """, (user_id, today_start))
                result = c.fetchone()
                return result[0] if result else 0
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo intentos incorrectos: {str(e)}")
        return 0

async def kick_user_for_button_abuse(context: ContextTypes.DEFAULT_TYPE, user_id: int, chat_id: int,
                                   username: str, total_abuse_count: int):
    """Expulsa a un usuario por abuso de botones."""
    try:
        # Obtener informaci√≥n del chat donde ocurri√≥ el abuso
        canal_info = None
        grupo_title = "Grupo desconocido"
        
        # Buscar en qu√© canal/grupo ocurri√≥ el abuso
        for grupo_chat_id, canal_data in CANALES_PETICIONES.items():
            if grupo_chat_id == chat_id:
                canal_info = canal_data
                grupo_title = GRUPOS_PREDEFINIDOS.get(grupo_chat_id, f"Grupo {grupo_chat_id}")
                break
        
        # Si no se encuentra en canales, usar el chat_id directamente
        if not canal_info:
            canal_info = {"chat_id": chat_id, "thread_id": None}
            grupo_title = GRUPOS_PREDEFINIDOS.get(chat_id, f"Grupo {chat_id}")
        
        username_display = f"@{username}" if not username.startswith("@") else username
        username_escaped = escape_markdown(username_display, preserve_username=True)
        fecha_hora = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")
        
        # Intentar expulsar al usuario del grupo
        kick_success = False
        try:
            await context.bot.ban_chat_member(
                chat_id=canal_info["chat_id"],
                user_id=user_id
            )
            kick_success = True
            logger.info(f"‚úÖ Usuario {user_id} expulsado exitosamente del grupo {canal_info['chat_id']}")

            # Enviar comando /ban al grupo de sincronizaci√≥n para que otro bot lo procese
            try:
                ban_command = f"/ban {username} Abuso reiterado de botones del sistema - {total_abuse_count} infracciones detectadas"
                await context.bot.send_message(
                    chat_id=BAN_GROUP_ID,
                    text=ban_command
                )
                logger.info(f"‚úÖ Comando /ban enviado al grupo {BAN_GROUP_ID} para {username}")
            except Exception as ban_error:
                logger.error(f"‚ö†Ô∏è Error enviando comando /ban: {str(ban_error)}")
        except Exception as kick_error:
            logger.error(f"‚ö†Ô∏è No se pudo expulsar al usuario {user_id}: {str(kick_error)}")
        
        # Mensaje para el grupo donde ocurri√≥ la infracci√≥n
        if kick_success:
            group_message = (
                f"üö® *Expulsi√≥n por Abuso de Botones* üö®\n\n"
                f"üë§ **Usuario expulsado:** {username_escaped}\n"
                f"üÜî **ID:** {user_id}\n"
                f"üìä **Abusos registrados:** {total_abuse_count}\n"
                f"üìç **Grupo:** {escape_markdown(grupo_title)}\n"
                f"‚è∞ **Fecha y hora:** {fecha_hora}\n\n"
                f"‚öñÔ∏è **Motivo:** Uso indebido reiterado de las funcionalidades del bot\n"
                f"üõ°Ô∏è **Acci√≥n:** Expulsi√≥n autom√°tica del grupo\n\n"
                f"üìã **Recordatorio para todos:**\n"
                f"‚Ä¢ Respeta las peticiones ajenas\n"
                f"‚Ä¢ Usa solo los botones de tus propias solicitudes\n"
                f"‚Ä¢ El abuso de funcionalidades conlleva expulsi√≥n\n\n"
                f"ü§ù *Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
            )
        else:
            group_message = (
                f"‚ö†Ô∏è *Intento de Expulsi√≥n por Abuso* ‚ö†Ô∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {user_id}\n"
                f"üìä **Abusos registrados:** {total_abuse_count}\n"
                f"üìç **Grupo:** {escape_markdown(grupo_title)}\n"
                f"‚è∞ **Fecha y hora:** {fecha_hora}\n\n"
                f"‚öñÔ∏è **Motivo:** Uso indebido reiterado de las funcionalidades del bot\n"
                f"‚ùå **Estado:** No se pudo expulsar autom√°ticamente (permisos insuficientes)\n\n"
                f"üîß **Acci√≥n requerida:** Expulsi√≥n manual por administrador\n\n"
                f"ü§ù *Sistema de Seguridad EntresHijos* üõ°Ô∏è"
            )
        
        # Enviar mensaje al grupo donde ocurri√≥ la infracci√≥n
        await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=group_message,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        
        # Notificar al grupo de administraci√≥n con bot√≥n
        admin_notification = (
            f"üö® *Expulsi√≥n Autom√°tica Ejecutada* üö®\n\n"
            f"üë§ **Usuario:** {username_escaped}\n"
            f"üÜî **ID:** {user_id}\n"
            f"üìä **Total de abusos:** {total_abuse_count}\n"
            f"üìç **Grupo de origen:** {escape_markdown(grupo_title)}\n"
            f"‚è∞ **Fecha y hora:** {fecha_hora}\n\n"
            f"‚öñÔ∏è **Motivo:** Abuso reiterado de botones del sistema\n"
            f"üõ°Ô∏è **Acci√≥n:** {'Expulsi√≥n exitosa' if kick_success else 'Expulsi√≥n fallida - Revisar permisos'}\n"
            f"üì¢ **Notificaci√≥n:** Grupo informado de la expulsi√≥n\n\n"
            f"üìã **Detalles t√©cnicos:**\n"
            f"‚Ä¢ L√≠mite configurado: {MAX_BUTTON_ABUSE_ATTEMPTS} abusos\n"
            f"‚Ä¢ Sistema de detecci√≥n: Autom√°tico\n"
            f"‚Ä¢ Per√≠odo de an√°lisis: 24 horas\n\n"
            f"üîß **Acci√≥n requerida:** {'Ninguna' if kick_success else 'Expulsi√≥n manual necesaria'}\n\n"
            f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
        )

        keyboard = [[InlineKeyboardButton("Gestionado ‚úÖ", callback_data=f"gestionado_expulsion_{user_id}")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=admin_notification,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        logger.info(f"üö® Usuario {user_id} procesado por abuso de botones - Expulsi√≥n: {'Exitosa' if kick_success else 'Fallida'}")
        return kick_success
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en expulsi√≥n por abuso de botones: {str(e)}")
        
        # Notificar error a administradores
        error_notification = (
            f"üö® *Error en Sistema de Expulsi√≥n* üö®\n\n"
            f"üë§ **Usuario:** {escape_markdown(username, preserve_username=True)}\n"
            f"üÜî **ID:** {user_id}\n"
            f"üìä **Abusos:** {total_abuse_count}\n"
            f"‚ùó **Error:** {escape_markdown(str(e))}\n"
            f"‚è∞ **Timestamp:** {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
            f"üîß **Acci√≥n requerida:** Revisar sistema y expulsar manualmente\n\n"
            f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
        )
        
        await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=error_notification,
            parse_mode="Markdown"
        )
        return False

def get_advanced_stats():
    """Obtiene estad√≠sticas avanzadas del bot."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                pendientes = c.fetchone()[0]
                c.execute("SELECT COUNT(*) FROM historial_solicitudes")
                gestionadas = c.fetchone()[0]
                c.execute("SELECT COUNT(*) FROM usuarios")
                usuarios = c.fetchone()[0]
                c.execute("SELECT estado, COUNT(*) as count FROM historial_solicitudes GROUP BY estado")
                estados_result = c.fetchall()
                estados = {"subido": 0, "denegado": 0, "eliminado": 0}
                for row in estados_result:
                    estado = row["estado"].lower()
                    if estado in estados:
                        estados[estado] = row["count"]
                c.execute("SELECT satisfaccion, COUNT(*) as count FROM encuestas_satisfaccion GROUP BY satisfaccion")
                encuestas = {}
                for row in c.fetchall():
                    encuestas[row["satisfaccion"]] = row["count"]
                
                total_gestionadas = sum(estados.values())
                approved_percent = (estados["subido"] / total_gestionadas * 100) if total_gestionadas > 0 else 0
                denied_percent = (estados["denegado"] / total_gestionadas * 100) if total_gestionadas > 0 else 0
                deleted_percent = (estados["eliminado"] / total_gestionadas * 100) if total_gestionadas > 0 else 0
                
                total_encuestas = sum(encuestas.values())
                satisfied = encuestas.get("excelente", 0) + encuestas.get("bueno", 0)
                satisfaction_rate = (satisfied / total_encuestas * 100) if total_encuestas > 0 else 0
                response_rate = (total_encuestas / total_gestionadas * 100) if total_gestionadas > 0 else 0
                
                return {
                    "pendientes": pendientes,
                    "gestionadas": gestionadas,
                    "usuarios": usuarios,
                    "estados": estados,
                    "encuestas": encuestas,
                    "approved_percent": approved_percent,
                    "denied_percent": denied_percent,
                    "deleted_percent": deleted_percent,
                    "satisfaction_rate": satisfaction_rate,
                    "response_rate": response_rate,
                    "satisfied": satisfied,
                    "unsatisfied": encuestas.get("regular", 0) + encuestas.get("malo", 0),
                    "avg_response_time": "2.3 horas",
                    "last_update": datetime.now(SPAIN_TZ).strftime("%H:%M:%S")
                }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener estad√≠sticas avanzadas: {str(e)}")
        return {
            "pendientes": 0, "gestionadas": 0, "usuarios": 0,
            "estados": {"subido": 0, "denegado": 0, "eliminado": 0},
            "encuestas": {}, "approved_percent": 0, "denied_percent": 0,
            "deleted_percent": 0, "satisfaction_rate": 0, "response_rate": 0,
            "satisfied": 0, "unsatisfied": 0, "avg_response_time": "N/A",
            "last_update": datetime.now(SPAIN_TZ).strftime("%H:%M:%S")
        }

async def save_encuesta_satisfaccion(ticket_number, user_id, chat_id, satisfaccion, context):
    """Guarda una encuesta de satisfacci√≥n y elimina el recordatorio si existe."""
    try:
        # Obtener info del recordatorio antes de marcar como completada
        reminder_info = get_reminder_message_info(ticket_number)

        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("INSERT INTO encuestas_satisfaccion (ticket_number, user_id, chat_id, satisfaccion, timestamp) "
                          "VALUES (%s, %s, %s, %s, %s)",
                          (ticket_number, user_id, chat_id, satisfaccion, datetime.now(SPAIN_TZ)))

                # Marcar la encuesta como completada en pending_surveys
                c.execute("UPDATE pending_surveys SET completed = TRUE WHERE ticket_number = %s", (ticket_number,))

                conn.commit()
                logger.info(f"‚úÖ Encuesta guardada: ticket={ticket_number}, user_id={user_id}, satisfaccion={satisfaccion}")

        # Otorgar puntos por completar encuesta (Sistema de gamificaci√≥n)
        if SISTEMA_PUNTOS_DISPONIBLE:
            try:
                # Obtener username
                peticion = get_peticion_registrada(ticket_number)
                if not peticion:
                    with get_db_connection() as conn:
                        with conn.cursor() as c:
                            c.execute("SELECT username FROM historial_solicitudes WHERE ticket_number = %s", (ticket_number,))
                            result = c.fetchone()
                            username = result["username"] if result else "Usuario"
                else:
                    username = peticion["username"]

                # Otorgar 10 puntos por completar encuesta
                puntos = 10
                descripcion = f"Encuesta completada para ticket #{ticket_number}: {satisfaccion}"
                otorgar_puntos(user_id, username, puntos, "encuesta_completada", descripcion)
                logger.info(f"üí∞ +{puntos} puntos para @{username} (encuesta completada)")

            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error otorgando puntos por encuesta: {str(e)}")

        # Eliminar mensaje de recordatorio si existe
        if reminder_info and context:
            deleted = await safe_bot_method(
                context.bot.delete_message,
                chat_id=reminder_info['chat_id'],
                message_id=reminder_info['message_id']
            )
            if deleted:
                logger.info(f"üóëÔ∏è Recordatorio eliminado autom√°ticamente para ticket #{ticket_number}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar encuesta para ticket_number={ticket_number}: {str(e)}")

def save_pending_survey(ticket_number, user_id, username, chat_id, message_text, chat_title):
    """Registra una encuesta pendiente cuando se aprueba una solicitud."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO pending_surveys
                    (ticket_number, user_id, username, chat_id, message_text, chat_title, created_at, reminder_sent, completed)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, FALSE, FALSE)
                    ON CONFLICT (ticket_number) DO NOTHING
                """, (ticket_number, user_id, username, chat_id, message_text, chat_title, datetime.now(SPAIN_TZ)))
                conn.commit()
                logger.info(f"‚úÖ Encuesta pendiente registrada: ticket={ticket_number}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar encuesta pendiente: {str(e)}")

def get_surveys_needing_reminder():
    """Obtiene encuestas que necesitan recordatorio (2 d√≠as despu√©s de aprobaci√≥n)."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT ticket_number, user_id, username, chat_id, message_text, chat_title
                    FROM pending_surveys
                    WHERE completed = FALSE
                    AND reminder_sent = FALSE
                    AND created_at <= NOW() - INTERVAL '2 days'
                """)
                return c.fetchall()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo encuestas para recordatorio: {str(e)}")
        return []

def mark_reminder_sent(ticket_number, message_id=None, chat_id=None):
    """Marca que se envi√≥ el recordatorio para una encuesta y guarda el message_id."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                if message_id and chat_id:
                    c.execute("""
                        UPDATE pending_surveys
                        SET reminder_sent = TRUE, reminder_message_id = %s, reminder_chat_id = %s
                        WHERE ticket_number = %s
                    """, (message_id, chat_id, ticket_number))
                else:
                    c.execute("UPDATE pending_surveys SET reminder_sent = TRUE WHERE ticket_number = %s", (ticket_number,))
                conn.commit()
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error marcando recordatorio enviado: {str(e)}")

def get_reminder_message_info(ticket_number):
    """Obtiene informaci√≥n del mensaje de recordatorio."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT reminder_message_id, reminder_chat_id
                    FROM pending_surveys
                    WHERE ticket_number = %s AND reminder_message_id IS NOT NULL
                """, (ticket_number,))
                result = c.fetchone()
                if result:
                    return {"message_id": result['reminder_message_id'], "chat_id": result['reminder_chat_id']}
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo info de recordatorio: {str(e)}")
        return None

def get_backup_group_attempts(user_id):
    """Obtiene los intentos de acceso al grupo de respaldo de un usuario."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    SELECT attempt_count, last_attempt, last_message_id, username
                    FROM backup_group_attempts 
                    WHERE user_id = %s
                """, (user_id,))
                result = c.fetchone()
                return dict(result) if result else None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener intentos de grupo de respaldo para user_id={user_id}: {str(e)}")
        return None

def update_backup_group_attempts(user_id, username, message_id=None):
    """Actualiza los intentos de acceso al grupo de respaldo."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO backup_group_attempts (user_id, username, attempt_count, last_attempt, last_message_id)
                    VALUES (%s, %s, 1, %s, %s)
                    ON CONFLICT (user_id) DO UPDATE SET
                    username = EXCLUDED.username,
                    attempt_count = backup_group_attempts.attempt_count + 1,
                    last_attempt = EXCLUDED.last_attempt,
                    last_message_id = EXCLUDED.last_message_id
                    RETURNING attempt_count
                """, (user_id, username, datetime.now(SPAIN_TZ), message_id))
                
                result = c.fetchone()
                attempt_count = result[0] if result else 1
                conn.commit()
                return attempt_count
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al actualizar intentos de grupo de respaldo para user_id={user_id}: {str(e)}")
        return 1

def reset_backup_group_attempts(user_id):
    """Resetea los intentos de acceso al grupo de respaldo cuando el usuario se une."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM backup_group_attempts WHERE user_id = %s", (user_id,))
                conn.commit()
        logger.info(f"‚úÖ Intentos de grupo de respaldo reseteados para user_id={user_id}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al resetear intentos de grupo de respaldo para user_id={user_id}: {str(e)}")

def get_bot_schedule():
    """Obtiene el horario configurado del bot."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT days_of_week, start_hour, end_hour FROM bot_schedule ORDER BY id DESC LIMIT 1")
                result = c.fetchone()
                if result:
                    return {
                        "days_of_week": json.loads(result["days_of_week"]),
                        "start_hour": result["start_hour"],
                        "end_hour": result["end_hour"]
                    }
                return None
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener horario: {str(e)}")
        return None

def set_bot_schedule(days_of_week, start_hour, end_hour):
    """Guarda un nuevo horario para el bot."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("INSERT INTO bot_schedule (days_of_week, start_hour, end_hour) VALUES (%s, %s, %s)",
                          (json.dumps(days_of_week), start_hour, end_hour))
                conn.commit()
        
        logger.info(f"‚úÖ Horario guardado: d√≠as={days_of_week}, inicio={start_hour}, fin={end_hour}")
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al guardar horario: {str(e)}")
        raise

def is_within_schedule():
    """Verifica si la solicitud est√° dentro del horario permitido."""
    schedule = get_bot_schedule()
    if not schedule or not schedule.get("days_of_week") or schedule.get("start_hour") is None or schedule.get("end_hour") is None:
        logger.warning("‚ö†Ô∏è Horario no configurado, permitiendo solicitudes por defecto.")
        return True
    now = datetime.now(SPAIN_TZ)
    current_day = now.strftime("%A")
    day_mapping = {
        "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
        "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
    }
    current_day_spanish = day_mapping.get(current_day, current_day)
    if current_day_spanish not in schedule["days_of_week"]:
        return False
    current_hour = now.hour
    start_hour = schedule["start_hour"]
    end_hour = schedule["end_hour"]
    if start_hour <= end_hour:
        return start_hour <= current_hour < end_hour
    else:
        return current_hour >= start_hour or current_hour < end_hour

def update_grupos_estados(chat_id, title=None):
    """Actualiza el estado de un grupo."""
    if str(chat_id) == GROUP_DESTINO:
        return
    grupos = get_grupos_estados()
    if chat_id not in grupos:
        set_grupo_estado(chat_id, title if title else f"Grupo {chat_id}")
    elif title and grupos[chat_id]["title"] != title:
        set_grupo_estado(chat_id, title)

def get_spain_time():
    """Obtiene la hora actual en Espa√±a."""
    return datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")

def validate_telegram_link(link):
    """Valida un enlace de Telegram."""
    telegram_link_pattern = r'^https?://t\.me/(?:c/[^/]+/\d+(?:/\d+)?|[\w-]+/\d+|joinchat/[\w-]+|@[a-zA-Z0-9_]+)$'
    return bool(re.match(telegram_link_pattern, link))

# ============================================
# SISTEMA DE ANIMACIONES Y MENSAJES DE CARGA
# ============================================

async def show_loading_animation(query, message_text: str, animation_type: str = "dots") -> None:
    """
    Muestra una animaci√≥n de carga profesional en el mensaje.

    Args:
        query: CallbackQuery de Telegram
        message_text: Texto base del mensaje
        animation_type: Tipo de animaci√≥n ('dots', 'spinner', 'bars', 'pulse')
    """
    animations = {
        "dots": ["‚ö™", "‚ö™‚ö™", "‚ö™‚ö™‚ö™", "‚ö™‚ö™‚ö™‚ö™"],
        "spinner": ["‚óê", "‚óì", "‚óë", "‚óí"],
        "bars": ["‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ±‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞"],
        "pulse": ["üí´", "‚ú®", "‚≠ê", "üåü", "‚≠ê", "‚ú®"],
        "loading": ["üîÑ", "üîÉ", "üîÑ", "üîÉ"],
        "search": ["üîç", "üîé", "üîç", "üîé"],
        "process": ["‚è≥", "‚åõ", "‚è≥", "‚åõ"]
    }

    frames = animations.get(animation_type, animations["dots"])

    for frame in frames:
        try:
            await query.edit_message_text(
                text=f"{message_text}\n\n{frame} Procesando...",
                parse_mode="Markdown"
            )
            await asyncio.sleep(0.3)
        except Exception as e:
            logger.debug(f"Animaci√≥n interrumpida: {str(e)}")
            break

async def show_typing_indicator(context, chat_id: int, duration: float = 2.0) -> None:
    """
    Muestra el indicador de 'escribiendo...' en el chat.

    Args:
        context: Context de Telegram
        chat_id: ID del chat
        duration: Duraci√≥n en segundos
    """
    try:
        await context.bot.send_chat_action(chat_id=chat_id, action="typing")
        await asyncio.sleep(min(duration, 5.0))  # M√°ximo 5 segundos
    except Exception as e:
        logger.debug(f"Error mostrando indicador de escritura: {str(e)}")

async def send_progress_message(query, total_steps: int, current_step: int, step_description: str) -> None:
    """
    Env√≠a un mensaje de progreso con barra visual.

    Args:
        query: CallbackQuery de Telegram
        total_steps: Total de pasos
        current_step: Paso actual
        step_description: Descripci√≥n del paso actual
    """
    percentage = int((current_step / total_steps) * 100)
    filled_blocks = int((current_step / total_steps) * 10)
    empty_blocks = 10 - filled_blocks

    progress_bar = "‚ñ∞" * filled_blocks + "‚ñ±" * empty_blocks

    message = (
        f"‚öôÔ∏è *Procesando operaci√≥n*\n\n"
        f"{progress_bar} {percentage}%\n\n"
        f"üìù {step_description}\n"
        f"‚è±Ô∏è Paso {current_step}/{total_steps}"
    )

    try:
        await query.edit_message_text(
            text=message,
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.debug(f"Error actualizando progreso: {str(e)}")

async def show_success_animation(query, success_message: str, auto_close_delay: int = 3) -> None:
    """
    Muestra una animaci√≥n de √©xito y luego el mensaje final.

    Args:
        query: CallbackQuery de Telegram
        success_message: Mensaje de √©xito
        auto_close_delay: Segundos antes de cerrar (0 = no auto-cerrar)
    """
    success_frames = ["‚úì", "‚úì‚úì", "‚úì‚úì‚úì", "‚úÖ"]

    for frame in success_frames:
        try:
            await query.edit_message_text(
                text=f"{frame} Completado...",
                parse_mode="Markdown"
            )
            await asyncio.sleep(0.2)
        except Exception:
            break

    await asyncio.sleep(0.5)

    try:
        await query.edit_message_text(
            text=success_message,
            parse_mode="Markdown"
        )
    except Exception as e:
        logger.error(f"Error mostrando mensaje de √©xito: {str(e)}")

def create_professional_menu_header(title: str, subtitle: str = "", emoji: str = "üéõÔ∏è") -> str:
    """
    Crea un encabezado profesional para men√∫s.

    Args:
        title: T√≠tulo del men√∫
        subtitle: Subt√≠tulo opcional
        emoji: Emoji principal

    Returns:
        str: Encabezado formateado
    """
    divider = "‚îÅ" * 30
    header = f"{divider}\n{emoji} *{title}* {emoji}\n{divider}"

    if subtitle:
        header += f"\n\nüí° _{subtitle}_"

    return header + "\n\n"

def create_info_box(title: str, items: dict) -> str:
    """
    Crea una caja de informaci√≥n con formato profesional.

    Args:
        title: T√≠tulo de la caja
        items: Diccionario con items a mostrar {emoji+label: valor}

    Returns:
        str: Caja de informaci√≥n formateada
    """
    box = f"‚îå‚îÄ üìä *{title}* ‚îÄ‚îê\n‚îÇ\n"

    for label, value in items.items():
        box += f"‚îÇ {label} {value}\n"

    box += "‚îÇ\n‚îî" + "‚îÄ" * 25 + "‚îò"

    return box

def format_stats_message(stats: dict) -> str:
    """
    Formatea estad√≠sticas de manera profesional.

    Args:
        stats: Diccionario con estad√≠sticas

    Returns:
        str: Mensaje formateado
    """
    header = create_professional_menu_header("üìà Estad√≠sticas del Sistema", "Panel de control avanzado")

    stats_text = header

    if "pendientes" in stats:
        stats_text += f"üìã *Solicitudes Pendientes:* `{stats['pendientes']}`\n"

    if "aprobadas" in stats:
        stats_text += f"‚úÖ *Solicitudes Aprobadas:* `{stats['aprobadas']}`\n"

    if "denegadas" in stats:
        stats_text += f"‚ùå *Solicitudes Denegadas:* `{stats['denegadas']}`\n"

    if "usuarios_activos" in stats:
        stats_text += f"üë• *Usuarios Activos:* `{stats['usuarios_activos']}`\n"

    if "total_puntos" in stats:
        stats_text += f"üí∞ *Puntos Totales:* `{stats['total_puntos']:,}`\n"

    stats_text += f"\nüïê *Actualizado:* {get_spain_time()}"

    return stats_text
    
async def close_inactive_menus():
    """Cierra men√∫s inactivos despu√©s de 15 minutos."""
    while True:
        current_time = datetime.now(SPAIN_TZ)
        inactive_menus = []
        for key, menu_data in list(menu_activos.items()):
            chat_id, message_id = key
            last_activity = menu_data["last_activity"]
            if (current_time - last_activity).total_seconds() >= 900:
                inactive_menus.append((chat_id, message_id))
                await safe_bot_method(
                    application.bot.delete_message,
                    chat_id=chat_id,
                    message_id=message_id
                )
        for chat_id, message_id in inactive_menus:
            if (chat_id, message_id) in menu_activos:
                del menu_activos[(chat_id, message_id)]
        await asyncio.sleep(60)

async def close_user_messages(context: ContextTypes.DEFAULT_TYPE, chat_id: int, message_ids: list):
    """Elimina mensajes del usuario despu√©s de un tiempo."""
    for message_id in message_ids:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message_id
        )

async def auto_delete_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int, message_id: int, delay: int = 10):
    """Auto-elimina un mensaje despu√©s del tiempo especificado."""
    await asyncio.sleep(delay)
    try:
        await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
    except Exception:
        pass

def can_respond_to_survey(user_id, ticket_number):
    """Verifica si un usuario puede responder a una encuesta."""
    try:
        if user_id in ADMINISTRATORS:
            return True
            
        historial = get_historial_solicitud(ticket_number)
        if historial and str(historial.get("user_id")) == str(user_id):
            return True
            
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT COUNT(*) FROM encuestas_satisfaccion WHERE ticket_number = %s AND user_id = %s",
                          (ticket_number, user_id))
                count = c.fetchone()[0]
                if count > 0:
                    return False
        
        return False
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al verificar permisos de encuesta: {str(e)}")
        return False

def can_use_request_buttons(user_id, ticket_number, button_type):
    """Verifica si un usuario puede usar botones espec√≠ficos de una solicitud."""
    try:
        if user_id in ADMINISTRATORS:
            return True
        
        if button_type == "vote":
            return True
        
        if button_type == "owner_only":
            peticion = get_peticion_registrada(ticket_number)
            if peticion and str(peticion.get("user_id")) == str(user_id):
                return True
            
            historial = get_historial_solicitud(ticket_number)
            if historial and str(historial.get("user_id")) == str(user_id):
                return True
            
            return False
        
        if button_type == "admin_only":
            return False
        
        return False
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al verificar permisos de bot√≥n: {str(e)}")
        return False

async def handle_cancelar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /cancelar para que los usuarios cancelen sus propias solicitudes."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_cancelar")
        return
    
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = f"@{message.from_user.username}" if message.from_user.username else "Usuario sin @"
    
    if chat_id not in CANALES_PETICIONES:
        logger.debug(f"‚ö†Ô∏è Comando /cancelar ignorado: chat_id={chat_id} no est√° en CANALES_PETICIONES")
        return
    
    canal_info = CANALES_PETICIONES[chat_id]
    thread_id = message.message_thread_id
    
    if thread_id != canal_info["thread_id"]:
        logger.debug(f"‚ö†Ô∏è Comando /cancelar ignorado: thread_id={thread_id} no coincide con {canal_info['thread_id']}")
        return
    
    args = context.args
    if not args or not args[0].isdigit():
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=(
                f"‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\n"
                f"Formato: /cancelar [n√∫mero de ticket]\n"
                f"Ejemplo: /cancelar 934"
            ),
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 60)
            )
        return
    
    ticket_number = int(args[0])
    
    peticion = get_peticion_registrada(ticket_number)
    if not peticion:
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=f"‚ùå *Error* ‚ùå\nLa solicitud #{ticket_number} no existe o ya fue procesada.",
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 60)
            )
        return
    
    # Verificaci√≥n de permisos
    if peticion["user_id"] != user_id and user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=f"‚ùå *Sin permisos* ‚ùå\nSolo puedes cancelar tus propias solicitudes.",
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 60)
            )
        return
    
    # === Datos de origen de la petici√≥n (grupo/canal y topic correcto) ===
    origin_chat_id = peticion.get("chat_id") or canal_info["chat_id"]
    origin_thread_id = peticion.get("thread_id")  # puede ser None si no es foro
    origin_message_id = peticion.get("message_id")

    # Eliminar de pendientes y mover a historial como "cancelado"
    del_peticion_registrada(ticket_number)
    
    gestion_dt = datetime.now(SPAIN_TZ)
    await set_historial_solicitud(ticket_number, {
        "chat_id": origin_chat_id,
        "username": peticion["username"],
        "user_id": peticion["user_id"],
        "message_text": peticion["message_text"],
        "chat_title": peticion["chat_title"],
        "estado": "cancelado",
        "fecha_gestion": gestion_dt,
        "admin_username": username if user_id == peticion["user_id"] else "Administrador",
        "reason": "Cancelado por el usuario" if user_id == peticion["user_id"] else "Cancelado por administrador",
        "has_attachment": peticion["has_attachment"],
        "photo_file_id": peticion["photo_file_id"]
    })
    
    # Ajustar contador de solicitudes del usuario si √©l mismo cancel√≥
    if user_id == peticion["user_id"]:
        user_data = get_peticiones_por_usuario(user_id)
        if user_data and user_data["count"] > 0:
            new_count = user_data["count"] - 1
            set_peticiones_por_usuario(user_id, new_count, user_data["chat_id"], user_data["username"], user_data["last_reset"])
    
    # Borrar el mensaje original de la solicitud (en el chat/foro de origen)
    if origin_message_id:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=origin_chat_id,
            message_id=origin_message_id
        )
    
    # Borrar posible foto asociada (si la guardaste con esa clave)
    photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
    if photo_message_id:
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=origin_chat_id,
            message_id=photo_message_id
        )
        del context.bot_data[f"photo_{ticket_number}"]
    
    # Eliminar mensaje de confirmaci√≥n cuando se cancela
    await delete_confirmation_message(context, ticket_number)
    
    # Confirmaci√≥n en el grupo/canal/tema donde se origin√≥ la petici√≥n
    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
    message_text_escaped = escape_markdown(peticion["message_text"])
    confirmation_text = (
        f"‚úÖ *Solicitud #{ticket_number} cancelada exitosamente*\n"
        f"üë§ *Usuario:* {username_escaped}\n"
        f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
        f"‚è∞ *Fecha:* {gestion_dt.strftime('%d/%m/%Y %H:%M:%S')}\n"
        f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
        f"{'üîÑ Solicitud cancelada exitosamente.' if user_id == peticion['user_id'] else 'üëÆ Solicitud cancelada por administrador.'}"
    )

    send_kwargs = dict(
        chat_id=origin_chat_id,
        text=confirmation_text,
        parse_mode="Markdown",
    )
    if origin_thread_id:
        send_kwargs["message_thread_id"] = origin_thread_id

    confirmation_message = await safe_bot_method(
        context.bot.send_message,
        **send_kwargs
    )
    
    if confirmation_message:
        # Borra la confirmaci√≥n en el origen tras 5 minutos
        context.application.create_task(
            auto_delete_message(context, origin_chat_id, confirmation_message.message_id, 300)
        )
    
    logger.info(f"‚úÖ Solicitud #{ticket_number} cancelada por user_id={user_id} en chat_id={origin_chat_id}, thread_id={origin_thread_id}")
    
async def handle_new_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja cuando un nuevo miembro se une al grupo de respaldo."""
    if not update.message or not update.message.new_chat_members:
        return

    chat_id = update.message.chat_id

    # Verificar que es el grupo de respaldo
    if chat_id != GROUP_RESPALDO:
        return

    for new_member in update.message.new_chat_members:
        # Ignorar bots
        if new_member.is_bot:
            continue

        user_id = new_member.id
        username = f"@{new_member.username}" if new_member.username else f"Usuario {user_id}"
        full_name = new_member.full_name or username

        # Resetear intentos de grupo de respaldo
        attempts_data = get_backup_group_attempts(user_id)
        if attempts_data:
            reset_backup_group_attempts(user_id)
            logger.info(f"‚úÖ Usuario {user_id} se uni√≥ al grupo de respaldo, intentos reseteados")

        # Buscar en qu√© grupos/canales el usuario hab√≠a intentado hacer solicitudes
        user_requests = []
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Buscar solicitudes previas del usuario
                    c.execute("""
                        SELECT DISTINCT chat_id, chat_title
                        FROM peticiones_registradas
                        WHERE user_id = %s
                        ORDER BY timestamp DESC
                        LIMIT 5
                    """, (user_id,))
                    user_requests = c.fetchall()
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error buscando solicitudes del usuario {user_id}: {str(e)}")

        # Enviar mensaje de bienvenida en el grupo de respaldo sin bot√≥n de confirmaci√≥n
        welcome_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_RESPALDO,
            text=(
                f"‚úÖ **SOLICITUD APROBADA - GRUPO DE RESPALDO** ‚úÖ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ **Usuario:** {escape_markdown(full_name)}\n"
                f"üÜî **ID:** {username}\n"
                f"üìÖ **Fecha de aprobaci√≥n:** {get_spain_time()}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"‚úÖ **Acceso concedido exitosamente**\n\n"
                f"Su solicitud de uni√≥n al Grupo de Respaldo EntresHijos ha sido **aprobada satisfactoriamente**.\n\n"
                f"üìã **Servicios disponibles:**\n"
                f"‚Ä¢ Env√≠o de solicitudes en canales autorizados\n"
                f"‚Ä¢ Participaci√≥n activa en la comunidad\n"
                f"‚Ä¢ Acceso completo a todos los servicios del grupo\n\n"
                f"üìù **Instrucciones para realizar una solicitud:**\n"
                f"1. Dir√≠jase al canal correspondiente\n"
                f"2. Utilice el comando `/solicito` seguido de su petici√≥n\n"
                f"3. Redacte su solicitud de forma clara y espec√≠fica\n\n"
                f"‚ö†Ô∏è **Importante:**\n"
                f"‚Ä¢ Las solicitudes deben realizarse dentro del horario establecido\n"
                f"‚Ä¢ Mantenga un lenguaje respetuoso y apropiado\n"
                f"‚Ä¢ Evite solicitudes duplicadas o spam\n"
                f"‚Ä¢ El incumplimiento de normas puede resultar en penalizaciones autom√°ticas\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                f"‚è∞ *Este mensaje se auto-eliminar√° en 10 minutos*"
            ),
            parse_mode="Markdown"
        )

        if welcome_message:
            # Programar auto-eliminaci√≥n del mensaje de bienvenida en 10 minutos (600 segundos)
            context.application.create_task(
                auto_delete_message(context, GROUP_RESPALDO, welcome_message.message_id, 600)
            )
            logger.info(f"‚úÖ Mensaje de bienvenida enviado a {username} en grupo de respaldo (auto-eliminaci√≥n: 10 min)")

        # Enviar notificaci√≥n al usuario en los canales donde intent√≥ hacer solicitudes
        if user_requests:
            for request in user_requests:
                target_chat_id = request['chat_id']
                chat_title = request['chat_title']

                # Buscar thread_id si existe
                thread_id = None
                canal_info = CANALES_PETICIONES.get(target_chat_id)
                if canal_info:
                    thread_id = canal_info.get('thread_id')

                notification_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=target_chat_id,
                    message_thread_id=thread_id,
                    text=(
                        f"üéä **¬°Excelente Noticia!** üéä\n\n"
                        f"üë§ {username} {escape_markdown(full_name)}\n\n"
                        f"‚úÖ **Tu solicitud de uni√≥n al grupo de respaldo ha sido aprobada**\n\n"
                        f"üîÑ **Ahora puedes realizar tu solicitud nuevamente**\n\n"
                        f"üìã **Proceso:**\n"
                        f"‚Ä¢ Usa el comando de solicitud (ej: `/solicito`)\n"
                        f"‚Ä¢ Completa tu petici√≥n normalmente\n"
                        f"‚Ä¢ Ser√° procesada por nuestro equipo\n\n"
                        f"üí´ **¬°Gracias por tu paciencia!**\n\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                        f"‚è∞ *Este mensaje se auto-eliminar√° en 3 minutos*"
                    ),
                    parse_mode="Markdown"
                )

                if notification_message:
                    context.application.create_task(
                        auto_delete_message(context, target_chat_id, notification_message.message_id, 180)
                    )
                    logger.info(f"‚úÖ Notificaci√≥n enviada a {username} en chat_id={target_chat_id}")
        else:
            # Si no hay solicitudes previas, enviar mensaje gen√©rico a los canales principales
            for canal_id, canal_info in CANALES_PETICIONES.items():
                notification_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=canal_id,
                    message_thread_id=canal_info.get('thread_id'),
                    text=(
                        f"üéä **¬°Nueva Aprobaci√≥n!** üéä\n\n"
                        f"üë§ {username} {escape_markdown(full_name)}\n\n"
                        f"‚úÖ **Ha sido aprobado/a en el grupo de respaldo**\n\n"
                        f"üîÑ **Ahora puede realizar solicitudes libremente**\n\n"
                        f"üìã **Para hacer una solicitud:**\n"
                        f"Usa el comando correspondiente (ej: `/solicito`)\n\n"
                        f"‚ö†Ô∏è **Recuerde:**\n"
                        f"Las peticiones deben realizarse *de forma correcta* y *dentro del horario establecido* üïí.\n"
                        f"El incumplimiento de estas normas puede generar **penalizaciones autom√°ticas por parte del bot.** üö´\n\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                        f"‚è∞ *Este mensaje se auto-eliminar√° en 3 minutos*"
                    ),
                    parse_mode="Markdown"
                )

                if notification_message:
                    context.application.create_task(
                        auto_delete_message(context, canal_id, notification_message.message_id, 180)
                    )

        logger.info(f"‚úÖ Usuario {user_id} ({username}) se uni√≥ al grupo de respaldo - notificaciones enviadas")

# FUNCI√ìN DESACTIVADA: Ya no se usa bot√≥n de confirmaci√≥n en grupo de respaldo
# El mensaje se auto-elimina autom√°ticamente despu√©s de 10 minutos
# async def handle_backup_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
#     """Maneja la confirmaci√≥n del bot√≥n en el mensaje de bienvenida al grupo de respaldo."""
#     pass

async def handle_request(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """FUNCI√ìN PRINCIPAL: Maneja solicitudes de usuarios y respuestas de administradores."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_request")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = f"@{message.from_user.username}" if message.from_user.username else f"Usuario {user_id}"
    chat_title = message.chat.title or "Chat privado"

    # Log para debugging
    logger.info(f"üîç handle_request llamado: user_id={user_id}, chat_id={chat_id}, text={bool(message.text)}, photo={bool(message.photo)}, video={bool(message.video)}, animation={bool(message.animation)}, doc={bool(message.document)}")

    # Verificar si el usuario est√° bloqueado (solo en privado y no admins)
    if chat_id > 0 and user_id not in ADMINISTRATORS and CONTACT_SYSTEM_AVAILABLE:
        try:
            conn = get_db_connection()
            if is_user_blocked(conn, user_id):
                release_db_connection(conn)
                logger.warning(f"üö´ Usuario bloqueado intent√≥ interactuar: user_id={user_id}")
                return  # Silenciosamente ignorar mensajes de usuarios bloqueados
            release_db_connection(conn)
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error verificando bloqueo en handle_request: {str(e)}")

    # Verificar si el usuario est√° en un estado de espera (sugerencias o contacto admin)
    if user_id in user_menu_states and chat_id > 0:  # Solo en chat privado
        state_data = user_menu_states[user_id]
        state = state_data.get("state")

        if state == "waiting_suggestion" and message.text:
            # Usuario est√° enviando una sugerencia
            suggestion_text = message.text.strip()

            if len(suggestion_text) < 10:
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text="‚ö†Ô∏è Tu sugerencia es muy corta. Por favor, s√© m√°s espec√≠fico (m√≠nimo 10 caracteres)."
                )
                return

            # Guardar sugerencia y mostrar confirmaci√≥n
            pending_suggestions[user_id] = {
                "text": suggestion_text,
                "type": "suggestion"
            }

            divider = "‚îÅ" * 32
            preview = suggestion_text if len(suggestion_text) <= 500 else suggestion_text[:500] + "..."
            mensaje = (
                f"{divider}\n"
                f"üí° *CONFIRMAR SUGERENCIA* üí°\n"
                f"{divider}\n\n"
                f"üìù *Tu sugerencia:*\n{preview}\n\n"
                f"{divider}\n\n"
                f"‚ùì *¬øTodo correcto?*"
            )

            keyboard = [
                [InlineKeyboardButton("‚úÖ Enviar", callback_data=f"confirm_suggestion_{user_id}"),
                 InlineKeyboardButton("‚úèÔ∏è Corregir", callback_data=f"edit_suggestion_{user_id}")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            logger.info(f"‚úÖ Sugerencia recibida de user_id={user_id}, esperando confirmaci√≥n")
            return

        elif state == "waiting_contact_admin" and message.text:
            # Usuario est√° enviando un mensaje al admin
            contact_text = message.text.strip()

            if len(contact_text) < 10:
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text="‚ö†Ô∏è Tu mensaje es muy corto. Por favor, s√© m√°s espec√≠fico (m√≠nimo 10 caracteres)."
                )
                return

            # Guardar mensaje y mostrar confirmaci√≥n
            pending_suggestions[user_id] = {
                "text": contact_text,
                "type": "contact_admin"
            }

            divider = "‚îÅ" * 32
            preview = contact_text if len(contact_text) <= 500 else contact_text[:500] + "..."
            mensaje = (
                f"{divider}\n"
                f"üë®‚Äçüíº *CONFIRMAR MENSAJE* üë®‚Äçüíº\n"
                f"{divider}\n\n"
                f"üí¨ *Tu mensaje:*\n{preview}\n\n"
                f"{divider}\n\n"
                f"‚ùì *¬øTodo correcto?*"
            )

            keyboard = [
                [InlineKeyboardButton("‚úÖ Enviar", callback_data=f"confirm_contact_admin_{user_id}"),
                 InlineKeyboardButton("‚úèÔ∏è Corregir", callback_data=f"edit_contact_admin_{user_id}")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            logger.info(f"‚úÖ Mensaje para admin recibido de user_id={user_id}, esperando confirmaci√≥n")
            return

    if await handle_admin_response(update, context):
        logger.info(f"‚úÖ Respuesta de administrador procesada para user_id={user_id}")
        return

    search_key = f"{user_id}_{chat_id}"
    if search_key in pending_searches:
        return await handle_user_search(update, context)

    message_text = message.text or (message.caption if message.caption else "")
    thread_id = message.message_thread_id

    is_valid_request = False
    matched_command = None
    request_text = message_text

    # IMPORTANTE: Solo procesar comandos de solicitud (#solicito, /solicito, #peticion, etc) en grupos configurados
    # Los chats privados NO deben procesar estos comandos como solicitudes
    for cmd in VALID_REQUEST_COMMANDS:
        pattern = rf'(?i)(^|\s){re.escape(cmd)}(\s|$)'
        match = re.search(pattern, message_text)
        if match:
            is_valid_request = True
            matched_command = match.group(0).strip()
            start_pos = match.start() + len(matched_command)
            request_text = message_text[start_pos:].strip() if start_pos < len(message_text) else ""
            break

    if not is_valid_request:
        if user_id in ADMINISTRATORS:
            return

        keywords = ["solicito", "peticion", "solicitud", "pendiente"]
        if any(word in message_text.lower() for word in keywords):
            if chat_id not in CANALES_PETICIONES:
                logger.debug(f"‚ö†Ô∏è Solicitud incorrecta ignorada: chat_id={chat_id} no est√° en CANALES_PETICIONES")
                return

            canal_info = CANALES_PETICIONES[chat_id]
            if thread_id != canal_info["thread_id"]:
                logger.debug(f"‚ö†Ô∏è Solicitud incorrecta ignorada: thread_id={thread_id} no coincide con {canal_info['thread_id']}")
                return

            # Verificar si el usuario ya est√° bloqueado por peticiones incorrectas
            if is_user_blocked_for_incorrect_requests(user_id):
                username_escaped = escape_markdown(username, preserve_username=True)
                current_attempts = get_user_incorrect_attempts_today(user_id)
                
                blocked_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text=(
                        f"üö´ *L√≠mite de Intentos Superado* üö´\n\n"
                        f"Hola {username_escaped}, has superado el l√≠mite de **{MAX_INCORRECT_ATTEMPTS} intentos incorrectos** por d√≠a. üòî\n\n"
                        f"üìä **Intentos realizados hoy:** {current_attempts}/{MAX_INCORRECT_ATTEMPTS}\n"
                        f"‚è∞ **Estado:** Bloqueado temporalmente\n\n"
                        f"üïí **¬øCu√°ndo puedo volver a intentar?**\n"
                        f"Podr√°s hacer nuevas solicitudes **ma√±ana a las 00:00** cuando se reinicie el contador diario. ‚è∞\n\n"
                        f"üí° **Consejos para evitar errores:**\n"
                        f"‚Ä¢ Usa */solicito* o *#peticion* seguido de tu mensaje\n"
                        f"‚Ä¢ Revisa el formato antes de enviar\n"
                        f"‚Ä¢ Consulta */ayuda* para m√°s informaci√≥n\n\n"
                        f"üôè Gracias por tu comprensi√≥n y paciencia.\n\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                        f"‚è∞ *Este mensaje se auto-eliminar√° en 10 minutos*"
                    ),
                    message_thread_id=canal_info["thread_id"],
                    parse_mode="Markdown"
                )
                
                if blocked_message:
                    context.application.create_task(
                        auto_delete_message(context, chat_id, blocked_message.message_id, 600)  # 10 minutos
                    )
                
                logger.info(f"üö´ Usuario {user_id} bloqueado por {current_attempts} peticiones incorrectas hoy")
                return

            timestamp = datetime.now(SPAIN_TZ)
            attempt_count = add_peticion_incorrecta(user_id, timestamp, chat_id)
            username_escaped = escape_markdown(username, preserve_username=True)
            
            # Verificar si con este intento alcanza el l√≠mite
            if attempt_count >= MAX_INCORRECT_ATTEMPTS:
                # Eliminar mensaje de penalizaci√≥n anterior
                last_message_id = get_last_penalty_message(user_id, chat_id, "peticion_incorrecta")
                if last_message_id:
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=chat_id,
                        message_id=last_message_id
                    )

                # Usuario alcanz√≥ el l√≠mite, enviar mensaje de bloqueo
                blocked_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text=(
                        f"üö´ *L√≠mite de Intentos Alcanzado* üö´\n\n"
                        f"Hola {username_escaped}, has alcanzado el l√≠mite de **{MAX_INCORRECT_ATTEMPTS} intentos incorrectos** por d√≠a. üòî\n\n"
                        f"üìä **Intentos realizados hoy:** {attempt_count}/{MAX_INCORRECT_ATTEMPTS}\n"
                        f"‚è∞ **Estado:** Bloqueado hasta ma√±ana\n\n"
                        f"üïí **¬øCu√°ndo puedo volver a intentar?**\n"
                        f"Podr√°s hacer nuevas solicitudes **ma√±ana a las 00:00** cuando se reinicie el contador diario. ‚è∞\n\n"
                        f"üí° **Consejos para evitar errores:**\n"
                        f"‚Ä¢ Usa */solicito* o *#peticion* seguido de tu mensaje\n"
                        f"‚Ä¢ Revisa el formato antes de enviar\n"
                        f"‚Ä¢ Consulta */ayuda* para m√°s informaci√≥n\n\n"
                        f"üôè Gracias por tu comprensi√≥n y paciencia.\n\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                        f"‚è∞ *Este mensaje se auto-eliminar√° en 10 minutos*"
                    ),
                    message_thread_id=canal_info["thread_id"],
                    parse_mode="Markdown"
                )

                if blocked_message:
                    save_penalty_message(user_id, chat_id, blocked_message.message_id, "peticion_incorrecta")
                    context.application.create_task(
                        auto_delete_message(context, chat_id, blocked_message.message_id, 600)  # 10 minutos
                    )
                
                # Notificar a administradores sobre el bloqueo
                grupo_title = GRUPOS_PREDEFINIDOS.get(chat_id, f"Grupo {chat_id}")
                fecha_hora = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")
                
                admin_notification = (
                    f"üö´ *Usuario Bloqueado por Peticiones Incorrectas* üö´\n\n"
                    f"üë§ **Usuario:** {username_escaped}\n"
                    f"üÜî **ID:** {user_id}\n"
                    f"üìä **Intentos incorrectos hoy:** {attempt_count}\n"
                    f"üìç **Grupo:** {escape_markdown(grupo_title)}\n"
                    f"‚è∞ **Fecha y hora:** {fecha_hora}\n\n"
                    f"‚öñÔ∏è **Acci√≥n:** Bloqueado hasta ma√±ana (00:00)\n"
                    f"üîÑ **Reinicio:** Autom√°tico al cambiar el d√≠a\n"
                    f"üìù **L√≠mite:** {MAX_INCORRECT_ATTEMPTS} intentos incorrectos por d√≠a\n\n"
                    f"üí° **Sugerencia:** El usuario puede consultar /ayuda para aprender el formato correcto\n\n"
                    f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
                )
                
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=GROUP_DESTINO,
                    text=admin_notification,
                    parse_mode="Markdown"
                )
                
                logger.info(f"üö´ Usuario {user_id} bloqueado por {attempt_count} peticiones incorrectas")
            else:
                # Eliminar mensaje de penalizaci√≥n anterior
                last_message_id = get_last_penalty_message(user_id, chat_id, "peticion_incorrecta")
                if last_message_id:
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=chat_id,
                        message_id=last_message_id
                    )

                # Usuario a√∫n no alcanza el l√≠mite, enviar mensaje de advertencia normal
                error_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text=(
                        f"‚ö†Ô∏è *Formato incorrecto* ‚ö†Ô∏è\n"
                        f"{username_escaped}, tu solicitud no cumple con el formato requerido _(Intento {attempt_count}/{MAX_INCORRECT_ATTEMPTS})_. üìù\n\n"
                        f"üí° **Formato correcto:**\n"
                        f"‚Ä¢ Usa */solicito* o *#peticion* seguido de tu mensaje\n"
                        f"‚Ä¢ Ejemplo: */solicito Pel√≠cula XYZ a√±o 2024*\n\n"
                        f"‚ö†Ô∏è **Aviso importante:** Si superas los **{MAX_INCORRECT_ATTEMPTS} intentos incorrectos**, se restringir√° tu acceso para realizar peticiones hasta el d√≠a siguiente. Por favor, lee atentamente las **normas de peticiones** para hacerlo correctamente. üòä\n\n"
                        f"üìñ Consulta */ayuda* para m√°s detalles sobre el formato correcto.\n\n"
                        f"ü§ù *Equipo de Administradores EntresHijos* üôå"
                    ),
                    message_thread_id=canal_info["thread_id"],
                    parse_mode="Markdown"
                )
                if error_message:
                    save_penalty_message(user_id, chat_id, error_message.message_id, "peticion_incorrecta")
                    context.application.create_task(
                        auto_delete_message(context, chat_id, error_message.message_id, 900)
                    )
        return

    if chat_id not in CANALES_PETICIONES:
        logger.debug(f"‚ö†Ô∏è Solicitud ignorada: chat_id={chat_id} no est√° en CANALES_PETICIONES")
        return

    canal_info = CANALES_PETICIONES[chat_id]
    if thread_id != canal_info["thread_id"]:
        logger.warning(f"‚ö†Ô∏è Solicitud ignorada: thread_id={thread_id} no coincide con {canal_info['thread_id']} para chat_id={chat_id}")
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=(
                f"‚ö†Ô∏è *Canal incorrecto* ‚ö†Ô∏è\n"
                f"Por favor, env√≠a tu solicitud en el canal correcto de peticiones.\n"
                f"Thread esperado: {canal_info['thread_id']}, thread actual: {thread_id}"
            ),
            message_thread_id=thread_id,
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 60)
            )
        return

    # Verificaci√≥n del grupo de respaldo SOLO para peticiones v√°lidas
    if user_id not in ADMINISTRATORS:
        username = f"@{message.from_user.username}" if message.from_user.username else f"Usuario {user_id}"
        
        try:
            member = await context.bot.get_chat_member(GROUP_RESPALDO, user_id)
            if member.status not in ['member', 'administrator', 'creator']:
                raise BadRequest("User not participant")
            else:
                # Usuario est√° en el grupo, resetear intentos si los ten√≠a
                attempts_data = get_backup_group_attempts(user_id)
                if attempts_data:
                    reset_backup_group_attempts(user_id)
                    logger.info(f"‚úÖ Usuario {user_id} verificado en grupo de respaldo, intentos reseteados")
        except BadRequest as e:
            if "user not found" in str(e).lower() or "not participant" in str(e).lower():
                # Obtener intentos previos
                attempts_data = get_backup_group_attempts(user_id)
                
                # Eliminar mensaje anterior si existe
                if attempts_data and attempts_data.get("last_message_id"):
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=chat_id,
                        message_id=attempts_data["last_message_id"]
                    )
                
                # Verificar si ha excedido el l√≠mite de intentos
                current_attempts = attempts_data["attempt_count"] if attempts_data else 0
                
                if current_attempts >= MAX_BACKUP_GROUP_ATTEMPTS:
                    # Usuario ha excedido el l√≠mite, mensaje de paciencia
                    patience_message = await safe_bot_method(
                        message.reply_text,
                        text=(
                            f"üòä ¬°Hola {username}! üëã\n\n"
                            f"Vemos que has intentado hacer solicitudes varias veces. Te pedimos un poco de **paciencia** üôè\n\n"
                            f"üìã **Tu solicitud de uni√≥n al grupo de respaldo est√° en cola de aprobaci√≥n** y ser√° gestionada lo m√°s r√°pido posible por nuestro equipo.\n\n"
                            f"‚ö†Ô∏è **Importante:** Evita saturar el grupo con m√∫ltiples intentos, ya que esto puede resultar en penalizaciones autom√°ticas del sistema.\n\n"
                            f"üïí **Tiempo estimado de aprobaci√≥n:** 1-24 horas\n"
                            f"üì± **Una vez aprobado:** Podr√°s hacer tus solicitudes normalmente\n\n"
                            f"Gracias por tu comprensi√≥n y paciencia. üíô\n\n"
                            f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                            f"‚è∞ *Este mensaje se auto-eliminar√° en 5 minutos*"
                        ),
                        parse_mode="Markdown"
                    )
                    
                    if patience_message:
                        # Actualizar el registro con el nuevo mensaje
                        update_backup_group_attempts(user_id, username, patience_message.message_id)
                        
                        context.application.create_task(
                            auto_delete_message(context, chat_id, patience_message.message_id, 300)  # 5 minutos
                        )
                        
                        # Notificar a administradores sobre usuario insistente
                        admin_alert = (
                        f"‚ö†Ô∏è *Usuario Insistente Detectado* ‚ö†Ô∏è\n\n"
                        f"üë§ **Usuario:** {escape_markdown(username, preserve_username=True)}\n"
                        f"üÜî **ID:** {user_id}\n"
                        f"üìä **Intentos:** {current_attempts + 1}\n"
                        f"üìç **Grupo:** {escape_markdown(chat_title)}\n"
                        f"‚è∞ **Fecha:** {get_spain_time()}\n\n"
                        f"üîî **Acci√≥n:** Mensaje de paciencia enviado\n"
                        f"üìù **Sugerencia:** Revisar y aprobar solicitud de uni√≥n al grupo de respaldo si es v√°lida\n"
                        f"üîó **Enlace del grupo:** {RESPALDO_LINK}\n"
                        f"‚öôÔ∏è **Configuraci√≥n:** El enlace tiene aprobaci√≥n manual habilitada\n\n"
                        f"*Sistema Autom√°tico EntresHijos* ü§ñ"
                    )
                        
                        await safe_bot_method(
                            context.bot.send_message,
                            chat_id=GROUP_DESTINO,
                            text=admin_alert,
                            parse_mode="Markdown"
                        )
                    
                    logger.info(f"‚ö†Ô∏è Usuario {user_id} excedi√≥ l√≠mite de intentos ({current_attempts + 1}), mensaje de paciencia enviado")
                    return
                
                # Usuario dentro del l√≠mite, enviar mensaje de invitaci√≥n
                join_message = await safe_bot_method(
                    message.reply_text,
                    text=(
                        f"üòä ¬°Hola {username}! üëã\n\n"
                        f"Para hacer peticiones, necesitas unirte a nuestro **grupo de respaldo** üîÜ\n\n"
                        f"üìã **¬øPor qu√© es necesario?**\n"
                        f"Es un requisito importante para mantener todo organizado, respaldado y asegurar la continuidad del servicio.\n\n"
                        f"üîó **Proceso de uni√≥n:**\n"
                        f"1Ô∏è‚É£ Haz clic en el bot√≥n de abajo\n"
                        f"2Ô∏è‚É£ Solicita unirse al grupo\n"
                        f"3Ô∏è‚É£ **Espera la aprobaci√≥n** (requiere aprobaci√≥n manual)\n"
                        f"4Ô∏è‚É£ Una vez aprobado, podr√°s hacer solicitudes\n\n"
                        f"‚è≥ **Tiempo de aprobaci√≥n:** Ser√° gestionado lo m√°s r√°pido posible por nuestro equipo\n"
                        f"üìä **Intento:** {current_attempts + 1}/{MAX_BACKUP_GROUP_ATTEMPTS}\n\n"
                        f"¬°Gracias por tu comprensi√≥n y paciencia! üöÄ\n\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                        f"‚è∞ *Este mensaje se auto-eliminar√° en 5 minutos*"
                    ),
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîó Unirse al Grupo de Respaldo", url=RESPALDO_LINK)]
                    ])
                )
                
                if join_message:
                    # Actualizar el registro con el nuevo mensaje
                    update_backup_group_attempts(user_id, username, join_message.message_id)
                    
                    context.application.create_task(
                        auto_delete_message(context, chat_id, join_message.message_id, 300)  # 5 minutos
                    )
                
                logger.info(f"‚ö†Ô∏è Usuario {user_id} no est√° en grupo de respaldo, mensaje de invitaci√≥n enviado (intento {current_attempts + 1})")
                return
            else:
                logger.error(f"‚ö†Ô∏è Error inesperado en get_chat_member: {str(e)}")
                await safe_bot_method(
                    application.bot.send_message,
                    chat_id=DEVELOPER_CHAT_ID,
                    text=(
                        f"üö® *Error en Verificaci√≥n de Grupo de Respaldo* üö®\n\n"
                        f"üë§ *Usuario:* {escape_markdown(username, preserve_username=True)}\n"
                        f"üÜî *User ID:* {user_id}\n"
                        f"üìç *Chat ID:* {chat_id}\n"
                        f"‚ùó *Error:* {escape_markdown(str(e))}\n"
                        f"‚è∞ *Timestamp:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                        f"*Sistema de Monitoreo EntresHijos* ü§ñ"
                    ),
                    parse_mode="Markdown"
                )
                return
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error verificando membres√≠a en respaldo: {str(e)}")
            await safe_bot_method(
                application.bot.send_message,
                chat_id=DEVELOPER_CHAT_ID,
                text=(
                    f"üö® *Error Cr√≠tico en Verificaci√≥n de Respaldo* üö®\n\n"
                    f"üë§ *Usuario:* {escape_markdown(username, preserve_username=True)}\n"
                    f"üÜî *User ID:* {user_id}\n"
                    f"üìç *Chat ID:* {chat_id}\n"
                    f"‚ùó *Error:* {escape_markdown(str(e))}\n"
                    f"‚è∞ *Timestamp:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                    f"*Sistema de Monitoreo EntresHijos* ü§ñ"
                ),
                parse_mode="Markdown"
            )
            return
    has_attachment = bool(message.photo)
    photo_file_id = message.photo[-1].file_id if has_attachment else None

    if not message_text and not has_attachment:
        logger.debug(f"‚ö†Ô∏è Mensaje vac√≠o sin imagen recibido en chat_id={chat_id}")
        return

    if has_attachment and not message_text:
        message_text = "[Imagen adjunta sin descripci√≥n]"
        request_text = message_text
        logger.info(f"üì∏ Detectada imagen sin texto, usando descripci√≥n por defecto para user_id={user_id}")

    if is_maintenance_active():
        maintenance = get_maintenance_mode()
        maintenance_msg = maintenance.get("message",
            "‚ö†Ô∏è El bot est√° en mantenimiento hasta pr√≥ximo aviso. "
            "Intenta de nuevo m√°s tarde. *Equipo de Administraci√≥n EntresHijos*, "
            "disculpen las molestias, estaremos de vuelta lo antes posible."
        )
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=maintenance_msg,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 900)
            )
        return

    if message.chat.type == "private":
        # PROTECCI√ìN: No procesar comandos de solicitud (#solicito, #peticion, /solicito, etc) en chat privado
        # Los usuarios deben usar el men√∫ interactivo (/start) para enviar mensajes a los administradores
        logger.info(f"‚ö†Ô∏è Comando de solicitud '{matched_command}' detectado en chat privado de user_id={user_id}, bloqueando")
        error_message = await safe_bot_method(
            message.reply_text,
            text=(
                "‚ÑπÔ∏è *Canal no permitido* ‚ÑπÔ∏è\n\n"
                "Este bot solo acepta solicitudes en los canales espec√≠ficos de los grupos configurados.\n\n"
                "üí° *Para contactar con administraci√≥n:*\n"
                "Usa el comando /start y selecciona la opci√≥n *'Contactar Admin'* del men√∫.\n\n"
                "üìñ Consulta /ayuda para m√°s informaci√≥n."
            ),
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    if message.video or message.document or message.animation:
        error_message = await safe_bot_method(
            message.reply_text,
            text=(
                f"‚ö†Ô∏è *Formato no permitido* ‚ö†Ô∏è\n"
                f"{escape_markdown(username, preserve_username=True)}, las solicitudes deben ser *texto* o *texto con una imagen*. "
                f"Consulta /ayuda para m√°s detalles."
            ),
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    # Verificar horario solo para usuarios normales (administradores pueden hacer peticiones siempre)
    if user_id not in ADMINISTRATORS and not is_within_schedule():
        # Obtener advertencias actuales del usuario
        warnings = get_user_schedule_warnings(user_id, chat_id)

        # Si el usuario ya est√° silenciado, no hacer nada (el silencio ya est√° activo)
        if warnings["is_muted"]:
            logger.info(f"üîá Usuario {user_id} ya est√° silenciado hasta {warnings['unmute_at']}")
            return

        # Si es la primera advertencia
        if warnings["warning_count"] == 0:
            # Enviar primera advertencia
            warning_msg_id = await send_schedule_warning(
                context, user_id, chat_id, thread_id, username, 1, None
            )

            # Incrementar contador de advertencias
            increment_schedule_warning(user_id, chat_id, warning_msg_id)

            logger.info(f"‚ö†Ô∏è Primera advertencia enviada a {username} por petici√≥n fuera de horario")
            return

        # Si ya tuvo una advertencia (segunda petici√≥n fuera de horario)
        elif warnings["warning_count"] >= 1:
            # Eliminar mensaje de primera advertencia si existe
            if warnings["last_warning_message_id"]:
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=canal_info["chat_id"],
                    message_id=warnings["last_warning_message_id"]
                )

            # Silenciar al usuario por 24 horas
            await mute_user_for_schedule_violation(context, user_id, chat_id, username)

            # Enviar mensaje de silenciamiento (reemplaza la primera advertencia)
            await send_schedule_warning(
                context, user_id, chat_id, thread_id, username, 2, None
            )

            # Notificar a administradores
            await notify_admins_schedule_mute(context, user_id, chat_id, username)

            logger.info(f"üîá Usuario {username} silenciado por 24h por segunda petici√≥n fuera de horario")
            return

    update_grupos_estados(chat_id, chat_title)
    grupos_estados = get_grupos_estados()
    if not grupos_estados.get(chat_id, {}).get("activo", True):
        username_escaped = escape_markdown(username, preserve_username=True)
        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=(
                f"‚õî *Solicitudes desactivadas* ‚õî\n"
                f"{username_escaped}, las solicitudes est√°n temporalmente desactivadas en este grupo. "
                f"Contacta a un administrador con @admin."
            ),
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 900)
            )
        return

    if not can_make_request(user_id):
        username_escaped = escape_markdown(username, preserve_username=True)
        user_data = get_peticiones_por_usuario(user_id)
        current_count = user_data["count"] if user_data else 0

        # Calcular l√≠mite actual del usuario
        extra_requests = get_user_extra_requests(user_id)
        penalty = get_user_weekly_penalty(user_id)
        user_limit = MAX_REQUESTS_PER_USER + extra_requests - penalty

        # Mensaje personalizado seg√∫n el estado del usuario
        status_message = ""
        if extra_requests > 0:
            status_message = f"\nüéä *¬°Tienes una recompensa activa!* +{extra_requests} petici√≥n extra esta semana\n"
        elif penalty > 0:
            status_message = f"\n‚ö†Ô∏è *Tienes una penalizaci√≥n activa:* -{penalty} petici√≥n esta semana\n"

        error_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=(
                f"‚ö†Ô∏è *L√≠mite de solicitudes alcanzado* ‚ö†Ô∏è\n"
                f"Hola {username_escaped}, has alcanzado tu l√≠mite diario de solicitudes. üìù\n"
                f"{status_message}\n"
                f"üïí *Podr√°s enviar nuevas solicitudes ma√±ana a las 00:00*\n"
                f"‚è∞ *Hora actual:* {get_spain_time()}\n\n"
                f"üìä *Tus solicitudes hoy:* {current_count}/{user_limit} ‚úÖ\n"
                f"üí° *Consejo:* Puedes revisar el estado de tus solicitudes pendientes.\n\n"
                f"üèÜ *¬øQuieres m√°s peticiones?* Usa correctamente las normas y podr√≠as ser premiado el pr√≥ximo viernes.\n\n"
                f"Gracias por tu comprensi√≥n. *Equipo EntresHijos* ü§ù"
            ),
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], error_message.message_id, 900)
            )
        return

    # VERIFICACI√ìN OBLIGATORIA DE DUPLICADOS - ANTES DE PROCESAR
    if user_id not in ADMINISTRATORS:
        logger.info(f"üîç Verificando duplicados para user_id={user_id}, texto: '{request_text[:50]}...'")
        duplicates = check_for_duplicates(user_id, request_text, chat_id)
        logger.info(f"üîç Duplicados encontrados: {len(duplicates)} para user_id={user_id}")
        
        if duplicates:
            logger.warning(f"‚ö†Ô∏è DUPLICADO DETECTADO - Rechazando solicitud de user_id={user_id}")
            
            # Obtener el duplicado m√°s similar
            best_match = duplicates[0]
            similarity_percent = int(best_match["similarity"] * 100)
            
            # Determinar estado del duplicado
            estado_emoji = {
                "pendiente": "‚è≥ Pendiente",
                "subido": "‚úÖ Aprobada", 
                "denegado": "‚ùå Denegada",
                "eliminado": "üóëÔ∏è Eliminada",
                "cancelado": "üîÑ Cancelada"
            }.get(best_match["estado"].lower(), "üìã Procesada")
            
            # Formatear fecha del duplicado
            duplicate_date = best_match["timestamp"].strftime("%d/%m/%Y %H:%M")
            
            # Crear mensaje amigable y profesional
            username_escaped = escape_markdown(username, preserve_username=True)
            duplicate_text_preview = best_match["message_text"][:80] + "..." if len(best_match["message_text"]) > 80 else best_match["message_text"]
            duplicate_text_escaped = escape_markdown(duplicate_text_preview)
            
            duplicate_warning = await safe_bot_method(
                context.bot.send_message,
                chat_id=canal_info["chat_id"],
                text=(
                    f"üîç *Solicitud Similar Detectada* üîç\n\n"
                    f"Hola {username_escaped}, hemos detectado que ya tienes una solicitud muy similar:\n\n"
                    f"üìã **Tu solicitud similar anterior:**\n"
                    f"üéüÔ∏è *Ticket:* #{best_match['ticket_number']}\n"
                    f"üìù *Contenido:* {duplicate_text_escaped}\n"
                    f"üìä *Estado:* {estado_emoji}\n"
                    f"üìç *Grupo:* {escape_markdown(best_match['chat_title'])}\n"
                    f"üìÖ *Fecha:* {duplicate_date}\n"
                    f"üéØ *Similitud:* {similarity_percent}%\n\n"
                    f"üí° **¬øQu√© puedes hacer?**\n"
                    f"‚Ä¢ Si es la misma solicitud, espera a que se procese\n"
                    f"‚Ä¢ Si es diferente, modifica tu mensaje para que sea m√°s espec√≠fico\n"
                    f"‚Ä¢ Puedes consultar el estado de tus solicitudes existentes\n\n"
                    f"ü§ù *Esto nos ayuda a mantener el sistema organizado y eficiente.*\n\n"
                    f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è\n\n"
                    f"‚è∞ *Este mensaje se auto-eliminar√° en 2 minutos*"
                ),
                message_thread_id=canal_info["thread_id"],
                parse_mode="Markdown"
            )
            
            if duplicate_warning:
                context.application.create_task(
                    auto_delete_message(context, canal_info["chat_id"], duplicate_warning.message_id, 120)  # 2 minutos
                )
            
            logger.info(f"üö´ Solicitud rechazada por duplicado - user_id={user_id}, similitud={similarity_percent}%")
            return  # SALIR SIN PROCESAR LA SOLICITUD
        else:
            logger.info(f"‚úÖ No se encontraron duplicados para user_id={user_id}, continuando...")
    user_data = get_peticiones_por_usuario(user_id)
    if user_data is None:
        set_peticiones_por_usuario(user_id, 0, chat_id, username)
        user_data = {"count": 0, "chat_id": chat_id, "username": username, "last_reset": datetime.now(SPAIN_TZ)}

    ticket_number = increment_ticket_counter()
    logger.info(f"üé´ Nuevo ticket generado: #{ticket_number} para user_id={user_id}")

    # Crear usuario en sistema de puntos si no existe
    if SISTEMA_PUNTOS_DISPONIBLE:
        crear_usuario_puntos(user_id, username)

    # VERIFICACI√ìN OBLIGATORIA DE DUPLICADOS ANTES DE PROCESAR
    timestamp = datetime.now(SPAIN_TZ)
    new_count = user_data["count"] + 1
    set_peticiones_por_usuario(user_id, new_count, chat_id, username, user_data["last_reset"])

    timestamp_str = get_spain_time()
    set_peticion_registrada(ticket_number, {
        "chat_id": chat_id,
        "username": username,
        "user_id": user_id,
        "message_text": request_text,
        "message_id": None,
        "timestamp": timestamp,
        "chat_title": chat_title,
        "thread_id": thread_id,
        "has_attachment": has_attachment,
        "photo_file_id": photo_file_id
    })

    username_escaped = escape_markdown(username, preserve_username=True)
    chat_title_escaped = escape_markdown(chat_title)
    message_text_escaped = escape_markdown(request_text)
    destino_message = (
        f"üì© *Nueva solicitud recibida* ‚úÖ\n"
        f"üë§ *Usuario:* {username_escaped} (ID: {user_id})\n"
        f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
        f"üìä *Petici√≥n:* {new_count}/2\n"
        f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
        f"üìç *Grupo:* {chat_title_escaped}\n"
        f"‚è∞ *Fecha:* {timestamp_str}\n"
        f"üìé *Adjunto:* {'S√≠' if has_attachment else 'No'}\n"
        f"ü§ù *Bot de Entreshijos*"
    )

    sent_message = await safe_bot_method(
        context.bot.send_message,
        chat_id=GROUP_DESTINO,
        text=destino_message,
        parse_mode="Markdown"
    )

    if sent_message:
        set_peticion_registrada(ticket_number, {
            "chat_id": chat_id,
            "username": username,
            "user_id": user_id,
            "message_text": request_text,
            "message_id": sent_message.message_id,
            "timestamp": timestamp,
            "chat_title": chat_title,
            "thread_id": thread_id,
            "has_attachment": has_attachment,
            "photo_file_id": photo_file_id
        })
        logger.info(f"‚úÖ Mensaje enviado al grupo admin con ID: {sent_message.message_id}")

    if has_attachment:
        photo_message = await safe_bot_method(
            context.bot.send_photo,
            chat_id=GROUP_DESTINO,
            photo=photo_file_id,
            caption=f"üì∏ *Imagen adjunta para solicitud #{ticket_number}*",
            parse_mode="Markdown"
        )
        if photo_message:
            context.bot_data[f"photo_{ticket_number}"] = photo_message.message_id
            logger.info(f"üì∏ Imagen enviada para ticket #{ticket_number}")

    logger.info(f"üìù Preparando mensaje de confirmaci√≥n para ticket #{ticket_number}")
    votes = get_votes_summary(ticket_number)
    vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else "\nüó≥Ô∏è *Votos:* +0 / -0"

    try:
        bot_info = await context.bot.get_me()
        bot_username = bot_info.username
        logger.info(f"ü§ñ Bot username obtenido: @{bot_username}")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error obteniendo info del bot: {str(e)}")
        bot_username = "EntresHijosBot"

    confirmacion_message = generar_mensaje_confirmacion_solicitud(
        username_escaped, ticket_number, user_id, chat_title_escaped,
        timestamp_str, message_text_escaped, has_attachment,
        new_count, vote_text, bot_username, username
    )

    keyboard = generar_teclado_confirmacion_solicitud(ticket_number, user_id)
    reply_markup = InlineKeyboardMarkup(keyboard)

    logger.info(f"üì§ Enviando confirmaci√≥n a chat_id={canal_info['chat_id']}, thread_id={canal_info['thread_id']}")
    try:
        try:
            bot_member = await context.bot.get_chat_member(chat_id=canal_info["chat_id"], user_id=context.bot.id)
            can_post = bot_member.can_post_messages or bot_member.status in ['administrator', 'creator']
            logger.info(f"üîê Permisos del bot - can_post: {can_post}, status: {bot_member.status}")
            if not can_post:
                logger.error(f"‚ùå El bot NO tiene permisos para enviar mensajes en chat_id={canal_info['chat_id']}")
        except Exception as perm_error:
            logger.warning(f"‚ö†Ô∏è No se pudieron verificar permisos: {str(perm_error)}")

        confirmacion_sent = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=confirmacion_message,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown",
            reply_markup=reply_markup
        )

        if confirmacion_sent:
            # Guardar mensaje de confirmaci√≥n para eliminarlo cuando se gestione
            save_confirmation_message(ticket_number, canal_info["chat_id"], confirmacion_sent.message_id, user_id)
            context.bot_data[f"confirmacion_{ticket_number}"] = confirmacion_sent.message_id
            logger.info(f"‚úÖ √âXITO: Confirmaci√≥n enviada con ID {confirmacion_sent.message_id} para ticket #{ticket_number}")
        else:
            logger.warning(f"‚ö†Ô∏è Fallo en env√≠o principal, intentando fallback sin thread_id")
            fallback_sent = await safe_bot_method(
                context.bot.send_message,
                chat_id=canal_info["chat_id"],
                text=confirmacion_message,
                parse_mode="Markdown",
                reply_markup=reply_markup
            )

            if fallback_sent:
                save_confirmation_message(ticket_number, canal_info["chat_id"], fallback_sent.message_id, user_id)
                context.bot_data[f"confirmacion_{ticket_number}"] = fallback_sent.message_id
                logger.info(f"‚úÖ FALLBACK 1 EXITOSO: Confirmaci√≥n enviada sin thread_id con ID {fallback_sent.message_id}")
            else:
                logger.warning(f"‚ö†Ô∏è Fallo en fallback 1, intentando fallback 2 sin botones")
                simple_message = (
                    f"‚úÖ *Solicitud #{ticket_number} registrada* ‚úÖ\n"
                    f"Hola {username_escaped}, tu solicitud ha sido recibida y ser√° procesada pronto.\n"
                    f"‚è∞ *Fecha:* {timestamp_str}\n"
                    f"üìä *Estado:* En proceso"
                )
                simple_sent = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=canal_info["chat_id"],
                    text=simple_message,
                    message_thread_id=canal_info["thread_id"],
                    parse_mode="Markdown"
                )

                if simple_sent:
                    save_confirmation_message(ticket_number, canal_info["chat_id"], simple_sent.message_id, user_id)
                    logger.info(f"‚úÖ FALLBACK 2 EXITOSO: Mensaje simple enviado con ID {simple_sent.message_id}")
                else:
                    logger.error(f"‚ùå TODOS LOS FALLBACKS FALLARON para ticket #{ticket_number}")
                    direct_message = (
                        f"‚úÖ *Solicitud #{ticket_number} registrada* ‚úÖ\n"
                        f"Tu solicitud ha sido recibida y ser√° procesada pronto.\n"
                        f"Usa /menu para consultar el estado."
                    )
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=user_id,
                        text=direct_message,
                        parse_mode="Markdown"
                    )
                    logger.info(f"üìû Mensaje directo enviado al usuario {user_id} como √∫ltimo recurso")

    except Exception as e:
        logger.error(f"‚ùå ERROR CR√çTICO al enviar confirmaci√≥n para ticket #{ticket_number}: {str(e)}")
        logger.error(f"üîç Datos del error: chat_id={canal_info['chat_id']}, thread_id={canal_info['thread_id']}, user_id={user_id}")

    logger.info(f"‚úÖ Solicitud completamente procesada: ticket #{ticket_number}, user_id={user_id}, has_attachment={has_attachment}")

async def update_menu_message(update: Update, context: ContextTypes.DEFAULT_TYPE, page: int, chat_id: int, message_id: int) -> None:
    """Actualiza el mensaje del men√∫ de solicitudes pendientes."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute(
                    "SELECT ticket_number, username, message_text, chat_title, has_attachment "
                    "FROM peticiones_registradas ORDER BY timestamp DESC LIMIT 5 OFFSET %s",
                    ((page - 1) * 5,)
                )
                solicitudes = c.fetchall()

        if not solicitudes:
            texto = "üìã *No hay solicitudes pendientes* üìã\n\nUsa /menu para otras opciones."
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        else:
            texto = f"üìã *Solicitudes Pendientes (P√°gina {page})* üìã\n\n"
            for i, solicitud in enumerate(solicitudes, 1):
                ticket_number = solicitud["ticket_number"]
                username_escaped = escape_markdown(solicitud["username"], preserve_username=True)
                message_text_escaped = escape_markdown(solicitud["message_text"][:50] + "..." if len(solicitud["message_text"]) > 50 else solicitud["message_text"])
                texto += (
                    f"**{i}. Ticket #{ticket_number}**\n"
                    f"üë§ *Usuario:* {username_escaped}\n"
                    f"üìù *Mensaje:* {message_text_escaped}\n"
                    f"üìç *Grupo:* {escape_markdown(solicitud['chat_title'])}\n"
                    f"üìé *Adjunto:* {'S√≠' if solicitud['has_attachment'] else 'No'}\n\n"
                )

            keyboard = []
            for solicitud in solicitudes:
                ticket_number = solicitud["ticket_number"]
                keyboard.append([
                    InlineKeyboardButton("‚úÖ Gestionar", callback_data=f"pend_{ticket_number}_{page}_gestionar"),
                    InlineKeyboardButton("üóëÔ∏è Eliminar", callback_data=f"pend_{ticket_number}_{page}_eliminar_with_reason")
                ])
            keyboard.append([
                InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"pend_page_{page-1}" if page > 1 else "no_action"),
                InlineKeyboardButton("‚û°Ô∏è Siguiente", callback_data=f"pend_page_{page+1}")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": update.callback_query.from_user.id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": page
        }

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al actualizar men√∫ de solicitudes: {str(e)}")
        await update.callback_query.answer("‚ùå Error al actualizar el men√∫.", show_alert=True)

async def handle_eliminar_solicitud_with_reason(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                               ticket_number: int, page: int, chat_id: int, message_id: int) -> None:
    """Maneja la eliminaci√≥n de una solicitud pidiendo motivo."""
    peticion = get_peticion_registrada(ticket_number)
    if not peticion:
        await update.callback_query.answer("‚ùå Solicitud no encontrada.", show_alert=True)
        return

    admin_id = update.callback_query.from_user.id
    
    set_admin_waiting_response(admin_id, chat_id, "deletion_reason", ticket_number, {
        "peticion": peticion,
        "page": page,
        "menu_message_id": message_id
    })
    
    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
    message_text_escaped = escape_markdown(peticion["message_text"])
    
    instruction_msg = await safe_bot_method(
        context.bot.send_message,
        chat_id=chat_id,
        text=(
            f"üóëÔ∏è *Eliminar Solicitud #{ticket_number}* üóëÔ∏è\n\n"
            f"üë§ *Usuario:* {username_escaped}\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n\n"
            f"üìù *Por favor, escribe el motivo de la eliminaci√≥n:*\n"
            f"(Ejemplo: Contenido inapropiado, Duplicado, etc.)"
        ),
        parse_mode="Markdown"
    )
    
    if instruction_msg:
        admin_waiting_responses[f"{admin_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
    
    logger.info(f"‚úÖ Solicitado motivo para eliminar ticket #{ticket_number} por admin {admin_id}")
                                                   
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /start con men√∫ interactivo profesional para usuarios."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_start")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = escape_markdown(f"@{message.from_user.username}", True) if message.from_user.username else "Usuario"
    username_raw = message.from_user.username or f"Usuario{user_id}"

    # Solo mostrar men√∫ completo en chat privado
    is_private = message.chat.type == "private"

    if is_private:
        # Verificar si el usuario est√° bloqueado
        if CONTACT_SYSTEM_AVAILABLE and user_id not in ADMINISTRATORS:
            try:
                conn = get_db_connection()
                if is_user_blocked(conn, user_id):
                    blocked_info = get_blocked_user_info(conn, user_id)
                    release_db_connection(conn)

                    divider = "‚îÅ" * 32
                    blocked_msg = (
                        f"{divider}\n"
                        f"üö´ *ACCESO BLOQUEADO* üö´\n"
                        f"{divider}\n\n"
                        f"Tu acceso al bot ha sido restringido.\n\n"
                        f"‚ö†Ô∏è *Raz√≥n:* {blocked_info['reason']}\n"
                        f"üìÖ *Fecha:* {blocked_info['blocked_at'].strftime('%d/%m/%Y ‚Äì %H:%M')}\n\n"
                        f"{divider}\n\n"
                        f"Si consideras que esto es un error, contacta al equipo de administraci√≥n."
                    )
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=chat_id,
                        text=blocked_msg,
                        parse_mode="Markdown"
                    )
                    logger.warning(f"üö´ Usuario bloqueado intent√≥ usar /start: user_id={user_id}")
                    return
                release_db_connection(conn)
            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error verificando bloqueo: {str(e)}")

        # Verificar membres√≠a si el sistema est√° disponible
        if CONTACT_SYSTEM_AVAILABLE and user_id not in ADMINISTRATORS:
            try:
                conn = get_db_connection()
                # Obtener lista de grupos requeridos (canales + grupos de solicitudes)
                required_groups = list(CANALES_PETICIONES.keys())
                membership_check = check_user_membership(conn, user_id, required_groups)
                release_db_connection(conn)

                if not membership_check["is_member"]:
                    # Usuario no es miembro, mostrar mensaje de restricci√≥n
                    non_member_msg = format_non_member_message()
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=chat_id,
                        text=non_member_msg,
                        parse_mode="Markdown"
                    )
                    logger.info(f"‚ö†Ô∏è Usuario no miembro intent√≥ usar /start: user_id={user_id}")
                    return
            except Exception as e:
                logger.error(f"‚ö†Ô∏è Error verificando membres√≠a: {str(e)}")
                # Continuar normalmente si hay error en verificaci√≥n
        divider = "‚îÅ" * 32
        welcome_message = (
            f"{divider}\n"
            f"üëã *¬°BIENVENIDO A ENTRESHIJOS!* üëã\n"
            f"{divider}\n\n"
            f"Hola {username}, üìö\n\n"
            f"‚úÖ *Tus notificaciones est√°n activadas*\n\n"
            f"üì¨ *Recibir√°s avisos cuando:*\n"
            f"   ‚Ä¢ Tu solicitud sea aprobada\n"
            f"   ‚Ä¢ Sea subida por el equipo\n"
            f"   ‚Ä¢ Cambie el estado de tu petici√≥n\n\n"
            f"{divider}\n\n"
            f"üí° *¬øQu√© puedes hacer aqu√≠?*\n\n"
            f"üìã Ver y gestionar tus solicitudes\n"
            f"üí∞ Consultar tus puntos y nivel\n"
            f"üéÅ Canjear recompensas\n"
            f"‚ö†Ô∏è Revisar tus sanciones (si las hay)\n"
            f"üìä Ver el ranking de usuarios\n"
            f"üïê Consultar horarios del bot\n\n"
            f"{divider}\n\n"
            f"üìå *IMPORTANTE:*\n"
            f"‚Ä¢ Lee los mensajes fijados en cada grupo\n"
            f"‚Ä¢ Respeta las normas de peticiones\n"
            f"‚Ä¢ M√°ximo 2 solicitudes por d√≠a\n\n"
            f"ü§ù Solo recibir√°s informaci√≥n relacionada con tus solicitudes.\n\n"
            f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *Equipo EntresHijos*"
        )

        # Crear botones de men√∫ para usuarios
        keyboard = [
            [InlineKeyboardButton("üìã Mis Solicitudes", callback_data="user_menu_solicitudes"),
             InlineKeyboardButton("üí∞ Mis Puntos", callback_data="user_menu_puntos")],
            [InlineKeyboardButton("üéÅ Canjear Recompensas", callback_data="user_menu_recompensas"),
             InlineKeyboardButton("‚ö†Ô∏è Mis Sanciones", callback_data="user_menu_sanciones")],
            [InlineKeyboardButton("üèÜ Ver Ranking", callback_data="user_menu_ranking"),
             InlineKeyboardButton("üïê Horario del Bot", callback_data="user_menu_horario")],
            [InlineKeyboardButton("üí° Enviar Sugerencia", callback_data="user_menu_sugerencia"),
             InlineKeyboardButton("üë®‚Äçüíº Contactar Admin", callback_data="user_menu_contactar_admin")],
            [InlineKeyboardButton("‚ùì Ayuda", callback_data="user_menu_ayuda")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=welcome_message,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        logger.info(f"‚úÖ Comando /start ejecutado en privado por user_id={user_id}")
    else:
        # En grupos, mensaje simple sin botones
        welcome_message = (
            f"üëã ¬°Hola {username}!\n\n"
            f"‚úÖ Para activar tus notificaciones privadas, escr√≠beme al privado:\n"
            f"üëâ @EntresHijosBot\n\n"
            f"üí° Desde el chat privado podr√°s gestionar tus solicitudes, ver tus puntos y mucho m√°s."
        )

        sent_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=welcome_message,
            parse_mode="Markdown"
        )

        if sent_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 120)
            )

        logger.info(f"‚úÖ Comando /start ejecutado en grupo por user_id={user_id}")

async def handle_ayuda(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /ayuda para usuarios - funciona en grupos y chat privado."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_ayuda")
        return

    message = update.message
    chat_id = message.chat_id
    thread_id = message.message_thread_id
    username = escape_markdown(f"@{message.from_user.username}", True) if message.from_user.username else "Usuario"
    is_private = chat_id > 0  # Chat privado si chat_id es positivo

    # Obtener username del bot
    try:
        bot_info = await context.bot.get_me()
        bot_username = bot_info.username
    except Exception:
        bot_username = "SolicitoEntresHijosBot"

    ayuda_message = (
        f"üåü **GU√çA DE USO DEL BOT** üåü\n\n"
        f"üëã ¬°Hola {username}! Bienvenido/a üòä\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üìã **C√≥mo enviar una solicitud:**\n"
        f"üó£Ô∏è ‚Ä¢ `/solicito [tu petici√≥n]`\n"
        f"üè∑Ô∏è ‚Ä¢ `#peticion [tu petici√≥n]`\n"
        f"üì∏ ‚Ä¢ Puedes adjuntar im√°genes si lo necesitas\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"‚öñÔ∏è **L√≠mites y normas:**\n"
        f"üîπ M√°x. 2 solicitudes por d√≠a\n"
        f"‚è∞ Respeta el horario establecido\n"
        f"üôå Respeta las peticiones ajenas\n"
        f"üìå Lee siempre los mensajes fijados del grupo\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üí∞ **Sistema de puntos:**\n"
        f"üèÖ Gana puntos por participar\n"
        f"üìà Sube de nivel y desbloquea ventajas exclusivas\n"
        f"üéÅ Canjea recompensas en la tienda\n"
        f"üìä Usa `/mispuntos` para ver tu progreso\n"
        f"üèÜ Usa `/ranking` para ver el top 10\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üì± **Comandos disponibles:**\n"
        f"‚Ä¢ `/start` - Activar notificaciones\n"
        f"‚Ä¢ `/ayuda` - Ver esta gu√≠a\n"
        f"‚Ä¢ `/mispuntos` - Ver tus puntos\n"
        f"‚Ä¢ `/missolicitudes` - Ver tus solicitudes\n"
        f"‚Ä¢ `/ranking` - Ver ranking de usuarios\n"
        f"‚Ä¢ `/recompensas` - Ver tienda de recompensas\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üîî **Notificaciones:**\n"
        f"‚úâÔ∏è Env√≠a `/start` a @{bot_username} en privado\n"
        f"üì¨ Recibe avisos autom√°ticos sobre tus solicitudes\n\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"‚ùì **¬øTienes dudas o problemas?**\n"
        f"üí¨ Contacta con un administrador\n\n"
        f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *Equipo EntresHijos*"
    )

    if is_private:
        # En chat privado, enviar directamente sin autoeliminaci√≥n
        await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=ayuda_message,
            parse_mode="Markdown"
        )
        logger.info(f"‚úÖ Comando /ayuda ejecutado en chat privado por user_id={message.from_user.id}")
    elif chat_id in CANALES_PETICIONES:
        # En grupos, verificar thread y autoeliminarse
        canal_info = CANALES_PETICIONES[chat_id]

        if thread_id != canal_info["thread_id"]:
            logger.debug(f"‚ö†Ô∏è Comando /ayuda ignorado: thread_id={thread_id} no coincide")
            return

        # Eliminar comando del usuario
        context.application.create_task(
            auto_delete_message(context, chat_id, message.message_id, 120)
        )

        ayuda_sent = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=ayuda_message,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )

        # Autoeliminar respuesta despu√©s de 2 minutos
        if ayuda_sent:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], ayuda_sent.message_id, 120)
            )

        logger.info(f"‚úÖ Comando /ayuda ejecutado en grupo chat_id={chat_id}")
    else:
        logger.debug(f"‚ö†Ô∏è Comando /ayuda ignorado: chat_id={chat_id} no permitido")

async def handle_mispuntos(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Comando /mispuntos - Muestra los puntos y nivel del usuario con opciones de canje."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_mispuntos")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = f"@{message.from_user.username}" if message.from_user.username else f"Usuario {user_id}"
    is_private = message.chat.type == "private"

    # Eliminar el comando del usuario despu√©s de 2 minutos
    if chat_id in CANALES_PETICIONES or chat_id == GROUP_DESTINO:
        context.application.create_task(
            auto_delete_message(context, chat_id, message.message_id, 120)
        )

    try:
        puntos_info = obtener_puntos_usuario(user_id)

        if not puntos_info:
            # Usuario nuevo, crearlo
            crear_usuario_puntos(user_id, username)
            puntos_info = obtener_puntos_usuario(user_id)

        nivel_config = NIVELES.get(puntos_info["nivel"], NIVELES["bronce"])
        nivel_emoji = nivel_config["emoji"]

        # Calcular progreso al siguiente nivel
        next_level = None
        progress_percent = 0
        puntos_para_siguiente = 0

        niveles_ordenados = ["bronce", "plata", "oro", "diamante", "leyenda"]
        nivel_actual_index = niveles_ordenados.index(puntos_info["nivel"])

        if nivel_actual_index < len(niveles_ordenados) - 1:
            next_level = niveles_ordenados[nivel_actual_index + 1]
            next_config = NIVELES[next_level]
            puntos_para_siguiente = next_config["min_puntos"] - puntos_info["puntos"]
            progress_percent = ((puntos_info["puntos"] - nivel_config["min_puntos"]) /
                              (next_config["min_puntos"] - nivel_config["min_puntos"])) * 100

        username_escaped = escape_markdown(username, preserve_username=True)

        divider = "‚îÅ" * 32
        mensaje = (
            f"{divider}\n"
            f"üí∞ *TUS PUNTOS Y ESTAD√çSTICAS* üí∞\n"
            f"{divider}\n\n"
            f"üë§ *Usuario:* {username_escaped}\n"
            f"üÜî *ID:* `{user_id}`\n\n"
            f"{divider}\n\n"
            f"üéØ *NIVEL ACTUAL*\n"
            f"{nivel_emoji} *{puntos_info['nivel'].upper()}* ‚Ä¢ {puntos_info['puntos']:,} pts\n"
        )

        if next_level:
            next_emoji = NIVELES[next_level]["emoji"]
            barra_progreso = "‚ñà" * int(progress_percent / 10) + "‚ñë" * (10 - int(progress_percent / 10))
            mensaje += (
                f"\nüìä *PROGRESO*\n"
                f"{next_emoji} {next_level.upper()}\n"
                f"[{barra_progreso}] {progress_percent:.1f}%\n"
                f"‚¨ÜÔ∏è Faltan *{puntos_para_siguiente:,} pts*\n"
            )
        else:
            mensaje += f"\nüëë *¬°Nivel m√°ximo alcanzado!*\n"

        mensaje += (
            f"\n{divider}\n\n"
            f"üìà *ESTAD√çSTICAS*\n"
            f"   ‚Ä¢ Solicitudes: *{puntos_info['solicitudes_aprobadas']}* aprobadas\n"
            f"   ‚Ä¢ Encuestas: *{puntos_info['encuestas_completadas']}* completadas\n"
            f"   ‚Ä¢ Racha: *{puntos_info['racha_dias']}* d√≠as üî•\n\n"
            f"{divider}\n\n"
            f"üí° *FORMAS DE GANAR PUNTOS*\n"
            f"   ‚Ä¢ +50 pts ‚Üí Solicitud aprobada\n"
            f"   ‚Ä¢ +10 pts ‚Üí Completar encuesta\n"
            f"   ‚Ä¢ +5 pts ‚Üí Racha semanal\n\n"
        )

        # Agregar botones solo en chat privado
        if is_private:
            mensaje += f"üéÅ *Usa los botones para canjear recompensas*"

            keyboard = [
                [InlineKeyboardButton("üéÅ Ver Recompensas Disponibles", callback_data="user_view_rewards")],
                [InlineKeyboardButton("üèÜ Ver Ranking", callback_data="user_menu_ranking"),
                 InlineKeyboardButton("üìã Mis Solicitudes", callback_data="user_menu_solicitudes")],
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="user_menu_puntos")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            sent_message = await safe_bot_method(
                message.reply_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        else:
            mensaje += f"üèÜ Usa `/ranking` para ver el top de usuarios"

            sent_message = await safe_bot_method(
                message.reply_text,
                text=mensaje,
                parse_mode="Markdown"
            )

            if sent_message:
                context.application.create_task(
                    auto_delete_message(context, chat_id, sent_message.message_id, 120)
                )

        logger.info(f"‚úÖ Comando /mispuntos ejecutado por user_id={user_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en /mispuntos: {str(e)}")
        error_msg = await safe_bot_method(
            message.reply_text,
            text="‚ùå Error al obtener tus puntos. Intenta de nuevo m√°s tarde."
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 60)
            )

async def handle_missolicitudes(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Comando /missolicitudes - Muestra las solicitudes del usuario."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_missolicitudes")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = f"@{message.from_user.username}" if message.from_user.username else f"Usuario {user_id}"

    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Solicitudes pendientes
                c.execute("""
                    SELECT ticket_number, message_text, chat_title, timestamp
                    FROM peticiones_registradas
                    WHERE user_id = %s
                    ORDER BY timestamp DESC
                    LIMIT 5
                """, (user_id,))
                pendientes = c.fetchall()

                # Solicitudes gestionadas (√∫ltimas 5)
                c.execute("""
                    SELECT ticket_number, message_text, chat_title, estado, fecha_gestion
                    FROM historial_solicitudes
                    WHERE user_id = %s
                    ORDER BY fecha_gestion DESC
                    LIMIT 5
                """, (user_id,))
                historial = c.fetchall()

        username_escaped = escape_markdown(username, preserve_username=True)

        mensaje = (
            f"üìã **MIS SOLICITUDES** üìã\n\n"
            f"üë§ **Usuario:** {username_escaped}\n"
            f"üÜî **ID:** `{user_id}`\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        )

        if pendientes:
            mensaje += f"‚è≥ **SOLICITUDES PENDIENTES** ({len(pendientes)})\n\n"
            for i, sol in enumerate(pendientes, 1):
                texto_preview = sol["message_text"][:50] + "..." if len(sol["message_text"]) > 50 else sol["message_text"]
                fecha = sol["timestamp"].strftime("%d/%m/%Y")
                mensaje += (
                    f"{i}. üé´ **Ticket #{sol['ticket_number']}**\n"
                    f"   üìù {escape_markdown(texto_preview)}\n"
                    f"   üìç {escape_markdown(sol['chat_title'])}\n"
                    f"   üìÖ {fecha}\n\n"
                )
        else:
            mensaje += "‚è≥ **SOLICITUDES PENDIENTES**\nNo tienes solicitudes pendientes.\n\n"

        mensaje += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"

        if historial:
            mensaje += f"üìú **HISTORIAL RECIENTE** ({len(historial)})\n\n"
            for i, sol in enumerate(historial, 1):
                texto_preview = sol["message_text"][:40] + "..." if len(sol["message_text"]) > 40 else sol["message_text"]
                fecha = sol["fecha_gestion"].strftime("%d/%m/%Y")
                estado_emoji = {"subido": "‚úÖ", "denegado": "‚ùå", "eliminado": "üóëÔ∏è", "cancelado": "üîÑ"}.get(sol["estado"].lower(), "üìã")
                mensaje += (
                    f"{i}. {estado_emoji} **#{sol['ticket_number']}** - {sol['estado'].upper()}\n"
                    f"   üìù {escape_markdown(texto_preview)}\n"
                    f"   üìÖ {fecha}\n\n"
                )
        else:
            mensaje += "üìú **HISTORIAL RECIENTE**\nNo tienes solicitudes en el historial.\n\n"

        mensaje += (
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üí° **L√çMITE DIARIO:** 2 solicitudes/d√≠a\n"
            f"üìä Usa `/mispuntos` para ver tus puntos\n"
            f"‚ùå Usa `/cancelar [ticket]` para cancelar"
        )

        sent_message = await safe_bot_method(
            message.reply_text,
            text=mensaje,
            parse_mode="Markdown"
        )

        if sent_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 120)
            )

        logger.info(f"‚úÖ Comando /missolicitudes ejecutado por user_id={user_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en /missolicitudes: {str(e)}")
        error_msg = await safe_bot_method(
            message.reply_text,
            text="‚ùå Error al obtener tus solicitudes. Intenta de nuevo m√°s tarde."
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 60)
            )

async def handle_ranking(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Comando /ranking - Muestra el top de usuarios por puntos."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_ranking")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id

    # Eliminar el comando del usuario despu√©s de 2 minutos
    if chat_id in CANALES_PETICIONES or chat_id == GROUP_DESTINO:
        context.application.create_task(
            auto_delete_message(context, chat_id, message.message_id, 120)
        )

    try:
        top_usuarios = obtener_top_usuarios(10)

        if not top_usuarios:
            error_msg = await safe_bot_method(
                message.reply_text,
                text="‚ö†Ô∏è No hay usuarios en el ranking todav√≠a."
            )
            if error_msg:
                context.application.create_task(
                    auto_delete_message(context, chat_id, error_msg.message_id, 60)
                )
            return

        # Dise√±o profesional mejorado
        divider = "‚îÅ" * 35
        mensaje = (
            f"{divider}\n"
            f"üèÜ *RANKING DE USUARIOS* üèÜ\n"
            f"*Top 10 Mejores Participantes*\n"
            f"{divider}\n\n"
        )

        posicion_usuario = None

        # Top 3 con dise√±o especial
        for i, usuario in enumerate(top_usuarios[:3], 1):
            nivel_emoji = NIVELES.get(usuario["nivel"], NIVELES["bronce"])["emoji"]
            username_display = escape_markdown(usuario["username"], preserve_username=True)

            if i == 1:
                medalla = "ü•á"
                marco = "‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì"
                fin_marco = "‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ"
            elif i == 2:
                medalla = "ü•à"
                marco = "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
                fin_marco = "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
            else:
                medalla = "ü•â"
                marco = "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê"
                fin_marco = "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"

            es_usuario_actual = usuario["user_id"] == user_id
            if es_usuario_actual:
                posicion_usuario = i

            mensaje += f"{marco}\n"
            if es_usuario_actual:
                mensaje += f"‚îÇ {medalla} **{username_display}** üëà T√ö\n"
            else:
                mensaje += f"‚îÇ {medalla} **{username_display}**\n"
            mensaje += f"‚îÇ {nivel_emoji} *{usuario['nivel'].capitalize()}* ‚îÇ **{usuario['puntos']:,}** pts\n"
            mensaje += f"‚îÇ ‚úÖ {usuario['solicitudes_aprobadas']} aprobadas\n"
            mensaje += f"{fin_marco}\n\n"

        # Resto del top 10
        if len(top_usuarios) > 3:
            mensaje += f"‚îå‚îÄ *Otros Destacados* ‚îÄ‚îê\n"
            for i, usuario in enumerate(top_usuarios[3:], 4):
                nivel_emoji = NIVELES.get(usuario["nivel"], NIVELES["bronce"])["emoji"]
                username_display = escape_markdown(usuario["username"], preserve_username=True)

                es_usuario_actual = usuario["user_id"] == user_id
                if es_usuario_actual:
                    posicion_usuario = i
                    mensaje += f"‚îÇ `{i:>2}.` {nivel_emoji} **{username_display}** üëà ‚îÇ `{usuario['puntos']:,}` pts\n"
                else:
                    mensaje += f"‚îÇ `{i:>2}.` {nivel_emoji} {username_display} ‚îÇ `{usuario['puntos']:,}` pts\n"
            mensaje += f"‚îî{'‚îÄ' * 32}‚îò\n\n"

        mensaje += f"{divider}\n\n"

        # Informaci√≥n del usuario
        if posicion_usuario:
            if posicion_usuario == 1:
                emoji = "üëë"
            elif posicion_usuario <= 3:
                emoji = "üåü"
            else:
                emoji = "‚≠ê"
            mensaje += f"{emoji} **Tu Posici√≥n:** #{posicion_usuario}\n\n"
        else:
            mensaje += f"üìä **Tu Posici√≥n:** Fuera del top 10\n"
            mensaje += f"üí™ ¬°Sigue participando para entrar al ranking!\n\n"

        mensaje += (
            f"üí° **Comandos √ötiles:**\n"
            f"‚Ä¢ `/mispuntos` - Ver tus estad√≠sticas\n"
            f"‚Ä¢ `/recompensas` - Ver premios disponibles\n"
            f"‚Ä¢ `/horario` - Ver horario del bot"
        )

        sent_message = await safe_bot_method(
            message.reply_text,
            text=mensaje,
            parse_mode="Markdown"
        )

        # Autoeliminar respuesta despu√©s de 2 minutos
        if sent_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 120)
            )

        logger.info(f"‚úÖ Comando /ranking ejecutado por user_id={user_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en /ranking: {str(e)}")
        error_msg = await safe_bot_method(
            message.reply_text,
            text="‚ùå Error al obtener el ranking. Intenta de nuevo m√°s tarde."
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 60)
            )

async def handle_recompensas(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Comando /recompensas - Muestra las recompensas disponibles para canjear."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_recompensas")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id

    try:
        recompensas = obtener_recompensas_disponibles()
        puntos_info = obtener_puntos_usuario(user_id)
        puntos_usuario = puntos_info["puntos"] if puntos_info else 0

        # --- Deduplicaci√≥n de recompensas (blindaje en capa de presentaci√≥n) ---
        vistos = set()
        recompensas_unicas = []
        for r in recompensas or []:
            # Clave l√≥gica para evitar duplicados por contenido
            k = (
                (r.get("nombre") or "").strip().lower(),
                (r.get("descripcion") or "").strip().lower(),
                int(r.get("costo_puntos") or 0),
            )
            if k not in vistos:
                vistos.add(k)
                recompensas_unicas.append({
                    "nombre": r.get("nombre", "").strip(),
                    "descripcion": r.get("descripcion", "").strip(),
                    "costo_puntos": int(r.get("costo_puntos") or 0),
                })

        mensaje = (
            f"üéÅ **RECOMPENSAS DISPONIBLES** üéÅ\n\n"
            f"üí∞ **Tus puntos:** {puntos_usuario:,} pts\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        )

        if recompensas_unicas:
            for i, rec in enumerate(recompensas_unicas, 1):
                puede_canjear = "‚úÖ" if puntos_usuario >= rec["costo_puntos"] else "üîí"
                mensaje += (
                    f"{puede_canjear} **{i}. {rec['nombre']}**\n"
                    f"   üí∞ Costo: **{rec['costo_puntos']:,} puntos**\n"
                    f"   üìù {rec['descripcion']}\n\n"
                )
        else:
            mensaje += "‚ö†Ô∏è No hay recompensas disponibles en este momento.\n\n"

        mensaje += (
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            "üí° **C√≥mo canjear:**\n"
            "Contacta a un administrador con @admin indicando\n"
            "la recompensa que deseas y tu ID de usuario.\n\n"
            "üéØ Usa `/mispuntos` para ver tus estad√≠sticas\n"
            "üèÜ Usa `/ranking` para ver tu posici√≥n"
        )

        sent_message = await safe_bot_method(
            message.reply_text,
            text=mensaje,
            parse_mode="Markdown"
        )

        if sent_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 120)
            )

        logger.info(f"‚úÖ Comando /recompensas ejecutado por user_id={user_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en /recompensas: {str(e)}")
        error_msg = await safe_bot_method(
            message.reply_text,
            text="‚ùå Error al obtener recompensas. Intenta de nuevo m√°s tarde."
        )
        if error_msg:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_msg.message_id, 60)
            )

async def handle_horario(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Comando /horario - Muestra el horario actual del bot para usuarios."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_horario")
        return

    message = update.message
    chat_id = message.chat_id

    schedule = get_bot_schedule()

    if not schedule:
        mensaje = (
            f"üïê **HORARIO DEL BOT** üïê\n\n"
            f"‚úÖ **El bot acepta solicitudes 24/7**\n\n"
            f"No hay restricciones de horario configuradas.\n"
            f"Puedes enviar tus solicitudes en cualquier momento.\n\n"
            f"üìù **Recuerda:**\n"
            f"‚Ä¢ Usa `/solicito` o `#peticion` para hacer solicitudes\n"
            f"‚Ä¢ L√≠mite: 2 solicitudes por d√≠a\n"
            f"‚Ä¢ Usa `/missolicitudes` para ver tus solicitudes"
        )
    else:
        days_str = ", ".join(schedule['days_of_week'])
        is_active = is_within_schedule()
        estado_actual = "üü¢ **ACTIVO**" if is_active else "üî¥ **INACTIVO**"

        # Calcular pr√≥ximo horario activo si est√° inactivo
        proximo_horario = ""
        if not is_active:
            now = datetime.now(SPAIN_TZ)
            current_day = now.strftime("%A")
            day_mapping = {
                "Monday": "Lunes", "Tuesday": "Martes", "Wednesday": "Mi√©rcoles",
                "Thursday": "Jueves", "Friday": "Viernes", "Saturday": "S√°bado", "Sunday": "Domingo"
            }
            current_day_spanish = day_mapping.get(current_day, current_day)

            if current_day_spanish in schedule["days_of_week"]:
                # Mismo d√≠a, despu√©s de la hora de cierre
                if now.hour >= schedule['end_hour']:
                    proximo_horario = f"\n‚è∞ **Pr√≥ximo horario:** Ma√±ana a las {schedule['start_hour']:02d}:00"
                else:
                    proximo_horario = f"\n‚è∞ **Pr√≥ximo horario:** Hoy a las {schedule['start_hour']:02d}:00"
            else:
                # Buscar el pr√≥ximo d√≠a activo
                dias_orden = ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado", "Domingo"]
                current_index = dias_orden.index(current_day_spanish)

                for i in range(1, 8):
                    next_index = (current_index + i) % 7
                    next_day = dias_orden[next_index]
                    if next_day in schedule["days_of_week"]:
                        proximo_horario = f"\n‚è∞ **Pr√≥ximo horario:** {next_day} a las {schedule['start_hour']:02d}:00"
                        break

        mensaje = (
            f"üïê **HORARIO DEL BOT** üïê\n\n"
            f"üìä **Estado actual:** {estado_actual}{proximo_horario}\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üìÖ **D√≠as activos:**\n{days_str}\n\n"
            f"üïí **Horario de solicitudes:**\n"
            f"De **{schedule['start_hour']:02d}:00** a **{schedule['end_hour']:02d}:00**\n\n"
            f"üåç **Zona horaria:** Europe/Madrid\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"‚ö†Ô∏è **IMPORTANTE:**\n"
            f"‚Ä¢ Las solicitudes fuera de horario ser√°n advertidas\n"
            f"‚Ä¢ 2 violaciones = Silencio de 7 d√≠as (1 semana)\n"
            f"‚Ä¢ Penalizaci√≥n: -50 puntos\n\n"
            f"üí° **Recomendaciones:**\n"
            f"‚Ä¢ Planifica tus solicitudes dentro del horario\n"
            f"‚Ä¢ Lee las normas del grupo\n"
            f"‚Ä¢ Consulta `/ayuda` para m√°s informaci√≥n"
        )

    sent_message = await safe_bot_method(
        message.reply_text,
        text=mensaje,
        parse_mode="Markdown"
    )

    if sent_message:
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 300)
        )

    logger.info(f"‚úÖ Comando /horario ejecutado por user_id={message.from_user.id}")

async def handle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /menu para mostrar el panel de administraci√≥n a usuarios autorizados."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_menu")
        return

    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    username = escape_markdown(f"@{message.from_user.username}", True) if message.from_user.username else "Usuario"

    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        logger.info(f"‚ö†Ô∏è Intento de acceso no autorizado a /menu por user_id={user_id}")
        return

    # Mostrar indicador de "escribiendo..." mientras se prepara el men√∫
    await show_typing_indicator(context, chat_id, 1.0)

    # Cerrar men√∫s anteriores del mismo admin
    for (existing_chat_id, existing_message_id), menu_data in list(menu_activos.items()):
        if menu_data.get("admin_id") == user_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=existing_chat_id,
                message_id=existing_message_id
            )
            del menu_activos[(existing_chat_id, existing_message_id)]

    # Obtener estad√≠sticas r√°pidas para el men√∫
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                pendientes = c.fetchone()[0]
    except Exception as e:
        logger.error(f"Error obteniendo estad√≠sticas: {str(e)}")
        pendientes = 0

    keyboard = [
        [InlineKeyboardButton("üìã Gesti√≥n de Solicitudes", callback_data="menu_gestion"),
         InlineKeyboardButton("üìä Estad√≠sticas y Reportes", callback_data="menu_estadisticas")],
        [InlineKeyboardButton("‚öôÔ∏è Configuraci√≥n del Bot", callback_data="menu_configuracion"),
         InlineKeyboardButton("üõ†Ô∏è Herramientas Admin", callback_data="menu_herramientas")],
        [InlineKeyboardButton("üîß Mantenimiento", callback_data="menu_mantenimiento"),
         InlineKeyboardButton("üí∞ Sistema de Puntos", callback_data="menu_puntos")],
        [InlineKeyboardButton("‚ùå Cerrar Panel", callback_data="menu_close")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Dise√±o profesional mejorado
    divider = "‚îÅ" * 35
    texto = (
        f"{divider}\n"
        f"üéõÔ∏è *PANEL DE ADMINISTRACI√ìN* üéõÔ∏è\n"
        f"*EntresHijos Bot v2.0*\n"
        f"{divider}\n\n"
        f"üë§ *Admin:* {username}\n"
        f"üìÖ *Fecha:* `{get_spain_time()}`\n"
        f"üìä *Pendientes:* `{pendientes}` solicitudes\n"
        f"üü¢ *Estado:* Sistema Operativo\n\n"
        f"{divider}\n\n"
        f"üí° _Selecciona una categor√≠a para gestionar:_\n\n"
        f"üìã **Gesti√≥n** ‚îÄ Administra solicitudes\n"
        f"üìä **Estad√≠sticas** ‚îÄ An√°lisis y reportes\n"
        f"‚öôÔ∏è **Configuraci√≥n** ‚îÄ Ajustes del bot\n"
        f"üõ†Ô∏è **Herramientas** ‚îÄ Utilidades admin\n"
        f"üîß **Mantenimiento** ‚îÄ Modo servicio\n"
        f"üí∞ **Puntos** ‚îÄ Sistema de gamificaci√≥n\n\n"
        f"‚è∞ _Sesi√≥n expira en 15 minutos_"
    )

    sent_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

    if sent_message:
        menu_activos[(chat_id, sent_message.message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )

    logger.info(f"‚úÖ Men√∫ de administraci√≥n abierto por user_id={user_id} en chat_id={chat_id}")

async def cancel_schedule(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancela la configuraci√≥n del horario."""
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id

    context.user_data.clear()
    texto = (
        f"‚ùå *Configuraci√≥n Cancelada* ‚ùå\n"
        f"La configuraci√≥n del horario ha sido cancelada."
    )
    keyboard = [
        [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
         InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await safe_bot_method(
        query.edit_message_text,
        text=texto,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

    menu_activos[(chat_id, message_id)] = {
        "last_activity": datetime.now(SPAIN_TZ),
        "admin_id": user_id,
        "message_content": texto,
        "message_markup": reply_markup,
        "last_page": 1
    }

    logger.info(f"‚úÖ Configuraci√≥n de horario cancelada por user_id={user_id}")
    return ConversationHandler.END

async def send_to_all_channels(context: ContextTypes.DEFAULT_TYPE, message_text: str,
                              parse_mode: str = "Markdown", reply_markup=None,
                              exclude_channels: list = None):
    """Env√≠a un mensaje a todos los canales configurados."""
    exclude_channels = exclude_channels or []
    results = {}
    
    for chat_id, canal_info in CANALES_PETICIONES.items():
        if chat_id in exclude_channels:
            continue
            
        try:
            sent_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=canal_info["chat_id"],
                text=message_text,
                message_thread_id=canal_info["thread_id"],
                parse_mode=parse_mode,
                reply_markup=reply_markup
            )
            
            if sent_message:
                results[chat_id] = sent_message.message_id
                logger.info(f"‚úÖ Mensaje enviado a {GRUPOS_PREDEFINIDOS.get(chat_id, f'Grupo {chat_id}')}")
            else:
                results[chat_id] = None
                logger.warning(f"‚ö†Ô∏è Fallo al enviar a {GRUPOS_PREDEFINIDOS.get(chat_id, f'Grupo {chat_id}')}")
                
        except Exception as e:
            results[chat_id] = None
            logger.error(f"‚ùå Error enviando a {chat_id}: {str(e)}")
    
    return results

async def send_notification_to_all_channels(context: ContextTypes.DEFAULT_TYPE,
                                          notification_type: str, **kwargs):
    """Env√≠a notificaciones espec√≠ficas a todos los canales."""
    
    if notification_type == "maintenance":
        is_active = kwargs.get("is_active", False)
        message = kwargs.get("message", "Mantenimiento programado")
        
        if is_active:
            notification_text = (
                f"üöß *Modo de Mantenimiento Activado* üöß\n\n"
                f"üìù {message}\n\n"
                f"‚è∞ *Activado:* {get_spain_time()}\n"
                f"üîÑ El bot no procesar√° nuevas solicitudes temporalmente.\n"
                f"ü§ù *Equipo EntresHijos*"
            )

            # Enviar y guardar mensajes para eliminarlos despu√©s
            results = await send_to_all_channels(context, notification_text)
            for chat_id, message_id in results.items():
                if message_id:
                    save_maintenance_message(chat_id, message_id, None, "start")

            # Enviar notificaci√≥n al grupo de administraci√≥n con bot√≥n
            admin_notification = (
                f"üöß *Modo de Mantenimiento Activado* üöß\n\n"
                f"üìù **Mensaje personalizado:**\n"
                f"```\n{message}\n```\n\n"
                f"‚è∞ **Activado:** {get_spain_time()}\n"
                f"üîÑ **Estado:** Bot no procesar√° nuevas solicitudes\n"
                f"üì¢ **Acci√≥n:** Notificaci√≥n enviada a todos los canales\n\n"
                f"*Sistema de Administraci√≥n EntresHijos* üõ°Ô∏è"
            )

            keyboard = [[InlineKeyboardButton("Gestionado ‚úÖ", callback_data="gestionado_maintenance")]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                context.bot.send_message,
                chat_id=GROUP_DESTINO,
                text=admin_notification,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            
        else:
            # Primero eliminar mensajes de mantenimiento anteriores
            await delete_all_maintenance_messages(context)
            
            # Luego enviar notificaci√≥n de fin
            await send_maintenance_end_notification(context)
    
    elif notification_type == "schedule_change":
        days = kwargs.get("days", [])
        start_hour = kwargs.get("start_hour", 0)
        end_hour = kwargs.get("end_hour", 23)
        
        notification_text = (
            f"üìÖ *Cambio de Horario* üìÖ\n\n"
            f"üïí *Nuevo horario de solicitudes:*\n"
            f"üìÜ *D√≠as:* {', '.join(days)}\n"
            f"üïê *Horario:* {start_hour:02d}:00 - {end_hour:02d}:00\n"
            f"üåç *Zona horaria:* Europe/Madrid\n\n"
            f"‚è∞ *Efectivo desde:* {get_spain_time()}\n"
            f"ü§ù *Equipo EntresHijos*"
        )
        
        return await send_to_all_channels(context, notification_text)
    
    elif notification_type == "announcement":
        title = kwargs.get("title", "Anuncio Importante")
        content = kwargs.get("content", "")
        
        notification_text = (
            f"üì¢ *{title}* üì¢\n\n"
            f"{content}\n\n"
            f"‚è∞ *Fecha:* {get_spain_time()}\n"
            f"ü§ù *Equipo EntresHijos*"
        )
        
        return await send_to_all_channels(context, notification_text)
    
    else:
        logger.warning(f"‚ö†Ô∏è Tipo de notificaci√≥n desconocido: {notification_type}")
        return {}

async def render_menu_masiva(query, user_id, chat_id, message_id):
    """Renderiza el men√∫ de gesti√≥n masiva con dise√±o moderno y profesional."""
    if user_id not in selected_requests:
        selected_requests[user_id] = []

    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Obtener todas las solicitudes con m√°s informaci√≥n
                c.execute("""
                    SELECT
                        pr.ticket_number,
                        pr.username,
                        pr.message_text,
                        pr.chat_title,
                        pr.timestamp,
                        pr.has_attachment,
                        COUNT(rv.id) as total_votes
                    FROM peticiones_registradas pr
                    LEFT JOIN request_votes rv ON pr.ticket_number = rv.ticket_number
                    GROUP BY pr.ticket_number, pr.username, pr.message_text, pr.chat_title, pr.timestamp, pr.has_attachment
                    ORDER BY pr.timestamp DESC
                    LIMIT 15
                """)
                peticiones = c.fetchall()

                c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                total_peticiones = c.fetchone()[0]

        if not peticiones:
            divider = "‚îÅ" * 35
            texto = (
                f"{divider}\n"
                f"üî≤ *GESTI√ìN MASIVA DE SOLICITUDES* üî≤\n"
                f"{divider}\n\n"
                f"üì≠ *No hay solicitudes pendientes*\n\n"
                f"‚ú® Las nuevas solicitudes aparecer√°n aqu√≠ para gesti√≥n m√∫ltiple\n\n"
                f"üí° _Selecciona m√∫ltiples solicitudes para procesarlas en lote_\n\n"
                f"‚è∞ {get_spain_time()}"
            )
            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="menu_masiva")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_gestion"),
                 InlineKeyboardButton("‚úñÔ∏è Cerrar", callback_data="menu_close")]
            ]
        else:
            selected = selected_requests[user_id]
            divider = "‚îÅ" * 35

            # Crear header con estad√≠sticas
            texto = (
                f"{divider}\n"
                f"üî≤ *GESTI√ìN MASIVA DE SOLICITUDES* üî≤\n"
                f"{divider}\n\n"
                f"üìä *Estado de Selecci√≥n:*\n"
                f"   ‚Ä¢ Total disponibles: `{total_peticiones}`\n"
                f"   ‚Ä¢ Mostrando: `{len(peticiones)}`\n"
                f"   ‚Ä¢ Seleccionadas: `{len(selected)}`\n\n"
            )

            if selected:
                texto += f"‚úÖ *{len(selected)} solicitud(es) lista(s) para procesar*\n\n"
            else:
                texto += f"üí° _Selecciona las solicitudes que deseas procesar_\n\n"

            texto += f"{divider}\n\n"

            keyboard = []

            # Botones de selecci√≥n con dise√±o mejorado
            for p in peticiones:
                is_selected = p['ticket_number'] in selected

                # Emojis modernos y claros
                checkbox = "‚úÖ" if is_selected else "‚¨ú"
                attachment_icon = "üìé" if p.get('has_attachment') else ""
                votes_icon = f"üó≥Ô∏è{p['total_votes']}" if p['total_votes'] > 0 else ""

                # Truncar username y mensaje para mejor visualizaci√≥n
                username_display = p['username'][:15] if p['username'] else "Usuario"
                if not username_display.startswith('@'):
                    username_display = f"@{username_display}"

                message_preview = p['message_text'][:25] if p['message_text'] else "Sin mensaje"
                if len(p['message_text']) > 25:
                    message_preview += "..."

                # Formatear timestamp
                timestamp = p['timestamp']
                if timestamp:
                    time_str = timestamp.strftime("%d/%m %H:%M")
                else:
                    time_str = "N/A"

                # Crear bot√≥n con informaci√≥n compacta y clara
                button_text = f"{checkbox} #{p['ticket_number']} ¬∑ {username_display}"

                keyboard.append([
                    InlineKeyboardButton(
                        button_text,
                        callback_data=f"toggle_select_{p['ticket_number']}"
                    )
                ])

                # Bot√≥n secundario con info adicional (en una segunda fila)
                info_text = f"   üìç {p['chat_title'][:20]} ¬∑ ‚è∞ {time_str}"
                if attachment_icon or votes_icon:
                    info_text += f" ¬∑ {attachment_icon}{votes_icon}"

                keyboard.append([
                    InlineKeyboardButton(
                        info_text,
                        callback_data=f"toggle_select_{p['ticket_number']}"
                    )
                ])

            # Agregar l√≠nea separadora
            keyboard.append([InlineKeyboardButton("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", callback_data="noop")])

            # Acciones masivas con emojis modernos
            if selected:
                keyboard.append([
                    InlineKeyboardButton(f"üî¥ Denegar ({len(selected)})", callback_data="batch_deny_start"),
                    InlineKeyboardButton("üóëÔ∏è Limpiar", callback_data="clear_selection")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚òëÔ∏è Seleccionar Todas", callback_data="select_all_batch"),
                    InlineKeyboardButton("‚¨ú Deseleccionar Todas", callback_data="deselect_all_batch")
                ])
            else:
                keyboard.append([
                    InlineKeyboardButton("‚òëÔ∏è Seleccionar Todas", callback_data="select_all_batch")
                ])

            # Navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üîÑ Actualizar", callback_data="menu_masiva")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_gestion"),
                InlineKeyboardButton("‚úñÔ∏è Cerrar", callback_data="menu_close")
            ])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return True
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error renderizando men√∫ masiva: {str(e)}")
        return False

async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja las interacciones con los botones del men√∫ interactivo."""
    query = update.callback_query

    try:
        await query.answer()
    except Exception as e:
        if "query is too old" in str(e).lower() or "timeout" in str(e).lower():
            logger.warning(f"‚ö†Ô∏è Callback query expirado, continuando procesamiento: {str(e)}")
        else:
            logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")

    if not query.message:
        logger.warning(f"‚ö†Ô∏è Callback query sin mensaje asociado: {query.data}")
        return ConversationHandler.END

    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id
    data = query.data
    logger.info(f"‚úÖ Bot√≥n presionado: {data}, user_id={user_id}, chat_id={chat_id}")

    # Helper: comprobar si el bot puede borrar en este chat
    async def _bot_can_delete_in(_chat_id: int) -> bool:
        try:
            me = await context.bot.get_chat_member(_chat_id, (await context.bot.get_me()).id)
            # Si es admin/owner y tiene permiso de borrar (en algunos tipos siempre es True)
            if me.status in ("administrator", "creator"):
                return getattr(me, "can_delete_messages", True)
            return False
        except Exception:
            return False

    if data.startswith("continue_duplicate_"):
        ticket_number = int(data.split("_")[2])
        
        # Recuperar la solicitud pendiente
        pending_request = context.bot_data.get(f"pending_request_{ticket_number}")
        if not pending_request:
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END
        
        # Procesar la solicitud normalmente
        user_data = pending_request["user_data"]
        new_count = user_data["count"] + 1
        set_peticiones_por_usuario(user_id, new_count, pending_request["chat_id"], pending_request["username"], user_data["last_reset"])
        
        set_peticion_registrada(ticket_number, {
            "chat_id": pending_request["chat_id"],
            "username": pending_request["username"],
            "user_id": pending_request["user_id"],
            "message_text": pending_request["message_text"],
            "message_id": None,
            "timestamp": pending_request["timestamp"],
            "chat_title": pending_request["chat_title"],
            "thread_id": pending_request["thread_id"],
            "has_attachment": pending_request["has_attachment"],
            "photo_file_id": pending_request["photo_file_id"]
        })
        
        # Eliminar advertencia de duplicados
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message_id
        )
        
        # Limpiar datos temporales
        if f"pending_request_{ticket_number}" in context.bot_data:
            del context.bot_data[f"pending_request_{ticket_number}"]
        if f"duplicate_warning_{ticket_number}" in context.bot_data:
            del context.bot_data[f"duplicate_warning_{ticket_number}"]
        
        # Continuar con el procesamiento normal
        username_escaped = escape_markdown(pending_request["username"], preserve_username=True)
        chat_title_escaped = escape_markdown(pending_request["chat_title"])
        message_text_escaped = escape_markdown(pending_request["message_text"])
        timestamp_str = pending_request["timestamp"].strftime("%d/%m/%Y %H:%M:%S")
        
        destino_message = (
            f"üì© *Nueva solicitud recibida* ‚úÖ\n"
            f"üë§ *Usuario:* {username_escaped} (ID: {pending_request['user_id']})\n"
            f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
            f"üìä *Petici√≥n:* {new_count}/2\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {chat_title_escaped}\n"
            f"‚è∞ *Fecha:* {timestamp_str}\n"
            f"üìé *Adjunto:* {'S√≠' if pending_request['has_attachment'] else 'No'}\n"
            f"üîç *Verificado:* Sin duplicados confirmados\n"
            f"ü§ù *Bot de Entreshijos*"
        )
        
        sent_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=destino_message,
            parse_mode="Markdown"
        )
        
        if sent_message:
            set_peticion_registrada(ticket_number, {
                "chat_id": pending_request["chat_id"],
                "username": pending_request["username"],
                "user_id": pending_request["user_id"],
                "message_text": pending_request["message_text"],
                "message_id": sent_message.message_id,
                "timestamp": pending_request["timestamp"],
                "chat_title": pending_request["chat_title"],
                "thread_id": pending_request["thread_id"],
                "has_attachment": pending_request["has_attachment"],
                "photo_file_id": pending_request["photo_file_id"]
            })
        
        # Enviar imagen si la hay
        if pending_request["has_attachment"] and pending_request["photo_file_id"]:
            photo_message = await safe_bot_method(
                context.bot.send_photo,
                chat_id=GROUP_DESTINO,
                photo=pending_request["photo_file_id"],
                caption=f"üì∏ *Imagen adjunta para solicitud #{ticket_number}*",
                parse_mode="Markdown"
            )
            if photo_message:
                context.bot_data[f"photo_{ticket_number}"] = photo_message.message_id
        
        # Enviar mensaje de confirmaci√≥n
        votes = get_votes_summary(ticket_number)
        vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else "\nüó≥Ô∏è *Votos:* +0 / -0"
        
        try:
            bot_info = await context.bot.get_me()
            bot_username = bot_info.username
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo info del bot: {str(e)}")
            bot_username = "EntresHijosBot"
        
        canal_info = CANALES_PETICIONES.get(pending_request["chat_id"], {"chat_id": pending_request["chat_id"], "thread_id": pending_request["thread_id"]})
        
        puntos_info = get_puntos_info_texto(pending_request['user_id'], pending_request['username'])

        confirmacion_message = (
            f"‚úÖ *Solicitud Registrada* ‚úÖ\n"
            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido recibida con √©xito.\n\n"
            f"üìå *Detalles:*\n"
            f"üÜî *ID:* {pending_request['user_id']}\n"
            f"üìç *Grupo:* {chat_title_escaped}\n"
            f"‚è∞ *Fecha:* {timestamp_str}\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìé *Adjunto:* {'S√≠' if pending_request['has_attachment'] else 'No'}\n"
            f"üìä *Solicitudes hoy:* {new_count}/2{vote_text}{puntos_info}\n"
            f"üîç *Verificado:* Sin duplicados confirmados\n\n"
            f"‚åõ Ser√° procesada pronto. ¬°Gracias por tu paciencia!\n\n"
            f"üì± *¬øQuieres recibir notificaciones personalizadas?*\n"
            f"Para mantenerte al tanto de *tu solicitud* (aprobaciones, cambios de estado o actualizaciones), sigue estos pasos:\n"
            f"1Ô∏è‚É£ Abre un chat privado con el bot. Busca @{bot_username} en Telegram y haz clic en su nombre.\n"
            f"2Ô∏è‚É£ Escribe cualquier mensaje (por ejemplo, 'Hola') y pulsa el bot√≥n *'Start'* (o escribe */start*).\n"
            f"3Ô∏è‚É£ ¬°Listo! Recibir√°s notificaciones privadas *solo sobre tus solicitudes*, sin publicidad ni mensajes innecesarios.\n\n"
            f"ü§ù ¬°Estamos aqu√≠ para ayudarte!"
        )

        keyboard = generar_teclado_confirmacion_solicitud(ticket_number, pending_request['user_id'])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        confirmacion_sent = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=confirmacion_message,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
        
        if confirmacion_sent:
            save_confirmation_message(ticket_number, canal_info["chat_id"], confirmacion_sent.message_id, pending_request["user_id"])
            context.bot_data[f"confirmacion_{ticket_number}"] = confirmacion_sent.message_id
        
        logger.info(f"‚úÖ Solicitud #{ticket_number} procesada despu√©s de confirmar duplicados")
        return ConversationHandler.END
    
    if data.startswith("cancel_duplicate_"):
        ticket_number = int(data.split("_")[2])
        
        # Recuperar la solicitud pendiente
        pending_request = context.bot_data.get(f"pending_request_{ticket_number}")
        if not pending_request:
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END
        
        # Eliminar advertencia de duplicados
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message_id
        )
        
        # Limpiar datos temporales
        if f"pending_request_{ticket_number}" in context.bot_data:
            del context.bot_data[f"pending_request_{ticket_number}"]
        if f"duplicate_warning_{ticket_number}" in context.bot_data:
            del context.bot_data[f"duplicate_warning_{ticket_number}"]
        
        # Enviar mensaje de cancelaci√≥n
        username_escaped = escape_markdown(pending_request["username"], preserve_username=True)
        canal_info = CANALES_PETICIONES.get(pending_request["chat_id"], {"chat_id": pending_request["chat_id"], "thread_id": pending_request["thread_id"]})
        
        cancel_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=(
                f"‚ùå *Solicitud #{ticket_number} cancelada* ‚ùå\n"
                f"Hola {username_escaped}, has cancelado tu nueva solicitud debido a duplicados detectados.\n"
                f"üí° Puedes revisar tus solicitudes existentes o enviar una solicitud diferente.\n"
                f"ü§ù *Equipo EntresHijos*"
            ),
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown"
        )
        
        if cancel_message:
            context.application.create_task(
                auto_delete_message(context, canal_info["chat_id"], cancel_message.message_id, 300)
            )
        
        logger.info(f"‚ùå Solicitud #{ticket_number} cancelada por duplicados por user_id={user_id}")
        return ConversationHandler.END
    
    if data.startswith("view_duplicate_"):
        parts = data.split("_")
        duplicate_ticket = int(parts[2])
        original_ticket = int(parts[3])
        
        # Buscar el duplicado en pendientes o historial
        duplicate_info = get_peticion_registrada(duplicate_ticket)
        if not duplicate_info:
            duplicate_info = get_historial_solicitud(duplicate_ticket)
        
        if not duplicate_info:
            await query.answer("‚ùå Solicitud duplicada no encontrada", show_alert=True)
            return ConversationHandler.END
        
        username_escaped = escape_markdown(duplicate_info["username"], preserve_username=True)
        message_text_escaped = escape_markdown(duplicate_info["message_text"])
        chat_title_escaped = escape_markdown(duplicate_info["chat_title"])
        
        if "estado" in duplicate_info:
            # Es del historial
            estado = duplicate_info["estado"].capitalize()
            fecha = duplicate_info["fecha_gestion"].strftime("%d/%m/%Y %H:%M:%S")
            estado_emoji = {
                "Subido": "‚úÖ",
                "Denegado": "‚ùå",
                "Eliminado": "üóëÔ∏è",
                "Cancelado": "üîÑ"
            }.get(estado, "üìã")
            
            detail_text = (
                f"üìã *Detalles del Duplicado #{duplicate_ticket}* üìã\n\n"
                f"üë§ *Usuario:* {username_escaped}\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {chat_title_escaped}\n"
                f"üìä *Estado:* {estado_emoji} {estado}\n"
                f"‚è∞ *Fecha:* {fecha}\n"
                f"üìé *Adjunto:* {'S√≠' if duplicate_info.get('has_attachment') else 'No'}\n\n"
                f"üí° *¬øEs igual a tu nueva solicitud?*"
            )
        else:
            # Es de pendientes
            fecha = duplicate_info["timestamp"].strftime("%d/%m/%Y %H:%M:%S")
            
            detail_text = (
                f"üìã *Detalles del Duplicado #{duplicate_ticket}* üìã\n\n"
                f"üë§ *Usuario:* {username_escaped}\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {chat_title_escaped}\n"
                f"üìä *Estado:* ‚è≥ Pendiente\n"
                f"‚è∞ *Fecha:* {fecha}\n"
                f"üìé *Adjunto:* {'S√≠' if duplicate_info.get('has_attachment') else 'No'}\n\n"
                f"üí° *¬øEs igual a tu nueva solicitud?*"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ Continuar con Nueva", callback_data=f"continue_duplicate_{original_ticket}"),
             InlineKeyboardButton("‚ùå Cancelar Nueva", callback_data=f"cancel_duplicate_{original_ticket}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Comparaci√≥n", callback_data=f"back_to_duplicate_{original_ticket}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=detail_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        logger.info(f"üëÅÔ∏è Detalles del duplicado #{duplicate_ticket} mostrados para comparaci√≥n con #{original_ticket}")
        return ConversationHandler.END
    
    if data.startswith("back_to_duplicate_"):
        ticket_number = int(data.split("_")[3])
        
        # Recuperar informaci√≥n de la advertencia original
        warning_info = context.bot_data.get(f"duplicate_warning_{ticket_number}")
        if not warning_info:
            await query.answer("‚ùå Informaci√≥n de duplicados no encontrada", show_alert=True)
            return ConversationHandler.END
        
        # Recrear la advertencia original
        duplicates = warning_info["duplicates"]
        username = warning_info["username"]
        message_text = warning_info["message_text"]
        
        username_escaped = escape_markdown(username, preserve_username=True)
        message_text_escaped = escape_markdown(message_text[:100] + "..." if len(message_text) > 100 else message_text)
        
        duplicates_text = ""
        keyboard = []
        
        for i, dup in enumerate(duplicates[:3], 1):
            estado_emoji = {
                "pendiente": "‚è≥",
                "subido": "‚úÖ",
                "denegado": "‚ùå",
                "eliminado": "üóëÔ∏è",
                "cancelado": "üîÑ"
            }.get(dup["estado"].lower(), "üìã")
            
            similarity_percent = int(dup["similarity"] * 100)
            timestamp_str = dup["timestamp"].strftime("%d/%m %H:%M")
            dup_text_preview = dup["message_text"][:50] + "..." if len(dup["message_text"]) > 50 else dup["message_text"]
            
            duplicates_text += (
                f"**{i}. {estado_emoji} Ticket #{dup['ticket_number']}** ({similarity_percent}% similar)\n"
                f"   üìù {escape_markdown(dup_text_preview)}\n"
                f"   üìç {escape_markdown(dup['chat_title'])}\n"
                f"   ‚è∞ {timestamp_str}\n\n"
            )
            
            keyboard.append([
                InlineKeyboardButton(
                    f"üìã Ver #{dup['ticket_number']} ({similarity_percent}%)",
                    callback_data=f"view_duplicate_{dup['ticket_number']}_{ticket_number}"
                )
            ])
        
        keyboard.append([
            InlineKeyboardButton("‚úÖ Continuar Anyway", callback_data=f"continue_duplicate_{ticket_number}"),
            InlineKeyboardButton("‚ùå Cancelar Nueva", callback_data=f"cancel_duplicate_{ticket_number}")
        ])
        
        warning_text = (
            f"‚ö†Ô∏è *Posibles Solicitudes Duplicadas Detectadas* ‚ö†Ô∏è\n\n"
            f"Hola {username_escaped}, hemos detectado que tienes solicitudes similares recientes:\n\n"
            f"üìù **Tu nueva solicitud:**\n"
            f"‚úâÔ∏è {message_text_escaped}\n\n"
            f"üîç **Solicitudes similares encontradas:**\n\n"
            f"{duplicates_text}"
            f"üí° **¬øQu√© deseas hacer?**\n"
            f"‚Ä¢ **Continuar:** Si es diferente a las anteriores\n"
            f"‚Ä¢ **Cancelar:** Si es igual a alguna existente\n\n"
            f"ü§ù *Sistema de Calidad EntresHijos* üõ°Ô∏è"
        )
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=warning_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        logger.info(f"‚Ü©Ô∏è Vuelto a advertencia de duplicados para ticket #{ticket_number}")
        return ConversationHandler.END

    # Verificar permisos espec√≠ficos para cada tipo de bot√≥n
    if data.startswith("estado_") or data.startswith("ticket_") or data.startswith("contactar_admin_"):
        if data.startswith("contactar_admin_"):
            ticket_number = int(data.split("_")[2])
        else:
            ticket_number = int(data.split("_")[1])
        if not can_use_request_buttons(user_id, ticket_number, "owner_only"):
            peticion = get_peticion_registrada(ticket_number)
            if not peticion:
                peticion = get_historial_solicitud(ticket_number)
            
            if peticion:
                grupo_chat_id = peticion["chat_id"]
                canal_info = CANALES_PETICIONES.get(grupo_chat_id)
                grupo_title = GRUPOS_PREDEFINIDOS.get(grupo_chat_id, f"Grupo {grupo_chat_id}")
                
                if canal_info:
                    username = f"@{query.from_user.username}" if query.from_user.username else f"ID: {user_id}"
                    fecha_hora = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")
                    
                    attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number)
                    
                    # Verificar si debe ser expulsado por abuso de botones
                    if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
                        username_for_kick = query.from_user.username or f"User{user_id}"
                        await kick_user_for_button_abuse(context, user_id, grupo_chat_id, username_for_kick, total_abuse_count)
                        return ConversationHandler.END
                    
                    alert_message = (
                        f"‚ö†Ô∏è *Detecci√≥n de Uso Incorrecto del Bot√≥n* ‚ö†Ô∏è\n"
                        f"üë§ *Usuario:* {username}\n"
                        f"üÜî *ID:* {user_id}\n"
                        f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
                        f"üìç *Grupo:* {grupo_title}\n"
                        f"‚è∞ *Fecha y Hora:* {fecha_hora}\n"
                        f"üìä *Intento:* {attempt_count} (Total: {total_abuse_count})\n"
                        f"‚ö†Ô∏è *Aviso:* Te quedan {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos antes de la expulsi√≥n.\n\n"
                        f"üòä *Por favor, respeta las solicitudes de los dem√°s.* El uso indebido o cualquier intento de sabotaje resultar√° en la exclusi√≥n inmediata del grupo. ¬°Colaboremos juntos! üôå"
                    )
                    
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=canal_info["chat_id"],
                        text=alert_message,
                        message_thread_id=canal_info["thread_id"],
                        parse_mode="Markdown"
                    )
                else:
                    username = f"@{query.from_user.username}" if query.from_user.username else f"ID: {user_id}"
                    fecha_hora = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")
                    
                    attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number)
                    
                    # Verificar si debe ser expulsado por abuso de botones
                    if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
                        username_for_kick = query.from_user.username or f"User{user_id}"
                        await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
                        return ConversationHandler.END
                    
                    alert_message = (
                        f"‚ö†Ô∏è *Abuso de Bot√≥n Detectado* ‚ö†Ô∏è\n"
                        f"üë§ *Usuario:* {username}\n"
                        f"üÜî *ID:* {user_id}\n"
                        f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
                        f"‚è∞ *Fecha y Hora:* {fecha_hora}\n"
                        f"üìä *Intento:* {attempt_count} (Total: {total_abuse_count})\n"
                        f"‚ö†Ô∏è *Advertencia:* {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                        f"Por favor respeta las peticiones ajenas. La mala fe o intento de sabotaje conllevan a la exclusi√≥n inmediata del grupo."
                    )
                    
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=chat_id,
                        text=alert_message,
                        parse_mode="Markdown"
                    )
                
                return ConversationHandler.END
    
    if data.startswith("encuesta_") and "_" in data and len(data.split("_")) > 2:
        # Manejar diferentes formatos de callback de encuesta
        parts = data.split("_")
        if len(parts) < 2:
            logger.warning(f"‚ö†Ô∏è Callback de encuesta malformado: {data}")
            return ConversationHandler.END
        
        # Verificar si es encuesta_cancel
        if parts[1] == "cancel":
            try:
                ticket_number = context.user_data.get("current_survey_ticket")
                if ticket_number and f"encuesta_msg_{ticket_number}" in context.bot_data:
                    msg_id = context.bot_data[f"encuesta_msg_{ticket_number}"]
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=chat_id,
                        message_id=msg_id
                    )
                    del context.bot_data[f"encuesta_msg_{ticket_number}"]
                else:
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=chat_id,
                        message_id=message_id
                    )
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è No se pudo eliminar mensaje de encuesta: {str(e)}")
            return ConversationHandler.END
        
        # Intentar parsear el ticket number
        try:
            ticket_number = int(parts[1])
        except ValueError:
            logger.warning(f"‚ö†Ô∏è Ticket number inv√°lido en callback: {data}")
            return ConversationHandler.END
        if not can_respond_to_survey(user_id, ticket_number) and user_id not in ADMINISTRATORS:
            attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number)

            # Verificar si debe ser expulsado por abuso de botones
            if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
                username_for_kick = query.from_user.username or f"User{user_id}"
                await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
                return ConversationHandler.END

            # Eliminar mensaje de penalizaci√≥n anterior
            last_message_id = get_last_penalty_message(user_id, chat_id, "encuesta_abuse")
            if last_message_id:
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=chat_id,
                    message_id=last_message_id
                )

            # Obtener informaci√≥n del canal/grupo para enviar en el thread correcto
            canal_info = CANALES_PETICIONES.get(chat_id)
            thread_id = canal_info.get('thread_id') if canal_info else None

            username_display = f"@{query.from_user.username}" if query.from_user.username else f"Usuario {user_id}"
            abuse_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                message_thread_id=thread_id,
                text=(
                    f"‚ö†Ô∏è *Acceso no autorizado* ‚ö†Ô∏è\n\n"
                    f"{username_display}, no puedes responder a esta encuesta porque no eres el due√±o de la solicitud.\n\n"
                    f"üìä **Intento:** {attempt_count}\n"
                    f"‚ö†Ô∏è **Advertencia:** {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                    f"Por favor, respeta las funcionalidades del bot.\n\n"
                    f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
                ),
                parse_mode="Markdown"
            )

            # Guardar el nuevo mensaje
            if abuse_message:
                save_penalty_message(user_id, chat_id, abuse_message.message_id, "encuesta_abuse")

            return ConversationHandler.END
    
    # Manejo del bot√≥n cancelar solicitud
    if data.startswith("cancelar_"):
        try:
            ticket_number = int(data.split("_")[1])
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para cancelar: {data}")
            await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
            return ConversationHandler.END

        if not can_use_request_buttons(user_id, ticket_number, "owner_only"):
            attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number)

            # Verificar si debe ser expulsado por abuso de botones
            if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
                username_for_kick = query.from_user.username or f"User{user_id}"
                await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
                return ConversationHandler.END

            # Eliminar mensaje de penalizaci√≥n anterior
            last_message_id = get_last_penalty_message(user_id, chat_id, "cancelar_abuse")
            if last_message_id and await _bot_can_delete_in(chat_id):
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=chat_id,
                    message_id=last_message_id
                )

            # Obtener informaci√≥n del canal/grupo para enviar en el thread correcto
            canal_info = CANALES_PETICIONES.get(chat_id)
            thread_id = canal_info.get('thread_id') if canal_info else None

            username_display = f"@{query.from_user.username}" if query.from_user.username else f"Usuario {user_id}"
            abuse_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                message_thread_id=thread_id,
                text=(
                    f"‚ö†Ô∏è *Sin permisos* ‚ö†Ô∏è\n\n"
                    f"{username_display}, solo puedes cancelar tus propias solicitudes.\n\n"
                    f"üìä **Intento:** {attempt_count}\n"
                    f"‚ö†Ô∏è **Advertencia:** {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                    f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
                ),
                parse_mode="Markdown"
            )

            # Guardar el nuevo mensaje
            if abuse_message:
                save_penalty_message(user_id, chat_id, abuse_message.message_id, "cancelar_abuse")

            return ConversationHandler.END

        peticion = get_peticion_registrada(ticket_number)
        if not peticion:
            await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=f"‚ùå *Error* ‚ùå\nLa solicitud #{ticket_number} no existe o ya fue procesada.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END

        # Eliminar de pendientes
        del_peticion_registrada(ticket_number)

        # Guardar en historial como cancelado
        gestion_dt = datetime.now(SPAIN_TZ)
        await set_historial_solicitud(ticket_number, {
            "chat_id": peticion["chat_id"],
            "username": peticion["username"],
            "user_id": peticion["user_id"],
            "message_text": peticion["message_text"],
            "chat_title": peticion["chat_title"],
            "estado": "cancelado",
            "fecha_gestion": gestion_dt,
            "admin_username": peticion["username"] if user_id == peticion["user_id"] else "Administrador",
            "reason": "Cancelado por el usuario" if user_id == peticion["user_id"] else "Cancelado por administrador",
            "has_attachment": peticion["has_attachment"],
            "photo_file_id": peticion["photo_file_id"]
        })

        # Ajustar contador del usuario si √©l mismo cancela
        if user_id == peticion["user_id"]:
            user_data = get_peticiones_por_usuario(user_id)
            if user_data and user_data["count"] > 0:
                new_count = user_data["count"] - 1
                set_peticiones_por_usuario(user_id, new_count, user_data["chat_id"], user_data["username"], user_data["last_reset"])

        # Borrar mensaje original y foto en el chat donde se public√≥ (si el bot puede borrar all√≠)
        target_chat_for_deletes = peticion.get("chat_id", chat_id)
        can_delete_here = await _bot_can_delete_in(target_chat_for_deletes)

        if peticion.get("message_id") and can_delete_here:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=target_chat_for_deletes,
                message_id=peticion["message_id"]
            )

        photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
        if photo_message_id and can_delete_here:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=target_chat_for_deletes,
                message_id=photo_message_id
            )
            del context.bot_data[f"photo_{ticket_number}"]

        # Eliminar mensaje de confirmaci√≥n del sistema
        await delete_confirmation_message(context, ticket_number)

        # Eliminar el mensaje con los botones (si el bot puede borrar en este chat)
        if await _bot_can_delete_in(chat_id):
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=query.message.message_id
            )

        # Confirmaci√≥n en el MISMO grupo/canal/topic donde se puls√≥ el bot√≥n
        origin_thread_id = getattr(query.message, "message_thread_id", None)
        username_escaped = escape_markdown(peticion["username"], preserve_username=True)
        confirmation_text = (
            f"‚úÖ *Solicitud #{ticket_number} cancelada exitosamente*\n"
            f"üë§ *Usuario:* {username_escaped}\n"
            f"‚è∞ *Fecha:* {gestion_dt.strftime('%d/%m/%Y %H:%M:%S')}"
        )
        send_kwargs = {
            "chat_id": chat_id,     # exactamente donde se cancel√≥
            "text": confirmation_text,
            "parse_mode": "Markdown"
        }
        if origin_thread_id:
            send_kwargs["message_thread_id"] = origin_thread_id  # topic correcto si es foro

        confirmation_message = await safe_bot_method(context.bot.send_message, **send_kwargs)

        if confirmation_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, confirmation_message.message_id, 120)
            )

        await query.answer("‚úÖ Solicitud cancelada en este canal", show_alert=False)
        logger.info(f"‚úÖ Solicitud #{ticket_number} cancelada por user_id={user_id} en chat_id={chat_id}")
        return ConversationHandler.END

    # Verificar abuso de botones (excluir botones del men√∫ de usuario y botones permitidos)
    if user_id not in ADMINISTRATORS and not data.startswith(("estado_", "contactar_admin_", "ticket_", "encuesta_", "satisfaccion_", "vote_", "cancelar_", "canjear_puntos_", "confirm_canje_", "volver_solicitud_", "user_menu_", "user_view_", "user_confirm_", "user_redeem_", "confirm_suggestion_", "edit_suggestion_", "confirm_contact_admin_", "edit_contact_admin_")):
        # Solo registrar abuso si 'data' parece un ticket_number num√©rico
        try:
            ticket_number_for_abuse = int(data) if data.isdigit() else int(data.split("_")[1])
            attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number_for_abuse)
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è No se pudo extraer ticket_number de data='{data}' para registro de abuso, ignorando...")
            return ConversationHandler.END

        # Verificar si debe ser expulsado por abuso de botones
        if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
            username_for_kick = query.from_user.username or f"User{user_id}"
            await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
            return ConversationHandler.END

        # Eliminar mensaje de penalizaci√≥n anterior
        last_message_id = get_last_penalty_message(user_id, chat_id, "general_abuse")
        if last_message_id and await _bot_can_delete_in(chat_id):
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=last_message_id
            )

        # Obtener informaci√≥n del canal/grupo para enviar en el thread correcto
        canal_info = CANALES_PETICIONES.get(chat_id)
        thread_id = canal_info.get('thread_id') if canal_info else None

        username_display = f"@{query.from_user.username}" if query.from_user.username else f"Usuario {user_id}"
        abuse_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            message_thread_id=thread_id,
            text=(
                f"‚ö†Ô∏è *Acceso No Autorizado* ‚ö†Ô∏è\n\n"
                f"{username_display}, no tienes permiso para esta acci√≥n.\n\n"
                f"üìä **Intento:** {attempt_count}\n"
                f"‚ö†Ô∏è **Advertencia:** {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                f"Por favor, respeta las funcionalidades del bot.\n\n"
                f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
            ),
            parse_mode="Markdown"
        )

        # Guardar el nuevo mensaje
        if abuse_message:
            save_penalty_message(user_id, chat_id, abuse_message.message_id, "general_abuse")
        
        # Notificar al desarrollador sobre abuso
        await safe_bot_method(
            application.bot.send_message,
            chat_id=DEVELOPER_CHAT_ID,
            text=(
                f"üö® *Abuso de Bot√≥n Detectado* üö®\n\n"
                f"üë§ *Usuario:* @{query.from_user.username}\n"
                f"üÜî *User ID:* {user_id}\n"
                f"üìç *Chat ID:* {chat_id}\n"
                f"üìä *Intento:* {attempt_count} (Total: {total_abuse_count})\n"
                f"‚ö†Ô∏è *Estado:* {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n"
                f"‚è∞ *Timestamp:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
            ),
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    # Verificar abuso de botones (excluir botones del men√∫ de usuario y botones permitidos)
    if user_id not in ADMINISTRATORS and not data.startswith(("estado_", "contactar_admin_", "ticket_", "encuesta_", "satisfaccion_", "vote_", "cancelar_", "canjear_puntos_", "confirm_canje_", "volver_solicitud_", "user_menu_", "user_view_", "user_confirm_", "user_redeem_", "confirm_suggestion_", "edit_suggestion_", "confirm_contact_admin_", "edit_contact_admin_")):
        # Solo registrar abuso si 'data' parece un ticket_number num√©rico
        try:
            ticket_number_for_abuse = int(data) if data.isdigit() else int(data.split("_")[1])
            attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number_for_abuse)
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è No se pudo extraer ticket_number de data='{data}' para registro de abuso, ignorando...")
            return ConversationHandler.END

        # Verificar si debe ser expulsado por abuso de botones
        if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
            username_for_kick = query.from_user.username or f"User{user_id}"
            await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
            return ConversationHandler.END

        # Eliminar mensaje de penalizaci√≥n anterior
        last_message_id = get_last_penalty_message(user_id, chat_id, "general_abuse")
        if last_message_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=last_message_id
            )

        # Obtener informaci√≥n del canal/grupo para enviar en el thread correcto
        canal_info = CANALES_PETICIONES.get(chat_id)
        thread_id = canal_info.get('thread_id') if canal_info else None

        username_display = f"@{query.from_user.username}" if query.from_user.username else f"Usuario {user_id}"
        abuse_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            message_thread_id=thread_id,
            text=(
                f"‚ö†Ô∏è *Acceso No Autorizado* ‚ö†Ô∏è\n\n"
                f"{username_display}, no tienes permiso para esta acci√≥n.\n\n"
                f"üìä **Intento:** {attempt_count}\n"
                f"‚ö†Ô∏è **Advertencia:** {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                f"Por favor, respeta las funcionalidades del bot.\n\n"
                f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
            ),
            parse_mode="Markdown"
        )

        # Guardar el nuevo mensaje
        if abuse_message:
            save_penalty_message(user_id, chat_id, abuse_message.message_id, "general_abuse")
        
        # Notificar al desarrollador sobre abuso
        await safe_bot_method(
            application.bot.send_message,
            chat_id=DEVELOPER_CHAT_ID,
            text=(
                f"üö® *Abuso de Bot√≥n Detectado* üö®\n\n"
                f"üë§ *Usuario:* @{query.from_user.username}\n"
                f"üÜî *User ID:* {user_id}\n"
                f"üìç *Chat ID:* {chat_id}\n"
                f"üìä *Intento:* {attempt_count} (Total: {total_abuse_count})\n"
                f"‚ö†Ô∏è *Estado:* {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n"
                f"‚è∞ *Timestamp:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"*Sistema de Seguridad EntresHijos* üõ°Ô∏è"
            ),
            parse_mode="Markdown"
        )
        return ConversationHandler.END


    # Verificar si el men√∫ est√° activo (excepto para botones de usuario y otros botones permitidos)
    if (chat_id, message_id) not in menu_activos and not data.startswith(("estado_", "contactar_admin_", "ticket_", "encuesta_", "satisfaccion_", "vote_", "cancelar_", "canjear_puntos_", "confirm_canje_", "volver_solicitud_", "canjear_recompensa_", "confirmar_autocanje_", "user_menu_", "user_view_", "user_confirm_", "user_redeem_", "confirm_suggestion_", "edit_suggestion_", "confirm_contact_admin_", "edit_contact_admin_", "confirm_alerta_", "edit_alerta_", "contact_", "contact_view_", "contact_respond_", "contact_confirm_response_", "contact_edit_response_", "contact_close_", "contact_reopen_", "contact_block_user_", "contact_confirm_block_", "menu_contact_list")):
        valid_callbacks = [
            "menu_principal", "menu_gestion", "menu_estadisticas", "menu_configuracion", "menu_herramientas", "menu_mantenimiento", "menu_puntos",
            "detailed_stats", "view_maintenance_msg", "view_maintenance_schedule", "satisfaction_report", "system_logs",
            "resource_usage", "auto_cleanup", "restart_services", "notification_config", "enable_notifications",
            "puntos_top_usuarios", "puntos_estadisticas", "puntos_recompensas", "puntos_transacciones", "puntos_dar_puntos",
            "disable_notifications", "view_schedule", "menu_grupos", "menu_tiempo", "search_user", "cancel_search",
            "menu_ping", "clear_cache", "menu_pendientes", "menu_recuperar", "menu_votacion", "menu_masiva", "voting_stats",
            "maintenance_config", "activate_maintenance", "deactivate_maintenance", "suspicious_activity",
            "menu_restar", "edit_days", "reset_schedule", "confirm_days", "save_schedule", "cancel_schedule",
            "schedule_maintenance", "program_maintenance", "duplicate_config",
            "manual_survey_reminder", "send_manual_reminders", "menu_close", "menu_suggestions_list",
            "suggestions_pendientes", "suggestions_revisadas", "suggestions_todas", "menu_contact_list"
        ]
        
        if data in valid_callbacks:
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": "",
                "message_markup": None,
                "last_page": 1
            }
            logger.info(f"‚úÖ Men√∫ reactivado para chat_id={chat_id}, message_id={message_id}")
        else:
            await safe_bot_method(
                query.edit_message_text,
                text="‚ùå *Men√∫ expirado* ‚ùå\nPor favor, usa /menu para abrir un nuevo men√∫.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        if data not in valid_callbacks and not any(data.startswith(prefix) for prefix in ["toggle_grupo_", "confirm_grupo_", "pend_", "day_", "vote_", "encuesta_", "show_votes_", "toggle_select_", "batch_", "clear_selection", "select_all_batch", "deselect_all_batch", "noop", "restore_request_", "ver_historial_", "canjear_puntos_", "confirm_canje_", "user_menu_", "user_view_", "user_confirm_", "user_redeem_", "confirm_alerta_", "edit_alerta_", "confirm_suggestion_", "edit_suggestion_", "confirm_contact_admin_", "edit_contact_admin_", "contact_view_", "contact_respond_", "contact_confirm_response_", "contact_edit_response_", "contact_close_", "contact_reopen_", "contact_block_user_", "contact_confirm_block_", "menu_contact_list_"]):
            if not data.startswith(("historial_page_", "user_details_", "user_pending_", "user_history_", "user_manage_", "user_action_", "user_restore_", "user_reduce_", "user_reset_", "user_detailed_stats_", "manage_incorrect_", "manage_abuse_", "view_incorrect_", "view_abuse_", "clear_user_", "reduce_", "reset_today_", "warn_user_", "manage_user_infractions_", "clear_all_user_infractions_")):
                logger.warning(f"‚ö†Ô∏è Callback data no reconocido: {data} por @{query.from_user.username}")
                return ConversationHandler.END
        
        if data in valid_callbacks:
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": "",
                "message_markup": None,
                "last_page": 1
            }
            logger.info(f"‚úÖ Men√∫ reactivado para callback v√°lido: {data}")

    if (chat_id, message_id) in menu_activos:
        menu_activos[(chat_id, message_id)]["last_activity"] = datetime.now(SPAIN_TZ)

    # GESTI√ìN DE SOLICITUDES CON ELIMINACI√ìN MEJORADA
    if data.startswith("pend_") and "_eliminar_with_reason" in data:
        parts = data.split("_")
        ticket = int(parts[1])
        page = int(parts[2])
        
        return await handle_eliminar_solicitud_with_reason(update, context, ticket, page, chat_id, message_id)

    if data.startswith("pend_") and "_subido_link" in data:
        parts = data.split("_")
        ticket = int(parts[1])
        page = int(parts[2])
        
        info = get_peticion_registrada(ticket)
        if not info:
            await safe_bot_method(
                query.edit_message_text,
                text=f"‚ùå *Error* ‚ùå\nEl Ticket #{ticket} no se encuentra disponible.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        set_admin_waiting_response(user_id, chat_id, "link", ticket, {
            "peticion": info,
            "page": page,
            "menu_message_id": message_id
        })
        
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=(
                f"üîó *Aprobar Solicitud #{ticket} con Enlace* üîó\n\n"
                f"üë§ *Usuario:* {escape_markdown(info['username'], preserve_username=True)}\n"
                f"‚úâÔ∏è *Mensaje:* {escape_markdown(info['message_text'])}\n"
                f"üìç *Grupo:* {escape_markdown(info['chat_title'])}\n\n"
                f"üìù *Por favor, escribe el enlace de Telegram para esta solicitud:*"
            ),
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            admin_waiting_responses[f"{user_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
        
        logger.info(f"‚úÖ Solicitado enlace para ticket #{ticket} por admin {user_id}")
        return ConversationHandler.END
    
    if data.startswith("pend_") and "_denegado" in data:
        parts = data.split("_")
        ticket = int(parts[1])
        page = int(parts[2])
        
        info = get_peticion_registrada(ticket)
        if not info:
            await safe_bot_method(
                query.edit_message_text,
                text=f"‚ùå *Error* ‚ùå\nEl Ticket #{ticket} no se encuentra disponible.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        set_admin_waiting_response(user_id, chat_id, "reason", ticket, {
            "peticion": info,
            "page": page,
            "menu_message_id": message_id
        })
        
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=(
                f"‚ùå *Denegar Solicitud #{ticket}* ‚ùå\n\n"
                f"üë§ *Usuario:* {escape_markdown(info['username'], preserve_username=True)}\n"
                f"‚úâÔ∏è *Mensaje:* {escape_markdown(info['message_text'])}\n"
                f"üìç *Grupo:* {escape_markdown(info['chat_title'])}\n\n"
                f"üìù *Por favor, escribe el motivo de la denegaci√≥n:*"
            ),
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            admin_waiting_responses[f"{user_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
        
        logger.info(f"‚úÖ Solicitado motivo para denegar ticket #{ticket} por admin {user_id}")
        return ConversationHandler.END

    # Manejar callbacks de duplicados
    if data.startswith("continue_duplicate_"):
        ticket_number = int(data.split("_")[2])
        
        # Recuperar solicitud pendiente
        pending_request = context.bot_data.get(f"pending_request_{ticket_number}")
        if not pending_request:
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END
        
        # Eliminar advertencia de duplicados
        duplicate_warning = context.bot_data.get(f"duplicate_warning_{ticket_number}")
        if duplicate_warning:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=duplicate_warning["message_id"] // 1000000,  # Extraer chat_id del message_id
                message_id=duplicate_warning["message_id"]
            )
            del context.bot_data[f"duplicate_warning_{ticket_number}"]
        
        # Procesar la solicitud normalmente
        chat_id = pending_request["chat_id"]
        username = pending_request["username"]
        user_id = pending_request["user_id"]
        request_text = pending_request["message_text"]
        timestamp = pending_request["timestamp"]
        chat_title = pending_request["chat_title"]
        thread_id = pending_request["thread_id"]
        has_attachment = pending_request["has_attachment"]
        photo_file_id = pending_request["photo_file_id"]
        user_data = pending_request["user_data"]
        
        # Incrementar contador de usuario
        new_count = user_data["count"] + 1
        set_peticiones_por_usuario(user_id, new_count, chat_id, username, user_data["last_reset"])
        
        # Registrar la solicitud
        set_peticion_registrada(ticket_number, {
            "chat_id": chat_id,
            "username": username,
            "user_id": user_id,
            "message_text": request_text,
            "message_id": None,
            "timestamp": timestamp,
            "chat_title": chat_title,
            "thread_id": thread_id,
            "has_attachment": has_attachment,
            "photo_file_id": photo_file_id
        })
        
        # Enviar al grupo de administradores
        username_escaped = escape_markdown(username, preserve_username=True)
        chat_title_escaped = escape_markdown(chat_title)
        message_text_escaped = escape_markdown(request_text)
        timestamp_str = timestamp.strftime("%d/%m/%Y %H:%M:%S")
        
        destino_message = (
            f"üì© *Nueva solicitud recibida* ‚úÖ\n"
            f"üë§ *Usuario:* {username_escaped} (ID: {user_id})\n"
            f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
            f"üìä *Petici√≥n:* {new_count}/2\n"
            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
            f"üìç *Grupo:* {chat_title_escaped}\n"
            f"‚è∞ *Fecha:* {timestamp_str}\n"
            f"üìé *Adjunto:* {'S√≠' if has_attachment else 'No'}\n"
            f"‚ö†Ô∏è *Nota:* Usuario decidi√≥ continuar a pesar de duplicados detectados\n"
            f"ü§ù *Bot de Entreshijos*"
        )
        
        sent_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=destino_message,
            parse_mode="Markdown"
        )
        
        if sent_message:
            # Actualizar con el message_id
            set_peticion_registrada(ticket_number, {
                "chat_id": chat_id,
                "username": username,
                "user_id": user_id,
                "message_text": request_text,
                "message_id": sent_message.message_id,
                "timestamp": timestamp,
                "chat_title": chat_title,
                "thread_id": thread_id,
                "has_attachment": has_attachment,
                "photo_file_id": photo_file_id
            })
        
        # Enviar imagen si existe
        if has_attachment and photo_file_id:
            photo_message = await safe_bot_method(
                context.bot.send_photo,
                chat_id=GROUP_DESTINO,
                photo=photo_file_id,
                caption=f"üì∏ *Imagen adjunta para solicitud #{ticket_number}*",
                parse_mode="Markdown"
            )
            if photo_message:
                context.bot_data[f"photo_{ticket_number}"] = photo_message.message_id
        
        # Enviar mensaje de confirmaci√≥n
        canal_info = CANALES_PETICIONES.get(chat_id, {"chat_id": chat_id, "thread_id": thread_id})
        votes = get_votes_summary(ticket_number)
        vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else "\nüó≥Ô∏è *Votos:* +0 / -0"
        
        try:
            bot_info = await context.bot.get_me()
            bot_username = bot_info.username
        except Exception:
            bot_username = "EntresHijosBot"
        
        confirmacion_message = generar_mensaje_confirmacion_solicitud(
            username_escaped, ticket_number, user_id, chat_title_escaped,
            timestamp_str, message_text_escaped, has_attachment,
            new_count, vote_text, bot_username, username
        )

        keyboard = generar_teclado_confirmacion_solicitud(ticket_number, user_id)
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        confirmacion_sent = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=confirmacion_message,
            message_thread_id=canal_info["thread_id"],
            parse_mode="Markdown",
            reply_markup=reply_markup
        )
        
        if confirmacion_sent:
            save_confirmation_message(ticket_number, canal_info["chat_id"], confirmacion_sent.message_id, user_id)
        
        # Limpiar datos temporales
        del context.bot_data[f"pending_request_{ticket_number}"]
        
        logger.info(f"‚úÖ Solicitud #{ticket_number} procesada despu√©s de continuar con duplicados")
        return ConversationHandler.END
    
    if data.startswith("cancel_duplicate_"):
        ticket_number = int(data.split("_")[2])
        
        # Eliminar advertencia de duplicados
        duplicate_warning = context.bot_data.get(f"duplicate_warning_{ticket_number}")
        if duplicate_warning:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=duplicate_warning["message_id"] // 1000000,  # Extraer chat_id del message_id
                message_id=duplicate_warning["message_id"]
            )
            del context.bot_data[f"duplicate_warning_{ticket_number}"]
        
        # Limpiar datos temporales
        if f"pending_request_{ticket_number}" in context.bot_data:
            del context.bot_data[f"pending_request_{ticket_number}"]
        
        logger.info(f"‚úÖ Solicitud #{ticket_number} cancelada por duplicados")
        return ConversationHandler.END
    
    if data.startswith("view_duplicate_"):
        parts = data.split("_")
        duplicate_ticket = int(parts[2])
        original_ticket = int(parts[3])
        
        # Mostrar detalles del duplicado
        duplicate_info = get_peticion_registrada(duplicate_ticket) or get_historial_solicitud(duplicate_ticket)
        
        if duplicate_info:
            estado = "Pendiente" if get_peticion_registrada(duplicate_ticket) else duplicate_info.get("estado", "Desconocido").capitalize()
            fecha = duplicate_info.get("timestamp") or duplicate_info.get("fecha_gestion")
            fecha_str = fecha.strftime("%d/%m/%Y %H:%M:%S") if fecha else "Fecha desconocida"
            
            texto = (
                f"üîç *Detalles del Duplicado #{duplicate_ticket}* üîç\n\n"
                f"üìä *Estado:* {estado}\n"
                f"üë§ *Usuario:* {escape_markdown(duplicate_info['username'], preserve_username=True)}\n"
                f"‚úâÔ∏è *Mensaje:* {escape_markdown(duplicate_info['message_text'])}\n"
                f"üìç *Grupo:* {escape_markdown(duplicate_info['chat_title'])}\n"
                f"‚è∞ *Fecha:* {fecha_str}\n"
                f"üìé *Adjunto:* {'S√≠' if duplicate_info.get('has_attachment') else 'No'}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver a Advertencia", callback_data=f"back_to_duplicate_{original_ticket}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        else:
            await query.answer("‚ùå Duplicado no encontrado", show_alert=True)
        
        return ConversationHandler.END
    
    if data.startswith("back_to_duplicate_"):
        ticket_number = int(data.split("_")[3])
        
        # Recuperar informaci√≥n de la advertencia original
        duplicate_warning = context.bot_data.get(f"duplicate_warning_{ticket_number}")
        if duplicate_warning:
            duplicates = duplicate_warning["duplicates"]
            username = duplicate_warning["username"]
            message_text = duplicate_warning["message_text"]
            
            # Recrear la advertencia original
            username_escaped = escape_markdown(username, preserve_username=True)
            message_text_escaped = escape_markdown(message_text[:100] + "..." if len(message_text) > 100 else message_text)
            
            duplicates_text = ""
            keyboard = []
            
            for i, dup in enumerate(duplicates[:3], 1):
                estado_emoji = {
                    "pendiente": "‚è≥",
                    "subido": "‚úÖ",
                    "denegado": "‚ùå",
                    "eliminado": "üóëÔ∏è",
                    "cancelado": "üîÑ"
                }.get(dup["estado"].lower(), "üìã")
                
                similarity_percent = int(dup["similarity"] * 100)
                timestamp_str = dup["timestamp"].strftime("%d/%m %H:%M")
                dup_text_preview = dup["message_text"][:50] + "..." if len(dup["message_text"]) > 50 else dup["message_text"]
                
                duplicates_text += (
                    f"**{i}. {estado_emoji} Ticket #{dup['ticket_number']}** ({similarity_percent}% similar)\n"
                    f"   üìù {escape_markdown(dup_text_preview)}\n"
                    f"   üìç {escape_markdown(dup['chat_title'])}\n"
                    f"   ‚è∞ {timestamp_str}\n\n"
                )
                
                keyboard.append([
                    InlineKeyboardButton(
                        f"üìã Ver #{dup['ticket_number']} ({similarity_percent}%)",
                        callback_data=f"view_duplicate_{dup['ticket_number']}_{ticket_number}"
                    )
                ])
            
            keyboard.append([
                InlineKeyboardButton("‚úÖ Continuar Anyway", callback_data=f"continue_duplicate_{ticket_number}"),
                InlineKeyboardButton("‚ùå Cancelar Nueva", callback_data=f"cancel_duplicate_{ticket_number}")
            ])
            
            warning_text = (
                f"‚ö†Ô∏è *Posibles Solicitudes Duplicadas Detectadas* ‚ö†Ô∏è\n\n"
                f"Hola {username_escaped}, hemos detectado que tienes solicitudes similares recientes:\n\n"
                f"üìù **Tu nueva solicitud:**\n"
                f"‚úâÔ∏è {message_text_escaped}\n\n"
                f"üîç **Solicitudes similares encontradas:**\n\n"
                f"{duplicates_text}"
                f"üí° **¬øQu√© deseas hacer?**\n"
                f"‚Ä¢ **Continuar:** Si es diferente a las anteriores\n"
                f"‚Ä¢ **Cancelar:** Si es igual a alguna existente\n\n"
                f"ü§ù *Sistema de Calidad EntresHijos* üõ°Ô∏è"
            )
            
            await safe_bot_method(
                query.edit_message_text,
                text=warning_text,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )
        else:
            await query.answer("‚ùå Advertencia no encontrada", show_alert=True)
        
        return ConversationHandler.END

    # Men√∫s de usuario interactivos mejorados
    # Volver al mensaje de confirmaci√≥n de solicitud
    if data.startswith("volver_solicitud_"):
        logger.info(f"üîô Intentando volver a solicitud: callback={data}, user_id={user_id}")
        parts = data.split("_")
        try:
            ticket_number = int(parts[2])
            target_user_id = int(parts[3])
            logger.info(f"üîç Parseado - ticket: {ticket_number}, target_user: {target_user_id}, current_user: {user_id}")
        except (ValueError, IndexError) as e:
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para volver_solicitud: {data}, error: {str(e)}")
            await query.answer("‚ùå Error al volver a la solicitud", show_alert=True)
            return ConversationHandler.END

        # Verificar que es el usuario correcto o un administrador
        if user_id != target_user_id and user_id not in ADMINISTRATORS:
            logger.warning(f"‚ö†Ô∏è Usuario {user_id} intent√≥ ver solicitud de {target_user_id}")
            await query.answer("‚ö†Ô∏è Solo puedes ver tus propias solicitudes", show_alert=True)
            return ConversationHandler.END

        peticion = get_peticion_registrada(ticket_number)
        if not peticion:
            logger.warning(f"‚ö†Ô∏è Solicitud #{ticket_number} no encontrada")
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END

        logger.info(f"‚úÖ Petici√≥n encontrada: ticket #{ticket_number}, user: {peticion['username']}")

        # Regenerar mensaje de confirmaci√≥n
        votes = get_votes_summary(ticket_number)
        vote_display = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else "\nüó≥Ô∏è *Votos:* +0 / -0"

        username_escaped = escape_markdown(peticion["username"], preserve_username=True)
        chat_title_escaped = escape_markdown(peticion["chat_title"])
        message_text_escaped = escape_markdown(peticion["message_text"])
        timestamp_str = peticion["timestamp"].strftime("%d/%m/%Y %H:%M:%S")

        user_data = get_peticiones_por_usuario(peticion["user_id"])
        user_count = user_data["count"] if user_data else 1

        try:
            bot_info = await context.bot.get_me()
            bot_username = bot_info.username
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo info del bot: {str(e)}")
            bot_username = "EntresHijosBot"

        confirmacion_message = generar_mensaje_confirmacion_solicitud(
            username_escaped, ticket_number, peticion['user_id'], chat_title_escaped,
            timestamp_str, message_text_escaped, peticion['has_attachment'],
            user_count, vote_display, bot_username, peticion['username']
        )

        keyboard = generar_teclado_confirmacion_solicitud(ticket_number, peticion['user_id'])
        reply_markup = InlineKeyboardMarkup(keyboard)

        success = await safe_bot_method(
            query.edit_message_text,
            text=confirmacion_message,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        if success:
            logger.info(f"‚úÖ Usuario {user_id} volvi√≥ exitosamente a la solicitud #{ticket_number}")
        else:
            logger.error(f"‚ùå Error al editar mensaje para volver a solicitud #{ticket_number}")

        return ConversationHandler.END

    if data.startswith("estado_"):
        try:
            ticket_number = int(data.split("_")[1])
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para estado: {data}")
            await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
            return ConversationHandler.END
        return await handle_user_menu_estado(update, context, ticket_number, "main")

    if data.startswith("ticket_") and "_estado" in data:
        try:
            ticket_number = int(data.split("_")[1])
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para ticket_estado: {data}")
            await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
            return ConversationHandler.END
        return await handle_user_menu_estado(update, context, ticket_number, "details")

    if data.startswith("vote_"):
        parts = data.split("_")
        try:
            ticket_number = int(parts[1])
            vote_value = int(parts[2])
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para vote: {data}")
            await query.answer("‚ùå Error en el formato del voto", show_alert=True)
            return ConversationHandler.END

        add_vote(ticket_number, user_id, vote_value)
        vote_text = "positivo" if vote_value == 1 else "negativo"

        confirmacion_message_id = context.bot_data.get(f"confirmacion_{ticket_number}")
        if confirmacion_message_id:
            peticion = get_peticion_registrada(ticket_number)
            if peticion:
                votes = get_votes_summary(ticket_number)
                vote_display = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}"

                username_escaped = escape_markdown(peticion["username"], preserve_username=True)
                chat_title_escaped = escape_markdown(peticion["chat_title"])
                message_text_escaped = escape_markdown(peticion["message_text"])
                timestamp_str = peticion["timestamp"].strftime("%d/%m/%Y %H:%M:%S")

                user_data = get_peticiones_por_usuario(peticion["user_id"])
                user_count = user_data["count"] if user_data else 1

                bot_info = await context.bot.get_me()
                bot_username = bot_info.username

                confirmacion_message_updated = generar_mensaje_confirmacion_solicitud(
                    username_escaped, ticket_number, peticion['user_id'], chat_title_escaped,
                    timestamp_str, message_text_escaped, peticion['has_attachment'],
                    user_count, vote_display, bot_username, peticion['username']
                )

                keyboard = generar_teclado_confirmacion_solicitud(ticket_number, peticion['user_id'])
                reply_markup = InlineKeyboardMarkup(keyboard)

                canal_info = None
                for grupo_chat_id, canal_data in CANALES_PETICIONES.items():
                    if peticion["chat_id"] == grupo_chat_id:
                        canal_info = canal_data
                        break

                if canal_info:
                    await safe_bot_method(
                        context.bot.edit_message_text,
                        chat_id=canal_info["chat_id"],
                        message_id=confirmacion_message_id,
                        text=confirmacion_message_updated,
                        reply_markup=reply_markup,
                        parse_mode="Markdown"
                    )

        await safe_bot_method(query.answer, text=f"‚úÖ Voto {vote_text} registrado para solicitud #{ticket_number}")

        logger.info(f"‚úÖ Voto {vote_text} registrado para ticket #{ticket_number} por user_id={user_id}")
        return ConversationHandler.END

    if data.startswith("contactar_admin_"):
        try:
            parts = data.split("_")
            if len(parts) >= 3 and parts[2].isdigit():
                ticket_number = int(parts[2])
            else:
                logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para contactar_admin: {data}")
                await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
                return ConversationHandler.END
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para contactar_admin: {data}")
            await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
            return ConversationHandler.END
        
        texto = (
            f"üìû *Contactar Administrador* üìû\n"
            f"Para dudas sobre la solicitud #{ticket_number}, contacta con @admin."
        )
        contact_message = await safe_bot_method(
            query.message.reply_text,
            text=texto,
            parse_mode="Markdown"
        )

        if contact_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, contact_message.message_id, 60)
            )

        logger.info(f"‚úÖ Contactar admin para ticket #{ticket_number} solicitado por @{query.from_user.username}")
        return None

    if data.startswith("encuesta_"):
        try:
            ticket_number = int(data.split("_")[1])
        except (ValueError, IndexError):
            logger.warning(f"‚ö†Ô∏è Callback data inv√°lido para encuesta: {data}")
            await query.answer("‚ùå Error en el formato del ticket", show_alert=True)
            return ConversationHandler.END

        if len(data.split("_")) == 2:
            historial = get_historial_solicitud(ticket_number)
            if not historial or historial["estado"].lower() != "subido":
                await safe_bot_method(
                    query.message.reply_text,
                    text=f"‚ùå *Error* ‚ùå\nLa solicitud #{ticket_number} no est√° disponible para encuesta.",
                    parse_mode="Markdown"
                )
                return ConversationHandler.END

            if not can_respond_to_survey(user_id, ticket_number) and user_id not in ADMINISTRATORS:
                username = f"@{query.from_user.username}" if query.from_user.username else f"ID: {user_id}"
                fecha_hora = datetime.now(SPAIN_TZ).strftime("%d/%m/%Y %H:%M:%S")

                attempt_count, total_abuse_count = add_abuso_boton(user_id, chat_id, ticket_number)
                
                # Verificar si debe ser expulsado por abuso de botones
                if total_abuse_count >= MAX_BUTTON_ABUSE_ATTEMPTS:
                    username_for_kick = query.from_user.username or f"User{user_id}"
                    await kick_user_for_button_abuse(context, user_id, chat_id, username_for_kick, total_abuse_count)
                    return ConversationHandler.END

                await safe_bot_method(
                    query.message.reply_text,
                    text=(
                        f"‚ùå *Acceso denegado* ‚ùå\n"
                        f"Solo el usuario que realiz√≥ la solicitud puede responder a esta encuesta.\n\n"
                        f"üìã *Detalles del intento no autorizado:*\n"
                        f"üë§ *Usuario:* {escape_markdown(username, preserve_username=True)}\n"
                        f"üÜî *ID:* {user_id}\n"
                        f"‚è∞ *Fecha y Hora:* {fecha_hora}\n"
                        f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
                        f"üìä *Intento:* {attempt_count} (Total: {total_abuse_count})\n"
                        f"‚ö†Ô∏è *Advertencia:* {MAX_BUTTON_ABUSE_ATTEMPTS - total_abuse_count} intentos restantes antes de expulsi√≥n\n\n"
                        f"Por favor respeta las peticiones ajenas. La mala fe o intento de sabotaje conllevan a la exclusi√≥n inmediata del grupo."
                    ),
                    parse_mode="Markdown"
                )
                return ConversationHandler.END

            texto = (
                f"üòä *Encuesta de Satisfacci√≥n* üòä\n"
                f"Por favor, califica tu experiencia con la solicitud #{ticket_number}:"
            )
            keyboard = [
                [InlineKeyboardButton("‚≠ê Excelente", callback_data=f"encuesta_{ticket_number}_excelente"),
                 InlineKeyboardButton("üëç Bueno", callback_data=f"encuesta_{ticket_number}_bueno")],
                [InlineKeyboardButton("üëå Regular", callback_data=f"encuesta_{ticket_number}_regular"),
                 InlineKeyboardButton("üëé Malo", callback_data=f"encuesta_{ticket_number}_malo")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data=f"encuesta_cancel")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            try:
                await safe_bot_method(
                    query.edit_message_text,
                    text=texto,
                    reply_markup=reply_markup,
                    parse_mode="Markdown"
                )
                context.bot_data[f"encuesta_msg_{ticket_number}"] = message_id
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è No se pudo editar el mensaje para encuesta: {str(e)}")
                encuesta_message = await safe_bot_method(
                    context.bot.send_message,
                    chat_id=chat_id,
                    text=texto,
                    reply_markup=reply_markup,
                    parse_mode="Markdown"
                )

                if encuesta_message:
                    context.bot_data[f"encuesta_msg_{ticket_number}"] = encuesta_message.message_id
                    context.application.create_task(
                        auto_delete_message(context, chat_id, encuesta_message.message_id, 900)
                    )

            logger.info(f"‚úÖ Encuesta iniciada para ticket #{ticket_number} por @{query.from_user.username}")
            return ConversationHandler.END

        # Verificar que tenemos suficientes partes para la satisfacci√≥n
        if len(data.split("_")) < 3:
            logger.warning(f"‚ö†Ô∏è Callback de satisfacci√≥n malformado: {data}")
            return ConversationHandler.END

        satisfaccion = data.split("_")[2]
        await save_encuesta_satisfaccion(ticket_number, user_id, chat_id, satisfaccion, context)

        texto = (
            f"‚úÖ *Encuesta Registrada* ‚úÖ\n"
            f"Gracias por tu feedback sobre la solicitud #{ticket_number}!\n"
            f"Tu opini√≥n nos ayuda a mejorar el servicio. üôè"
        )

        try:
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                parse_mode="Markdown"
            )
            if f"encuesta_msg_{ticket_number}" in context.bot_data:
                context.application.create_task(
                    auto_delete_message(context, chat_id, context.bot_data[f"encuesta_msg_{ticket_number}"], 5)
                )
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo editar el mensaje para confirmaci√≥n de encuesta: {str(e)}")
            encuesta_result_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=texto,
                parse_mode="Markdown"
            )

            if encuesta_result_message:
                context.application.create_task(
                    auto_delete_message(context, chat_id, encuesta_result_message.message_id, 5)
                )

        logger.info(f"‚úÖ Encuesta {satisfaccion} registrada para ticket #{ticket_number} por @{query.from_user.username}")
        return ConversationHandler.END

    # Handler para bot√≥n "Gestionado ‚úÖ"
    if data.startswith("gestionado_"):
        if user_id not in ADMINISTRATORS:
            await query.answer("‚ùå Solo administradores pueden usar este bot√≥n", show_alert=True)
            return ConversationHandler.END

        # Eliminar el mensaje
        await safe_bot_method(query.delete_message)
        logger.info(f"‚úÖ Mensaje de notificaci√≥n gestionado y eliminado por admin user_id={user_id}, tipo={data}")
        return ConversationHandler.END

    # Men√∫s principales reorganizados
    if data == "menu_close":
        await safe_bot_method(query.delete_message)
        if (chat_id, message_id) in menu_activos:
            del menu_activos[(chat_id, message_id)]
        logger.info(f"‚úÖ Men√∫ cerrado por user_id={user_id}")
        return ConversationHandler.END

    if data == "menu_principal":
        keyboard = [
            [InlineKeyboardButton("üìã Gesti√≥n de Solicitudes", callback_data="menu_gestion"),
             InlineKeyboardButton("üìä Estad√≠sticas y Reportes", callback_data="menu_estadisticas")],
            [InlineKeyboardButton("‚öôÔ∏è Configuraci√≥n del Bot", callback_data="menu_configuracion"),
             InlineKeyboardButton("üõ†Ô∏è Herramientas Admin", callback_data="menu_herramientas")],
            [InlineKeyboardButton("üîß Mantenimiento", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("üí∞ Sistema de Puntos", callback_data="menu_puntos")],
            [InlineKeyboardButton("‚ùå Cerrar Panel", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"üéõÔ∏è *Panel de Administraci√≥n EntresHijos* üéõÔ∏è\n"
            f"üë§ *Administrador:* @{query.from_user.username}\n"
            f"üìÖ *Fecha:* {get_spain_time()}\n\n"
            f"Selecciona una categor√≠a para gestionar el bot:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Gesti√≥n de Solicitudes
    if data == "menu_gestion":
        # Mostrar animaci√≥n de carga
        await show_loading_animation(query, "üìã *Cargando Gesti√≥n de Solicitudes*", "loading")

        # Obtener estad√≠sticas r√°pidas
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                    total_pendientes = c.fetchone()[0]
                    c.execute("SELECT COUNT(*) FROM historial_solicitudes")
                    total_historial = c.fetchone()[0]
        except Exception as e:
            logger.error(f"Error obteniendo estad√≠sticas de gesti√≥n: {str(e)}")
            total_pendientes = 0
            total_historial = 0

        keyboard = [
            [InlineKeyboardButton("üìã Ver Pendientes", callback_data="menu_pendientes"),
             InlineKeyboardButton("üìú Historial", callback_data="menu_recuperar")],
            [InlineKeyboardButton("üó≥Ô∏è Votaci√≥n Comunitaria", callback_data="menu_votacion"),
             InlineKeyboardButton("üî≤ Gesti√≥n Masiva", callback_data="menu_masiva")],
            [InlineKeyboardButton("üì¨ Solicitudes de Contacto", callback_data="menu_contact_list_todas")],
            [InlineKeyboardButton("üí° Sugerencias de Usuarios", callback_data="menu_suggestions_list")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        divider = "‚îÅ" * 30
        texto = (
            f"{divider}\n"
            f"üìã *GESTI√ìN DE SOLICITUDES* üìã\n"
            f"{divider}\n\n"
            f"üìä *Estad√≠sticas r√°pidas:*\n"
            f"‚Ä¢ Pendientes: `{total_pendientes}` solicitudes\n"
            f"‚Ä¢ Historial: `{total_historial}` registros\n\n"
            f"{divider}\n\n"
            f"üí° _Herramientas disponibles:_\n\n"
            f"üìã **Ver Pendientes** ‚îÄ Lista de solicitudes activas\n"
            f"üìú **Historial** ‚îÄ Solicitudes procesadas\n"
            f"üó≥Ô∏è **Votaci√≥n** ‚îÄ Sistema comunitario\n"
            f"üî≤ **Gesti√≥n Masiva** ‚îÄ Acciones m√∫ltiples\n\n"
            f"üïê _{get_spain_time()}_"
        )

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Men√∫ de sugerencias de usuarios
    if data == "menu_suggestions_list":
        await show_loading_animation(query, "üí° *Cargando Sugerencias*", "loading")

        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM user_suggestions WHERE estado = 'pendiente'")
                    total_pendientes = c.fetchone()[0] or 0
                    c.execute("SELECT COUNT(*) FROM user_suggestions")
                    total_sugerencias = c.fetchone()[0] or 0
        except Exception as e:
            logger.error(f"Error obteniendo estad√≠sticas de sugerencias: {str(e)}")
            total_pendientes = 0
            total_sugerencias = 0

        keyboard = [
            [InlineKeyboardButton("üí° Ver Pendientes", callback_data="suggestions_pendientes"),
             InlineKeyboardButton("‚úÖ Revisadas", callback_data="suggestions_revisadas")],
            [InlineKeyboardButton("üìã Todas las Sugerencias", callback_data="suggestions_todas")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data="menu_gestion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        divider = "‚îÅ" * 30
        texto = (
            f"{divider}\n"
            f"üí° *SUGERENCIAS DE USUARIOS* üí°\n"
            f"{divider}\n\n"
            f"üìä *Estad√≠sticas:*\n"
            f"‚Ä¢ Pendientes: `{total_pendientes}` sugerencias\n"
            f"‚Ä¢ Total: `{total_sugerencias}` registros\n\n"
            f"{divider}\n\n"
            f"üìù Aqu√≠ puedes revisar y gestionar las sugerencias\n"
            f"que los usuarios han enviado al equipo.\n\n"
            f"üí° _Selecciona una categor√≠a para continuar_\n\n"
            f"üïê _{get_spain_time()}_"
        )

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Handlers para ver sugerencias filtradas
    if data == "suggestions_pendientes":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT id, user_id, username, suggestion, created_at, estado, admin_response
                        FROM user_suggestions
                        WHERE estado = 'pendiente'
                        ORDER BY created_at DESC
                        LIMIT 20
                    """)
                    suggestions = [dict(row) for row in c.fetchall()]

            if not suggestions:
                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üí° *SUGERENCIAS PENDIENTES* üí°\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üì≠ *No hay sugerencias pendientes*\n\n"
                    f"‚ú® Las nuevas sugerencias aparecer√°n aqu√≠\n\n"
                    f"üïê _{get_spain_time()}_"
                )
                keyboard = [
                    [InlineKeyboardButton("üîÑ Actualizar", callback_data="suggestions_pendientes"),
                     InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list")],
                    [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üí° *SUGERENCIAS PENDIENTES* üí°\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä Total: `{len(suggestions)}` sugerencias\n\n"
                    f"üí° _Selecciona una sugerencia para gestionar:_\n"
                )
                keyboard = []
                for sug in suggestions[:15]:
                    username_display = f"@{sug['username']}" if sug['username'] else f"User {sug['user_id']}"
                    preview = sug['suggestion'][:30] + "..." if len(sug['suggestion']) > 30 else sug['suggestion']
                    fecha = sug['created_at'].strftime("%d/%m")
                    button_text = f"#{sug['id']} {username_display}: {preview} ({fecha})"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"view_suggestion_{sug['id']}")])

                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error listando sugerencias pendientes: {str(e)}")
            await query.answer("‚ùå Error al cargar sugerencias", show_alert=True)

        return ConversationHandler.END

    if data == "suggestions_revisadas":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT id, user_id, username, suggestion, created_at, estado, admin_response, reviewed_at
                        FROM user_suggestions
                        WHERE estado IN ('aprobada', 'rechazada')
                        ORDER BY reviewed_at DESC
                        LIMIT 20
                    """)
                    suggestions = [dict(row) for row in c.fetchall()]

            if not suggestions:
                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"‚úÖ *SUGERENCIAS REVISADAS* ‚úÖ\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üì≠ *No hay sugerencias revisadas*\n\n"
                    f"‚ú® Las sugerencias revisadas aparecer√°n aqu√≠\n\n"
                    f"üïê _{get_spain_time()}_"
                )
                keyboard = [
                    [InlineKeyboardButton("üîÑ Actualizar", callback_data="suggestions_revisadas"),
                     InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list")],
                    [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"‚úÖ *SUGERENCIAS REVISADAS* ‚úÖ\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä Total: `{len(suggestions)}` sugerencias\n\n"
                    f"üí° _Selecciona una para ver detalles:_\n"
                )
                keyboard = []
                for sug in suggestions[:15]:
                    username_display = f"@{sug['username']}" if sug['username'] else f"User {sug['user_id']}"
                    estado_emoji = "‚úÖ" if sug['estado'] == 'aprobada' else "‚ùå"
                    preview = sug['suggestion'][:25] + "..." if len(sug['suggestion']) > 25 else sug['suggestion']
                    fecha = sug['reviewed_at'].strftime("%d/%m") if sug['reviewed_at'] else "N/A"
                    button_text = f"{estado_emoji} #{sug['id']} {username_display}: {preview} ({fecha})"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"view_suggestion_{sug['id']}")])

                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error listando sugerencias revisadas: {str(e)}")
            await query.answer("‚ùå Error al cargar sugerencias", show_alert=True)

        return ConversationHandler.END

    if data == "suggestions_todas":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT id, user_id, username, suggestion, created_at, estado, admin_response
                        FROM user_suggestions
                        ORDER BY created_at DESC
                        LIMIT 30
                    """)
                    suggestions = [dict(row) for row in c.fetchall()]

            if not suggestions:
                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üìã *TODAS LAS SUGERENCIAS* üìã\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üì≠ *No hay sugerencias registradas*\n\n"
                    f"‚ú® Las sugerencias aparecer√°n aqu√≠\n\n"
                    f"üïê _{get_spain_time()}_"
                )
                keyboard = [
                    [InlineKeyboardButton("üîÑ Actualizar", callback_data="suggestions_todas"),
                     InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list")],
                    [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                estado_counts = {}
                for sug in suggestions:
                    estado_counts[sug['estado']] = estado_counts.get(sug['estado'], 0) + 1

                texto = (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üìã *TODAS LAS SUGERENCIAS* üìã\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìä Total: `{len(suggestions)}` sugerencias\n"
                    f"üü° Pendientes: `{estado_counts.get('pendiente', 0)}`\n"
                    f"‚úÖ Aprobadas: `{estado_counts.get('aprobada', 0)}`\n"
                    f"‚ùå Rechazadas: `{estado_counts.get('rechazada', 0)}`\n\n"
                    f"üí° _Selecciona una para ver detalles:_\n"
                )
                keyboard = []
                for sug in suggestions[:20]:
                    username_display = f"@{sug['username']}" if sug['username'] else f"User {sug['user_id']}"
                    estado_emoji = {"pendiente": "üü°", "aprobada": "‚úÖ", "rechazada": "‚ùå"}.get(sug['estado'], "‚ö™")
                    preview = sug['suggestion'][:25] + "..." if len(sug['suggestion']) > 25 else sug['suggestion']
                    fecha = sug['created_at'].strftime("%d/%m")
                    button_text = f"{estado_emoji} #{sug['id']} {username_display}: {preview} ({fecha})"
                    keyboard.append([InlineKeyboardButton(button_text, callback_data=f"view_suggestion_{sug['id']}")])

                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error listando todas las sugerencias: {str(e)}")
            await query.answer("‚ùå Error al cargar sugerencias", show_alert=True)

        return ConversationHandler.END

    # Ver detalle de una sugerencia espec√≠fica
    if data.startswith("view_suggestion_"):
        try:
            suggestion_id = int(data.split("_")[2])

            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT id, user_id, username, suggestion, created_at, estado, admin_response, reviewed_at, admin_id
                        FROM user_suggestions
                        WHERE id = %s
                    """, (suggestion_id,))
                    sug = c.fetchone()

            if not sug:
                await query.answer("‚ùå Sugerencia no encontrada", show_alert=True)
                return ConversationHandler.END

            sug_dict = dict(sug)
            username_display = f"@{sug_dict['username']}" if sug_dict['username'] else f"User {sug_dict['user_id']}"
            fecha_creacion = sug_dict['created_at'].strftime("%d/%m/%Y %H:%M")
            estado_emoji = {"pendiente": "üü°", "aprobada": "‚úÖ", "rechazada": "‚ùå"}.get(sug_dict['estado'], "‚ö™")

            texto = (
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üí° *DETALLE DE SUGERENCIA #{sug_dict['id']}* üí°\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üë§ *Usuario:* {escape_markdown(username_display, True)}\n"
                f"üÜî *ID Usuario:* `{sug_dict['user_id']}`\n"
                f"üìÖ *Fecha:* {fecha_creacion}\n"
                f"üìä *Estado:* {estado_emoji} {sug_dict['estado'].capitalize()}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üí¨ *Sugerencia:*\n"
                f"{escape_markdown(sug_dict['suggestion'])}\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            )

            if sug_dict['admin_response']:
                fecha_revision = sug_dict['reviewed_at'].strftime("%d/%m/%Y %H:%M") if sug_dict['reviewed_at'] else "N/A"
                texto += (
                    f"\nüìù *Respuesta del Admin:*\n"
                    f"‚è∞ *Fecha revisi√≥n:* {fecha_revision}\n"
                    f"{escape_markdown(sug_dict['admin_response'])}\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                )

            keyboard = []
            if sug_dict['estado'] == 'pendiente':
                keyboard.append([
                    InlineKeyboardButton("‚úÖ Aprobar", callback_data=f"approve_suggestion_{suggestion_id}"),
                    InlineKeyboardButton("‚ùå Rechazar", callback_data=f"reject_suggestion_{suggestion_id}")
                ])

            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_suggestions_list"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error viendo detalle de sugerencia: {str(e)}")
            await query.answer("‚ùå Error al cargar sugerencia", show_alert=True)

        return ConversationHandler.END

    # Manejo de solicitudes pendientes
    if data.startswith("menu_pendientes") or data.startswith("pend_page_"):
        page = int(data.split("_")[-1]) if data.startswith("pend_page_") else 1
        ITEMS_PER_PAGE = 5

        # Mostrar animaci√≥n de b√∫squeda
        if data.startswith("menu_pendientes"):
            await show_loading_animation(query, "üîç *Buscando solicitudes pendientes*", "search")

        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    offset = (page - 1) * ITEMS_PER_PAGE
                    c.execute(
                        "SELECT ticket_number, username, message_text, chat_title, timestamp, has_attachment "
                        "FROM peticiones_registradas ORDER BY timestamp DESC LIMIT %s OFFSET %s",
                        (ITEMS_PER_PAGE, offset)
                    )
                    peticiones = [dict(row) for row in c.fetchall()]
                    c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                    total_peticiones = c.fetchone()[0]

            total_pages = (total_peticiones + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE

            if not peticiones:
                divider = "‚îÅ" * 30
                texto = (
                    f"{divider}\n"
                    f"üì≠ *SIN SOLICITUDES PENDIENTES* üì≠\n"
                    f"{divider}\n\n"
                    f"‚úÖ No hay solicitudes pendientes de revisi√≥n\n\n"
                    f"üí° _Las nuevas solicitudes aparecer√°n aqu√≠_\n\n"
                    f"üïê {get_spain_time()}"
                )
                keyboard = [
                    [InlineKeyboardButton("üîÑ Actualizar", callback_data="menu_pendientes"),
                     InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_gestion")],
                    [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                divider = "‚îÅ" * 30
                texto = (
                    f"{divider}\n"
                    f"üìã *SOLICITUDES PENDIENTES* üìã\n"
                    f"P√°gina {page}/{total_pages}\n"
                    f"{divider}\n\n"
                    f"üìä Total: `{total_peticiones}` solicitudes\n"
                    f"üìÑ Mostrando: `{len(peticiones)}` en esta p√°gina\n\n"
                    f"üí° _Selecciona una solicitud para gestionar:_\n"
                )
                keyboard = []

                for p in peticiones:
                    username_clean = p['username'].replace('@', '') if p['username'].startswith('@') else p['username']
                    votes = get_votes_summary(p['ticket_number'])
                    vote_display = f" [{votes['positive']}/{votes['negative']}]" if votes['total'] > 0 else ""
                    formato_solicitud = f"#{p['ticket_number']} @{username_clean} - {p['chat_title'][:20]}{vote_display}"
                    keyboard.append([
                        InlineKeyboardButton(
                            formato_solicitud,
                            callback_data=f"pend_{p['ticket_number']}_{page}_gestionar"
                        )
                    ])
                
                nav_buttons = []
                if page > 1:
                    nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"pend_page_{page-1}"))
                if page < total_pages:
                    nav_buttons.append(InlineKeyboardButton("Siguiente ‚û°Ô∏è", callback_data=f"pend_page_{page+1}"))
                if nav_buttons:
                    keyboard.append(nav_buttons)
                
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_gestion"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": page
            }
            return ConversationHandler.END
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al listar pendientes: {str(e)}")
            
        return ConversationHandler.END

    # Gesti√≥n individual de solicitudes
    if data.startswith("pend_") and "_gestionar" in data:
        parts = data.split("_")
        ticket = int(parts[1])
        page = int(parts[2])
        info = get_peticion_registrada(ticket)
        
        if not info:
            texto = f"‚ùå *Ticket no encontrado* ‚ùå\nEl Ticket #{ticket} no se encuentra disponible."
            keyboard = [
                [InlineKeyboardButton(f"‚Ü©Ô∏è Volver a Pendientes (p√°g. {page})", callback_data=f"pend_page_{page}"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": page
            }
            return ConversationHandler.END

        votes = get_votes_summary(ticket)
        vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else ""
        
        texto = (
            f"üìã *Solicitud #{ticket}* üìã\n"
            f"üë§ *Usuario:* {escape_markdown(info['username'], True)}\n"
            f"‚úâÔ∏è *Mensaje:* {escape_markdown(info['message_text'])}\n"
            f"üìç *Grupo:* {escape_markdown(info['chat_title'])}\n"
            f"‚è∞ *Fecha:* {info['timestamp'].strftime('%d/%m/%Y %H:%M:%S')}\n"
            f"üìé *Adjunto:* {'S√≠' if info['has_attachment'] else 'No'}{vote_text}\n"
            f"Selecciona una acci√≥n:"
        )
        keyboard = [
            [InlineKeyboardButton("‚úÖ Aprobar", callback_data=f"pend_{ticket}_{page}_subido"),
             InlineKeyboardButton("üîó Aprobar con Enlace", callback_data=f"pend_{ticket}_{page}_subido_link")],
            [InlineKeyboardButton("‚ùå Denegar", callback_data=f"pend_{ticket}_{page}_denegado"),
             InlineKeyboardButton("üóëÔ∏è Eliminar", callback_data=f"pend_{ticket}_{page}_eliminar_with_reason")],
            [InlineKeyboardButton(f"‚Ü©Ô∏è Volver a Pendientes (p√°g. {page})", callback_data=f"pend_page_{page}"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": page
        }
        return ConversationHandler.END

    # Procesar acciones directas (aprobar sin enlace)
    if data.startswith("pend_") and "_subido" in data and "_link" not in data:
        parts = data.split("_")
        ticket = int(parts[1])
        page = int(parts[2])
        info = get_peticion_registrada(ticket)
        
        if not info:
            await safe_bot_method(
                query.edit_message_text,
                text=f"‚ùå *Error* ‚ùå\nEl Ticket #{ticket} no se encuentra disponible.",
                parse_mode="Markdown"
            )
            return ConversationHandler.END
        
        await set_historial_solicitud(ticket, {
            "chat_id": info["chat_id"],
            "username": info["username"],
            "user_id": info["user_id"],
            "message_text": info["message_text"],
            "chat_title": info["chat_title"],
            "estado": "subido",
            "fecha_gestion": datetime.now(SPAIN_TZ),
            "admin_username": "Equipo de Administraci√≥n",
            "url": "Aprobado sin enlace",
            "has_attachment": info["has_attachment"],
            "photo_file_id": info["photo_file_id"]
        })
        
        del_peticion_registrada(ticket)
        
        canal_info = CANALES_PETICIONES.get(info["chat_id"], {"chat_id": info["chat_id"], "thread_id": None})
        username_escaped = escape_markdown(info["username"], preserve_username=True)
        message_text_escaped = escape_markdown(info["message_text"])
        
        notification_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=canal_info["chat_id"],
            text=(
                f"‚úÖ *Solicitud Aprobada* ‚úÖ\n"
                f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket})_ ha sido aprobada por el *Equipo de Administraci√≥n*.\n"
                f"üìå *Detalles:*\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {escape_markdown(info['chat_title'])}\n"
                f"‚è∞ *Fecha:* {get_spain_time()}\n"
                f"üìé *Adjunto:* {'S√≠' if info['has_attachment'] else 'No'}\n"
                f"üòä Por favor, califica tu experiencia con la encuesta."
            ),
            message_thread_id=canal_info["thread_id"],
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üòä Encuesta de Satisfacci√≥n", callback_data=f"encuesta_{ticket}")]
            ]),
            parse_mode="Markdown"
        )

        # Registrar encuesta pendiente para recordatorio
        save_pending_survey(ticket, info["user_id"], info["username"], info["chat_id"], info["message_text"], info["chat_title"])

        if info.get("message_id"):
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=GROUP_DESTINO,
                message_id=info["message_id"]
            )
        
        photo_message_id = context.bot_data.get(f"photo_{ticket}")
        if photo_message_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=GROUP_DESTINO,
                message_id=photo_message_id
            )
            del context.bot_data[f"photo_{ticket}"]
        
        # Eliminar mensaje de confirmaci√≥n cuando se gestiona
        await delete_confirmation_message(context, ticket)
        
        texto = (
            f"‚úÖ *Solicitud Aprobada* ‚úÖ\n"
            f"La solicitud #{ticket} ha sido aprobada sin enlace."
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Pendientes", callback_data="menu_pendientes"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": page
        }
        logger.info(f"‚úÖ Solicitud #{ticket} aprobada sin enlace por user_id={user_id}")
        return ConversationHandler.END

    # Estad√≠sticas y Reportes
    if data == "menu_estadisticas":
        keyboard = [
            [InlineKeyboardButton("üìà Panel General", callback_data="detailed_stats"),
             InlineKeyboardButton("üìä Estad√≠sticas Detalladas", callback_data="detailed_stats")],
            [InlineKeyboardButton("üìÖ Reporte Semanal", callback_data="ejecutar_reporte_semanal"),
             InlineKeyboardButton("üìã Stats Reportes", callback_data="stats_reportes_semanales")],
            [InlineKeyboardButton("üîç Actividad Sospechosa", callback_data="suspicious_activity"),
             InlineKeyboardButton("üòä Satisfacci√≥n Usuarios", callback_data="satisfaction_report")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"üìä *Estad√≠sticas y Reportes* üìä\n"
            f"An√°lisis completo del rendimiento del bot:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Configuraci√≥n del Bot
    if data == "menu_configuracion":
        keyboard = [
            [InlineKeyboardButton("‚è∞ Horario del Bot", callback_data="menu_tiempo"),
             InlineKeyboardButton("üìç Gestionar Grupos", callback_data="menu_grupos")],
            [InlineKeyboardButton("üöß Modo Mantenimiento", callback_data="maintenance_config"),
             InlineKeyboardButton("üîî Configurar Notificaciones", callback_data="notification_config")],
            [InlineKeyboardButton("üîç Detecci√≥n Duplicados", callback_data="duplicate_config"),
             InlineKeyboardButton("üìã Recordatorio Manual", callback_data="manual_survey_reminder")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"‚öôÔ∏è *Configuraci√≥n del Bot* ‚öôÔ∏è\n"
            f"Ajustes y configuraciones del sistema:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Configuraci√≥n de notificaciones autom√°ticas
    if data == "notification_config":
        current_status = "üü¢ Habilitadas" if automatic_notifications_enabled else "üî¥ Deshabilitadas"
        
        texto = (
            f"üîî *Configuraci√≥n de Notificaciones Autom√°ticas* üîî\n\n"
            f"üìä *Estado actual:* {current_status}\n\n"
            f"üìù *Funcionalidad:*\n"
            f"‚Ä¢ Notificaci√≥n de apertura: 5 minutos antes del horario de inicio\n"
            f"‚Ä¢ Notificaci√≥n de cierre: 5 minutos antes del horario de fin\n"
            f"‚Ä¢ Se env√≠an a todos los canales configurados\n"
            f"‚Ä¢ Requiere horario configurado para funcionar\n\n"
            f"‚öôÔ∏è *Gestionar notificaciones autom√°ticas:*"
        )
        
        keyboard = [
            [InlineKeyboardButton("üü¢ Activar Notificaciones", callback_data="enable_notifications"),
             InlineKeyboardButton("üî¥ Desactivar", callback_data="disable_notifications")],
            [InlineKeyboardButton("üìÖ Ver Horario", callback_data="view_schedule"),
             InlineKeyboardButton("‚öôÔ∏è Configurar Horario", callback_data="menu_tiempo")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END
    
    if data == "enable_notifications":
        set_notification_settings(True)
        schedule_notifications(context.application)
        
        schedule = get_bot_schedule()
        schedule_info = ""
        if schedule:
            days_str = ", ".join(schedule['days_of_week'])
            schedule_info = f"\nüìÖ Horario: {days_str} de {schedule['start_hour']:02d}:00 a {schedule['end_hour']:02d}:00"
        
        texto = (
            f"üü¢ *Notificaciones Autom√°ticas Activadas* üü¢\n\n"
            f"‚úÖ Las notificaciones autom√°ticas han sido habilitadas\n"
            f"‚è∞ Sistema en tiempo real activado (verificaci√≥n cada minuto)\n"
            f"üîî Recordatorios: 5 minutos antes de apertura y cierre\n"
            f"üì¢ Notificaciones: En hora exacta de apertura y cierre\n"
            f"üóëÔ∏è Auto-eliminaci√≥n: Mensajes se eliminan autom√°ticamente{schedule_info}\n"
            f"üì± Trabajos programados: {len(notification_jobs)}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üî¥ Desactivar", callback_data="disable_notifications")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="notification_config")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END
    
    if data == "disable_notifications":
        set_notification_settings(False)
        
        for job_name, job in list(notification_jobs.items()):
            job.schedule_removal()
            del notification_jobs[job_name]
        
        # Eliminar todos los mensajes de notificaci√≥n activos
        await delete_notification_messages_by_type(context, "opening_reminder")
        await delete_notification_messages_by_type(context, "closing_reminder")
        await delete_notification_messages_by_type(context, "opening_active")
        await delete_notification_messages_by_type(context, "closing_active")
        
        texto = (
            f"üî¥ *Notificaciones Autom√°ticas Desactivadas* üî¥\n\n"
            f"‚ùå Las notificaciones autom√°ticas han sido deshabilitadas\n"
            f"üìµ No se enviar√°n recordatorios autom√°ticos\n"
            f"üóëÔ∏è Trabajos programados cancelados\n"
            f"üßπ Mensajes de notificaci√≥n existentes eliminados"
        )
        
        keyboard = [
            [InlineKeyboardButton("üü¢ Activar", callback_data="enable_notifications")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="notification_config")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Herramientas Admin
    if data == "menu_herramientas":
        keyboard = [
            [InlineKeyboardButton("‚ûñ Reducir Solicitudes", callback_data="menu_restar"),
             InlineKeyboardButton("üì° Estado del Sistema", callback_data="menu_ping")],
            [InlineKeyboardButton("üîç Buscar Usuario", callback_data="search_user"),
             InlineKeyboardButton("üì¢ Enviar Alerta", callback_data="enviar_alerta")],
            [InlineKeyboardButton("üìã Logs del Sistema", callback_data="system_logs")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"üõ†Ô∏è *Herramientas de Administraci√≥n* üõ†Ô∏è\n"
            f"Utilidades avanzadas para administradores:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Mantenimiento
    if data == "menu_mantenimiento":
        keyboard = [
            [InlineKeyboardButton("üóëÔ∏è Limpiar Cach√©", callback_data="clear_cache"),
             InlineKeyboardButton("üîÑ Reiniciar Servicios", callback_data="restart_services")],
            [InlineKeyboardButton("üßπ Limpieza Autom√°tica", callback_data="auto_cleanup"),
             InlineKeyboardButton("üìä Uso de Recursos", callback_data="resource_usage")],
            [InlineKeyboardButton("üîÑ Optimizar DB", callback_data="reorganize_db"),
             InlineKeyboardButton("üßπ Autocierre Manual (20 d√≠as)", callback_data="manual_old_cleanup")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"üîß *Mantenimiento del Sistema* üîß\n"
            f"Herramientas de mantenimiento y optimizaci√≥n:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Sistema de Puntos (DESHABILITADO)
    if data == "menu_puntos":
        try:
            stats = obtener_estadisticas_puntos()
            if stats:
                texto = (
                    f"üí∞ *Sistema de Puntos* üí∞\n\n"
                    f"¬°Bienvenido al sistema de gamificaci√≥n de EntresHijos!\n\n"
                    f"üìä **Estad√≠sticas Generales:**\n"
                    f"üë• Usuarios registrados: {stats['total_usuarios']}\n"
                    f"‚≠ê Puntos totales: {stats['total_puntos']:,}\n"
                    f"üéÅ Recompensas canjeadas: {stats['total_canjes']}\n\n"
                    f"Selecciona una opci√≥n:"
                )
            else:
                texto = (
                    f"üí∞ *Sistema de Puntos* üí∞\n\n"
                    f"¬°Bienvenido al sistema de gamificaci√≥n de EntresHijos!\n\n"
                    f"Selecciona una opci√≥n para comenzar:"
                )

            keyboard = [
                [InlineKeyboardButton("üèÜ Top Usuarios", callback_data="puntos_top_usuarios"),
                 InlineKeyboardButton("üìä Mis Puntos", callback_data="puntos_mis_puntos")],
                [InlineKeyboardButton("üéÅ Recompensas", callback_data="puntos_recompensas"),
                 InlineKeyboardButton("üìà Estad√≠sticas", callback_data="puntos_estadisticas")],
                [InlineKeyboardButton("üí≥ Transacciones", callback_data="puntos_transacciones")],
                [InlineKeyboardButton("üíé Dar Puntos", callback_data="puntos_dar_puntos")] if user_id in ADMINISTRATORS else [],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            # Filtrar listas vac√≠as
            keyboard = [row for row in keyboard if row]

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en menu_puntos: {str(e)}")
            texto = (
                f"üí∞ *Sistema de Puntos* üí∞\n\n"
                f"‚ö†Ô∏è Error al cargar el sistema de puntos.\n"
                f"Por favor, int√©ntalo de nuevo m√°s tarde."
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Top Usuarios (Sistema de Puntos)
    if data == "puntos_top_usuarios":
        try:
            top_usuarios = obtener_top_usuarios(10)

            if not top_usuarios:
                texto = "üìä *Ranking de Puntos* üìä\n\nA√∫n no hay datos disponibles."
            else:
                texto = "üèÜ *Top 10 - Ranking de Puntos* üèÜ\n\n"

                medallas = ["ü•á", "ü•à", "ü•â"]
                for i, usuario in enumerate(top_usuarios, 1):
                    emoji_pos = medallas[i-1] if i <= 3 else f"`{i:>2}.`"
                    nivel_emoji = NIVELES[usuario["nivel"]]["emoji"]

                    # Formato compacto y profesional
                    texto += (
                        f"{emoji_pos} {nivel_emoji} **{usuario['username']}** ‚Ä¢ `{usuario['puntos']:,}pts`\n"
                    )

                texto += (
                    f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üí° *Gana puntos:* Solicitudes aprobadas, encuestas\n"
                    f"üéÅ *Canjea:* /recompensas"
                )

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="puntos_top_usuarios")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo top usuarios: {str(e)}")
            texto = f"‚ùå Error al obtener top usuarios: {str(e)}"
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Mis Puntos
    if data == "puntos_mis_puntos":
        try:
            puntos = obtener_puntos_usuario(user_id)

            if puntos:
                nivel_emoji = NIVELES[puntos["nivel"]]["emoji"]
                nivel_config = NIVELES[puntos["nivel"]]
                siguiente_nivel = None

                # Determinar siguiente nivel
                for nivel_nombre, config in NIVELES.items():
                    if config["min_puntos"] > puntos["puntos"]:
                        if siguiente_nivel is None or config["min_puntos"] < NIVELES[siguiente_nivel]["min_puntos"]:
                            siguiente_nivel = nivel_nombre

                if siguiente_nivel:
                    puntos_faltantes = NIVELES[siguiente_nivel]["min_puntos"] - puntos["puntos"]
                    progreso = f"Faltan {puntos_faltantes} pts para {NIVELES[siguiente_nivel]['emoji']} {siguiente_nivel.capitalize()}"
                else:
                    progreso = "¬°Nivel m√°ximo alcanzado! üëë"

                texto = (
                    f"üìä *Tus Puntos* üìä\n\n"
                    f"üë§ **Usuario:** @{puntos['username']}\n"
                    f"{nivel_emoji} **Nivel:** {puntos['nivel'].capitalize()}\n"
                    f"‚≠ê **Puntos totales:** {puntos['puntos']:,} pts\n\n"
                    f"üìà **Progreso:**\n{progreso}\n\n"
                    f"üìã **Actividad:**\n"
                    f"‚úÖ Solicitudes aprobadas: {puntos['solicitudes_aprobadas']}\n"
                    f"üòä Encuestas completadas: {puntos['encuestas_completadas']}\n"
                    f"üî• Racha actual: {puntos['racha_dias']} d√≠as\n"
                )
            else:
                texto = (
                    f"üìä *Tus Puntos* üìä\n\n"
                    f"A√∫n no tienes puntos registrados.\n"
                    f"¬°Comienza participando en la comunidad!\n\n"
                    f"üí° **Formas de ganar puntos:**\n"
                    f"‚Ä¢ Solicitudes aprobadas: 50 pts\n"
                    f"‚Ä¢ Completar encuestas: 10 pts\n"
                    f"‚Ä¢ Racha semanal: 20 pts\n"
                )

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="puntos_mis_puntos")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo mis puntos: {str(e)}")
            texto = f"‚ùå Error al obtener tus puntos: {str(e)}"
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Estad√≠sticas de Puntos
    if data == "puntos_estadisticas":
        try:
            stats = obtener_estadisticas_puntos()

            if stats:
                texto = (
                    f"üìä *Estad√≠sticas del Sistema de Puntos* üìä\n\n"
                    f"üë• **Total usuarios:** {stats['total_usuarios']:,}\n"
                    f"üí∞ **Puntos en circulaci√≥n:** {stats['total_puntos']:,}\n"
                    f"üéÅ **Recompensas canjeadas:** {stats['total_canjes']}\n\n"
                    f"üìà **Distribuci√≥n por Niveles:**\n"
                )

                for nivel, cantidad in stats['niveles'].items():
                    emoji = NIVELES[nivel]["emoji"]
                    porcentaje = (cantidad / stats['total_usuarios'] * 100) if stats['total_usuarios'] > 0 else 0
                    texto += f"{emoji} **{nivel.capitalize()}:** {cantidad} ({porcentaje:.1f}%)\n"
            else:
                texto = "‚ùå No se pudieron obtener las estad√≠sticas"

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="puntos_estadisticas")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas: {str(e)}")
            texto = f"‚ùå Error al obtener estad√≠sticas: {str(e)}"
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Recompensas disponibles
    if data == "puntos_recompensas":
        try:
            recompensas = obtener_recompensas_disponibles()
            puntos_usuario = obtener_puntos_usuario(user_id)

            if recompensas:
                puntos_actuales = puntos_usuario["puntos"] if puntos_usuario else 0

                texto = (
                    f"üéÅ *Tienda de Recompensas* üéÅ\n\n"
                    f"üí∞ Tus puntos: `{puntos_actuales:,} pts`\n\n"
                )

                keyboard = []
                for i, recompensa in enumerate(recompensas, 1):
                    puede_canjear = puntos_actuales >= recompensa["costo_puntos"]
                    icono = "‚úÖ" if puede_canjear else "üîí"

                    texto += (
                        f"{icono} `{i}.` **{recompensa['nombre']}**\n"
                        f"   üíé {recompensa['costo_puntos']} pts ‚Ä¢ {recompensa['descripcion']}\n\n"
                    )

                    # Agregar bot√≥n de canje si tiene suficientes puntos
                    if puede_canjear:
                        keyboard.append([
                            InlineKeyboardButton(
                                f"üéÅ Canjear: {recompensa['nombre']} ({recompensa['costo_puntos']} pts)",
                                callback_data=f"canjear_recompensa_{recompensa['id']}"
                            )
                        ])

                if not keyboard:
                    texto += "üí° *Acumula m√°s puntos para canjear recompensas*"
                else:
                    texto += "‚¨áÔ∏è *Selecciona una recompensa para canjear*"

                keyboard.append([InlineKeyboardButton("üîÑ Actualizar", callback_data="puntos_recompensas")])
            else:
                texto = (
                    f"üéÅ *Tienda de Recompensas* üéÅ\n\n"
                    f"No hay recompensas disponibles en este momento.\n"
                    f"¬°Pronto habr√° nuevas recompensas!"
                )
                keyboard = []

            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo recompensas: {str(e)}")
            texto = f"‚ùå Error al obtener recompensas: {str(e)}"
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Transacciones de puntos
    if data == "puntos_transacciones":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT 
                            puntos AS puntos_otorgados,
                            tipo,
                            descripcion,
                            created_at AS timestamp,
                            admin_id
                        FROM transacciones_puntos
                        WHERE user_id = %s
                        ORDER BY created_at DESC
                        LIMIT 15
                    """, (user_id,))
                    transacciones = [dict(row) for row in c.fetchall()]

            if transacciones:
                texto = f"üí≥ *Historial de Transacciones* üí≥\n\n"
                texto += f"üë§ Usuario: @{query.from_user.username or 'Usuario'}\n\n"

                for trans in transacciones:
                    fecha = trans["timestamp"].strftime("%d/%m/%Y %H:%M")
                    tipo_emoji = "üì•" if trans["puntos_otorgados"] > 0 else "üì§"
                    tipo_texto = "+" if trans["puntos_otorgados"] > 0 else ""

                    texto += (
                        f"{tipo_emoji} **{tipo_texto}{trans['puntos_otorgados']} pts**\n"
                        f"   üìù {trans['descripcion']}\n"
                        f"   üè∑Ô∏è Tipo: {trans['tipo']}\n"
                        f"   üìÖ {fecha}\n\n"
                    )
            else:
                texto = (
                    f"üí≥ *Historial de Transacciones* üí≥\n\n"
                    f"üì≠ No tienes transacciones registradas a√∫n.\n\n"
                    f"¬°Empieza a ganar puntos participando en la comunidad!"
                )

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="puntos_transacciones")],
                [
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ]
            ]

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo transacciones: {str(e)}", exc_info=True)
            await send_error_to_developer(context, f"Error transacciones: {str(e)}", "Error Transacciones")
            texto = f"‚ùå Error al obtener transacciones: {str(e)}"
            keyboard = [
                [
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Canjear puntos desde mensaje de confirmaci√≥n
    if data.startswith("canjear_puntos_"):
        logger.info(f"üéÅ Abriendo tienda de recompensas: callback={data}, user_id={user_id}")
        parts = data.split("_")
        target_user_id = int(parts[2])
        ticket_number = int(parts[3]) if len(parts) > 3 else None

        logger.info(f"üîç Usuario objetivo: {target_user_id}, Ticket: {ticket_number}")

        try:
            recompensas = obtener_recompensas_disponibles()
            puntos_usuario = obtener_puntos_usuario(target_user_id)
            logger.info(f"üìä Recompensas disponibles: {len(recompensas) if recompensas else 0}, Puntos usuario: {puntos_usuario['puntos'] if puntos_usuario else 0}")

            if not puntos_usuario:
                texto = (
                    f"üí∞ *Sistema de Puntos* üí∞\n\n"
                    f"A√∫n no tienes puntos registrados.\n\n"
                    f"üéØ *¬øC√≥mo ganar puntos?*\n"
                    f"‚Ä¢ +50 pts por cada solicitud aprobada\n"
                    f"‚Ä¢ +20 pts por completar encuestas\n"
                    f"‚Ä¢ +10 pts por racha diaria\n\n"
                    f"¬°Sigue participando para acumular puntos!"
                )
                keyboard = [[InlineKeyboardButton("‚Ü©Ô∏è Volver a Solicitud", callback_data=f"volver_solicitud_{ticket_number}_{target_user_id}")] if ticket_number else [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]]
            elif not recompensas:
                texto = (
                    f"üéÅ *Recompensas Disponibles* üéÅ\n\n"
                    f"üí∞ Tus puntos: {puntos_usuario['puntos']:,} pts\n\n"
                    f"No hay recompensas disponibles en este momento.\n"
                    f"¬°Pronto habr√° nuevas recompensas!"
                )
                keyboard = [[InlineKeyboardButton("‚Ü©Ô∏è Volver a Solicitud", callback_data=f"volver_solicitud_{ticket_number}_{target_user_id}")] if ticket_number else [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]]
            else:
                puntos_actuales = puntos_usuario["puntos"]
                nivel_emoji = NIVELES[puntos_usuario["nivel"]]["emoji"]

                texto = (
                    f"üéÅ *Tienda de Recompensas* üéÅ\n\n"
                    f"üë§ *Usuario:* @{query.from_user.username or 'Usuario'}\n"
                    f"üí∞ *Puntos disponibles:* {puntos_actuales:,} pts\n"
                    f"{nivel_emoji} *Nivel:* {puntos_usuario['nivel'].capitalize()}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üõçÔ∏è *Recompensas Disponibles:*\n\n"
                )

                keyboard = []
                for idx, recompensa in enumerate(recompensas, 1):
                    puede_canjear = puntos_actuales >= recompensa["costo_puntos"]
                    icono = "‚úÖ" if puede_canjear else "üîí"

                    texto += (
                        f"{idx}. {icono} *{recompensa['nombre']}*\n"
                        f"   üíé Costo: {recompensa['costo_puntos']:,} pts\n"
                        f"   üìù {recompensa['descripcion']}\n\n"
                    )

                    if puede_canjear:
                        keyboard.append([
                            InlineKeyboardButton(
                                f"üéÅ {recompensa['nombre']} ({recompensa['costo_puntos']} pts)",
                                callback_data=f"confirm_canje_{recompensa['id']}_{target_user_id}_{ticket_number if ticket_number else 0}"
                            )
                        ])
                        logger.info(f"üìù Bot√≥n de canje creado: confirm_canje_{recompensa['id']}_{target_user_id}_{ticket_number if ticket_number else 0}")

                texto += (
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üí° *Nota:* Al canjear una recompensa, se descontar√°n los puntos correspondientes.\n"
                    f"üìû Un administrador procesar√° tu solicitud de canje."
                )

                keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è Volver a Solicitud", callback_data=f"volver_solicitud_{ticket_number}_{target_user_id}")] if ticket_number else [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error mostrando tienda de puntos: {str(e)}")
            await query.answer("‚ùå Error al cargar la tienda de puntos")

        return ConversationHandler.END

    # Auto-canje de recompensa (nuevo sistema)
    if data.startswith("canjear_recompensa_"):
        recompensa_id = int(data.split("_")[2])

        try:
            # Obtener informaci√≥n de la recompensa
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT nombre, costo_puntos, descripcion
                        FROM recompensas_disponibles
                        WHERE id = %s AND activa = true
                    """, (recompensa_id,))
                    recompensa = c.fetchone()

            if not recompensa:
                await query.answer("‚ùå Recompensa no disponible", show_alert=True)
                return ConversationHandler.END

            puntos_usuario = obtener_puntos_usuario(user_id)
            if not puntos_usuario or puntos_usuario["puntos"] < recompensa["costo_puntos"]:
                await query.answer("‚ùå Puntos insuficientes", show_alert=True)
                return ConversationHandler.END

            # Confirmar canje
            texto = (
                f"üéÅ *Confirmar Canje* üéÅ\n\n"
                f"**Recompensa:** {recompensa['nombre']}\n"
                f"üíé **Costo:** {recompensa['costo_puntos']:,} pts\n"
                f"üìù **Descripci√≥n:** {recompensa['descripcion']}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üí∞ **Tus puntos actuales:** {puntos_usuario['puntos']:,} pts\n"
                f"üí≥ **Puntos despu√©s del canje:** {puntos_usuario['puntos'] - recompensa['costo_puntos']:,} pts\n\n"
                f"¬øConfirmas el canje de esta recompensa?"
            )

            keyboard = [
                [InlineKeyboardButton("‚úÖ Confirmar Canje", callback_data=f"confirmar_autocanje_{recompensa_id}")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="puntos_recompensas"),
                 InlineKeyboardButton("‚ùå Cancelar", callback_data="menu_close")]
            ]

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en canje de recompensa: {str(e)}")
            await query.answer("‚ùå Error al procesar el canje")

        return ConversationHandler.END

    # Confirmar auto-canje definitivo
    if data.startswith("confirmar_autocanje_"):
        recompensa_id = int(data.split("_")[2])

        try:
            # Obtener informaci√≥n de la recompensa
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT nombre, costo_puntos, descripcion
                        FROM recompensas_disponibles
                        WHERE id = %s AND activa = true
                    """, (recompensa_id,))
                    recompensa = c.fetchone()

            if not recompensa:
                await query.answer("‚ùå Recompensa no disponible", show_alert=True)
                return ConversationHandler.END

            puntos_usuario = obtener_puntos_usuario(user_id)
            if not puntos_usuario or puntos_usuario["puntos"] < recompensa["costo_puntos"]:
                await query.answer("‚ùå Puntos insuficientes", show_alert=True)
                return ConversationHandler.END

            # Registrar el canje
            exito, mensaje = canjear_recompensa(user_id, query.from_user.username or "Usuario", recompensa_id)

            if exito:
                puntos_restantes = puntos_usuario['puntos'] - recompensa['costo_puntos']
                texto = (
                    f"‚úÖ *¬°Canje Exitoso!* ‚úÖ\n\n"
                    f"üéÅ **Recompensa:** {recompensa['nombre']}\n"
                    f"üíé **Costo:** {recompensa['costo_puntos']:,} pts\n"
                    f"üí∞ **Puntos restantes:** {puntos_restantes:,} pts\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üìù **Descripci√≥n:**\n{recompensa['descripcion']}\n\n"
                    f"‚ú® Un administrador procesar√° tu recompensa pronto.\n"
                    f"üìû Recibir√°s una notificaci√≥n cuando est√© lista.\n\n"
                    f"üôè ¬°Gracias por participar en la comunidad!"
                )

                keyboard = [
                    [InlineKeyboardButton("üéÅ M√°s Recompensas", callback_data="puntos_recompensas")],
                    [InlineKeyboardButton("‚Ü©Ô∏è Men√∫ Puntos", callback_data="menu_puntos"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]

                # Notificar a administradores
                for admin_id in ADMINISTRATORS:
                    try:
                        admin_text = (
                            f"üéÅ *Nueva Solicitud de Canje* üéÅ\n\n"
                            f"üë§ **Usuario:** @{query.from_user.username or 'Usuario'} (ID: {user_id})\n"
                            f"üéÅ **Recompensa:** {recompensa['nombre']}\n"
                            f"üíé **Costo:** {recompensa['costo_puntos']:,} pts\n"
                            f"üìù **Descripci√≥n:** {recompensa['descripcion']}\n\n"
                            f"‚è∞ {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}"
                        )
                        await context.bot.send_message(
                            chat_id=admin_id,
                            text=admin_text,
                            parse_mode="Markdown"
                        )
                    except Exception as e:
                        logger.error(f"Error notificando admin {admin_id}: {str(e)}")

            else:
                texto = (
                    f"‚ùå *Error en el Canje* ‚ùå\n\n"
                    f"{mensaje}\n\n"
                    f"Por favor, intenta nuevamente o contacta a un administrador."
                )
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="puntos_recompensas"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error confirmando canje: {str(e)}")
            await query.answer("‚ùå Error al confirmar el canje")

        return ConversationHandler.END

    # Confirmar canje de recompensa
    if data.startswith("confirm_canje_"):
        logger.info(f"üéÅ Procesando canje: callback={data}, user_id={user_id}")
        parts = data.split("_")
        logger.info(f"üîç Partes del callback: {parts}")

        try:
            recompensa_id = int(parts[2])
            target_user_id = int(parts[3])
            ticket_number = int(parts[4]) if len(parts) > 4 and parts[4] != "0" else None

            logger.info(f"üîç Datos parseados - recompensa_id: {recompensa_id}, target_user_id: {target_user_id}, ticket_number: {ticket_number}")
        except (IndexError, ValueError) as e:
            logger.error(f"‚ùå Error parseando callback de canje: {str(e)}, parts: {parts}")
            await query.answer("‚ùå Error en el formato del bot√≥n", show_alert=True)
            return ConversationHandler.END

        try:
            # Verificar que es el usuario correcto o un administrador
            if user_id != target_user_id and user_id not in ADMINISTRATORS:
                logger.warning(f"‚ö†Ô∏è Usuario {user_id} intent√≥ canjear puntos de {target_user_id}")
                await query.answer("‚ö†Ô∏è Solo puedes canjear tus propios puntos", show_alert=True)
                return ConversationHandler.END

            logger.info(f"‚úÖ Verificaci√≥n de usuario OK - procesando canje para user_id={target_user_id}")

            # Obtener informaci√≥n de la recompensa
            conn = None
            try:
                conn = get_db_connection()
                with conn.cursor(cursor_factory=RealDictCursor) as c:
                    c.execute("""
                        SELECT nombre, costo_puntos, descripcion
                        FROM recompensas_disponibles
                        WHERE id = %s AND activa = true
                    """, (recompensa_id,))
                    recompensa = c.fetchone()
            finally:
                if conn:
                    release_db_connection(conn)

            if not recompensa:
                logger.error(f"‚ùå Recompensa {recompensa_id} no encontrada o no activa")
                await query.answer("‚ùå Recompensa no disponible", show_alert=True)
                return ConversationHandler.END

            logger.info(f"‚úÖ Recompensa encontrada: {recompensa['nombre']} ({recompensa['costo_puntos']} pts)")

            puntos_usuario = obtener_puntos_usuario(target_user_id)
            if not puntos_usuario:
                logger.error(f"‚ùå Usuario {target_user_id} no tiene registro de puntos")
                await query.answer("‚ùå No tienes puntos registrados", show_alert=True)
                return ConversationHandler.END

            logger.info(f"üí∞ Puntos usuario: {puntos_usuario['puntos']}, Costo recompensa: {recompensa['costo_puntos']}")

            if puntos_usuario["puntos"] < recompensa["costo_puntos"]:
                logger.warning(f"‚ùå Puntos insuficientes: {puntos_usuario['puntos']} < {recompensa['costo_puntos']}")
                await query.answer("‚ùå Puntos insuficientes", show_alert=True)
                return ConversationHandler.END

            # Registrar el canje (usar target_user_id, no user_id)
            username_for_canje = query.from_user.username or f"Usuario{target_user_id}"
            exito, mensaje = canjear_recompensa(target_user_id, username_for_canje, recompensa_id)
            logger.info(f"üéÅ Resultado del canje - √âxito: {exito}, Mensaje: {mensaje}")

            if exito:
                texto = (
                    f"‚úÖ *¬°Canje Exitoso!* ‚úÖ\n\n"
                    f"üéÅ *Recompensa:* {recompensa['nombre']}\n"
                    f"üíé *Costo:* {recompensa['costo_puntos']:,} pts\n"
                    f"üí∞ *Puntos restantes:* {puntos_usuario['puntos'] - recompensa['costo_puntos']:,} pts\n\n"
                    f"üìù *Descripci√≥n:*\n{recompensa['descripcion']}\n\n"
                    f"‚ú® Un administrador procesar√° tu recompensa pronto.\n"
                    f"üìû Recibir√°s una notificaci√≥n cuando est√© lista.\n\n"
                    f"üôè ¬°Gracias por participar en la comunidad!"
                )

                # Notificar a administradores
                admin_notif = (
                    f"üéÅ *Nueva Solicitud de Canje* üéÅ\n\n"
                    f"üë§ *Usuario:* @{username_for_canje} (ID: {target_user_id})\n"
                    f"üéÅ *Recompensa:* {recompensa['nombre']}\n"
                    f"üíé *Costo:* {recompensa['costo_puntos']:,} pts\n"
                    f"üìù *Descripci√≥n:* {recompensa['descripcion']}\n\n"
                    f"‚è∞ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M')}\n\n"
                    f"‚úÖ Puntos deducidos exitosamente"
                )

                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=GROUP_DESTINO,
                    text=admin_notif,
                    parse_mode="Markdown"
                )
                logger.info(f"‚úÖ Notificaci√≥n de canje enviada a administradores")
            else:
                logger.error(f"‚ùå Error en canje: {mensaje}")
                texto = f"‚ùå *Error al Canjear* ‚ùå\n\n{mensaje}"

            keyboard = [[InlineKeyboardButton("‚Ü©Ô∏è Volver a Solicitud", callback_data=f"volver_solicitud_{ticket_number}_{target_user_id}")] if ticket_number else [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error confirmando canje: {str(e)}")
            await query.answer("‚ùå Error al procesar el canje", show_alert=True)

        return ConversationHandler.END

    # Dar Puntos (Solo administradores)
    if data == "puntos_dar_puntos":
        if user_id not in ADMINISTRATORS:
            await query.answer("‚ùå Solo administradores pueden dar puntos", show_alert=True)
            return ConversationHandler.END

        texto = (
            f"üíé *Dar Puntos a Usuario* üíé\n\n"
            f"üîπ **Opci√≥n 1: Desde el chat**\n"
            f"Usa el comando en cualquier grupo de peticiones:\n\n"
            f"`/dar_puntos @username cantidad motivo`\n\n"
            f"**Ejemplo:**\n"
            f"`/dar_puntos @usuario 100 Buen aporte`\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üîπ **Opci√≥n 2: Desde aqu√≠**\n"
            f"Responde a este mensaje con el siguiente formato:\n\n"
            f"`@username cantidad motivo`\n\n"
            f"**Ejemplo:**\n"
            f"`@usuario 100 Excelente colaboraci√≥n`\n\n"
            f"‚ú® *El sistema procesar√° tu respuesta autom√°ticamente*"
        )

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_puntos"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        # Guardar estado del administrador esperando texto
        admin_waiting_responses[user_id] = {
            "action": "dar_puntos",
            "message_id": message_id,
            "chat_id": chat_id,
            "timestamp": datetime.now(SPAIN_TZ)
        }

        # Registrar el mensaje activo en el men√∫
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }

        return ConversationHandler.END

    # Mejorar manejo de selecci√≥n de d√≠as
    if data.startswith("day_"):
        day = data.split("_")[1]
        days = context.user_data.get("days", [])
        
        if day in days:
            days.remove(day)
            logger.info(f"‚úÖ D√≠a {day} deseleccionado por user_id={user_id}")
        else:
            days.append(day)
            logger.info(f"‚úÖ D√≠a {day} seleccionado por user_id={user_id}")
        
        context.user_data["days"] = days
        
        keyboard = []
        for day_option in ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado", "Domingo"]:
            marker = "‚úÖ" if day_option in days else "‚¨ú"
            keyboard.append([InlineKeyboardButton(f"{marker} {day_option}", callback_data=f"day_{day_option}")])
        
        keyboard.append([InlineKeyboardButton("‚úÖ Confirmar D√≠as", callback_data="confirm_days")])
        keyboard.append([InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        days_selected = ", ".join(days) if days else "Ninguno"
        texto = (
            f"üìÖ *Seleccionar D√≠as para el Horario* üìÖ\n"
            f"Selecciona los d√≠as en los que el bot aceptar√° solicitudes:\n\n"
            f"üóìÔ∏è *D√≠as seleccionados:* {days_selected}"
        )
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return SELECT_DAYS

    if data == "confirm_days":
        days = context.user_data.get("days", [])
        if not days:
            await query.answer("‚ö†Ô∏è Debes seleccionar al menos un d√≠a", show_alert=True)
            return SELECT_DAYS
        
        days_str = ", ".join(days)
        texto = (
            f"üìÖ *D√≠as Seleccionados* üìÖ\n"
            f"üìÜ *D√≠as:* {days_str}\n\n"
            f"üïî *Ahora escribe la hora de inicio*\n"
            f"Formato: HH:MM (ejemplo: 09:00)"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a D√≠as", callback_data="edit_days"),
             InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        # Enviar mensaje de instrucci√≥n separado
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="üïí *Escribe la hora de inicio (formato HH:MM):*\nEjemplo: 09:00",
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            context.user_data["question_message_id"] = instruction_msg.message_id
        
        logger.info(f"‚úÖ D√≠as confirmados por user_id={user_id}: {days}")
        return INPUT_START_HOUR

    # Buscar usuario
    if data == "search_user":
        texto = (
            "üîç *Buscar Usuario* üîç\n\n"
            "Busca informaci√≥n detallada de usuarios del sistema.\n"
            "Puedes buscar por:\n\n"
            "üë§ *Username* (ej: @usuario)\n"
            "üÜî *User ID* (ej: 123456789)\n"
            "üìß *Palabra clave* en solicitudes\n\n"
            "Escribe tu consulta de b√∫squeda:"
        )
        
        pending_searches[f"{user_id}_{chat_id}"] = {
            "timestamp": datetime.now(SPAIN_TZ),
            "message_id": message_id,
            "admin_id": user_id
        }
        
        keyboard = [
            [InlineKeyboardButton("‚ùå Cancelar B√∫squeda", callback_data="cancel_search")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="üîç *Escribe tu consulta de b√∫squeda:*\nPuedes usar @username, user_id o palabras clave",
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            context.user_data["search_instruction_msg"] = instruction_msg.message_id
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        return ASKING_USER_SEARCH

    if data == "cancel_search":
        search_key = f"{user_id}_{chat_id}"
        if search_key in pending_searches:
            del pending_searches[search_key]
        
        instruction_msg_id = context.user_data.get("search_instruction_msg")
        if instruction_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=instruction_msg_id
            )
            if "search_instruction_msg" in context.user_data:
                del context.user_data["search_instruction_msg"]
        
        texto = (
            f"‚ùå *B√∫squeda Cancelada* ‚ùå\n\n"
            f"La b√∫squeda de usuario ha sido cancelada.\n"
            f"‚è∞ *Cancelado:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ B√∫squeda cancelada por user_id={user_id}")
        return ConversationHandler.END

    # Estado del sistema (Ping)
    if data == "menu_ping":
        uptime_seconds = time_module.time() - BOT_START_TIME
        days = int(uptime_seconds // (24 * 3600))
        hours = int((uptime_seconds % (24 * 3600)) // 3600)
        minutes = int((uptime_seconds % 3600) // 60)
        seconds = int(uptime_seconds % 60)
        uptime_str = f"{days}d {hours}h {minutes}m {seconds}s"
        
        db_status = "‚úÖ Conectada" if test_db_connection() else "‚ùå Desconectada"
        
        memory_str = "No disponible"
        try:
            process = psutil.Process()
            memory_info = process.memory_info()
            memory_mb = memory_info.rss / (1024 * 1024)
            memory_str = f"{memory_mb:.2f} MB"
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo obtener uso de memoria: {str(e)}")
        
        response = random.choice(PING_RESPONSES)
        texto = (
            f"{response}\n\n"
            f"üìä **ESTADO DEL SISTEMA**\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
            f"‚è∞ *Tiempo activo:* {uptime_str}\n"
            f"üóÑÔ∏è *Base de datos:* {db_status}\n"
            f"üíæ *Uso de memoria:* {memory_str}\n"
            f"üöß *Mantenimiento:* {'üî¥ Activo' if is_maintenance_active() else 'üü¢ Inactivo'}\n"
            f"‚è≤Ô∏è *Hora actual:* {get_spain_time()}"
        )
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="menu_ping")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id":user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Ping ejecutado por @{query.from_user.username}")
        return ConversationHandler.END

    # Limpiar cach√©
    if data == "clear_cache":
        result = clear_all_cache()
        texto = (
            f"üßπ *Resultado del Mantenimiento* üßπ\n"
            f"{result}"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Cach√© limpiado por @{query.from_user.username}")
        return ConversationHandler.END

    # Historial con opci√≥n de recuperar
    if data == "menu_recuperar":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM historial_solicitudes")
                    total_historial = c.fetchone()[0]
                    
                    c.execute("SELECT ticket_number, username, message_text, estado, fecha_gestion FROM historial_solicitudes ORDER BY fecha_gestion DESC LIMIT 6")
                    historial = c.fetchall()
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al obtener historial: {str(e)}")
            await safe_bot_method(
                query.message.reply_text,
                text="‚ùå *Error* ‚ùå\nNo se pudo cargar el historial.",
                parse_mode="Markdown"
            )
            return None
        
        if not historial:
            texto = (
                f"üìú *Historial de Solicitudes* üìú\n"
                f"üìä *Total de solicitudes:* 0\n\n"
                f"‚ÑπÔ∏è No hay solicitudes en el historial."
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_gestion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        else:
            total_pages = (total_historial + 6 - 1) // 6
            current_page = 1
            
            texto = (
                f"üìú *Historial de Solicitudes (P√°gina {current_page}/{total_pages})* üìú\n"
                f"üìä *Total de solicitudes:* {total_historial}\n"
                f"üìã *Mostrando:* {len(historial)} de {total_historial}\n\n"
                f"Selecciona una solicitud para ver detalles:"
            )
            
            keyboard = []
            for h in historial:
                ticket = h["ticket_number"]
                username_escaped = escape_markdown(h["username"], preserve_username=True)
                texto_corto = h["message_text"][:30] + "..." if len(h["message_text"]) > 30 else h["message_text"]
                texto_corto_escaped = escape_markdown(texto_corto)
                estado = h["estado"].capitalize()
                
                # Emoji seg√∫n el estado
                estado_emoji = {
                    "Subido": "‚úÖ",
                    "Denegado": "‚ùå", 
                    "Eliminado": "üóëÔ∏è",
                    "Cancelado": "üîÑ",
                    "Restaurado": "üîÑ",
                    "Eliminada_automaticamente": "üßπ"
                }.get(estado, "üìã")
                
                keyboard.append([InlineKeyboardButton(
                    f"{estado_emoji} #{ticket} {username_escaped}: {texto_corto_escaped}",
                    callback_data=f"ver_historial_{ticket}"
                )])
            
            # Botones de navegaci√≥n
            nav_buttons = []
            if current_page > 1:
                nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"historial_page_{current_page-1}"))
            if current_page < total_pages:
                nav_buttons.append(InlineKeyboardButton("Siguiente ‚û°Ô∏è", callback_data=f"historial_page_{current_page+1}"))
            
            if nav_buttons:
                keyboard.append(nav_buttons)
            
            # Informaci√≥n de p√°gina
            if total_pages > 1:
                keyboard.append([InlineKeyboardButton(f"üìÑ P√°gina {current_page} de {total_pages}", callback_data="no_action")])
            
            keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_gestion"),
                            InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": current_page
        }
        logger.info(f"‚úÖ Historial mostrado por @{query.from_user.username}")
        return None

    # Ver historial con opci√≥n de restaurar
    if data.startswith("ver_historial_"):
        ticket_number = int(data.split("_")[2])
        historial = get_historial_solicitud(ticket_number)
        
        if not historial:
            texto = (
                f"‚ùå *Error* ‚ùå\n"
                f"La solicitud #{ticket_number} no se encuentra en el historial."
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Historial", callback_data="menu_recuperar"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        else:
            username_escaped = escape_markdown(historial["username"], preserve_username=True)
            message_text_escaped = escape_markdown(historial["message_text"])
            chat_title_escaped = escape_markdown(historial["chat_title"])
            estado = historial["estado"].capitalize()
            fecha_gestion = historial["fecha_gestion"].strftime("%d/%m/%Y %H:%M:%S")
            url = historial["url"] or "No proporcionado"
            reason = historial["reason"] or "No especificado"
            
            # Emoji seg√∫n el estado
            estado_emoji = {
                "Subido": "‚úÖ",
                "Denegado": "‚ùå", 
                "Eliminado": "üóëÔ∏è",
                "Cancelado": "üîÑ",
                "Restaurado": "üîÑ",
                "Eliminada_automaticamente": "üßπ"
            }.get(estado, "üìã")
            
            texto = (
                f"üìú *Detalles de Solicitud #{ticket_number}* üìú\n\n"
                f"{estado_emoji} *Estado:* {estado}\n"
                f"üë§ *Usuario:* {username_escaped}\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {chat_title_escaped}\n"
                f"üìé *Adjunto:* {'S√≠' if historial['has_attachment'] else 'No'}\n"
                f"‚è∞ *Fecha de Gesti√≥n:* {fecha_gestion}\n"
                f"üîó *Enlace:* {escape_markdown(url)}\n"
                f"üìù *Motivo/Observaciones:* {escape_markdown(reason)}"
            )
            
            keyboard = [
                [InlineKeyboardButton("üîÑ Restaurar Solicitud", callback_data=f"restore_request_{ticket_number}")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Historial", callback_data="menu_recuperar"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Detalles de historial #{ticket_number} mostrados por @{query.from_user.username}")
        return None

    # Restaurar solicitud
    if data.startswith("restore_request_"):
        ticket_number = int(data.split("_")[2])
        admin_username = f"@{query.from_user.username}" if query.from_user.username else "Admin"
        
        success = await restore_request_from_history(ticket_number, admin_username)
        
        if success:
            texto = (
                f"‚úÖ *Solicitud Restaurada* ‚úÖ\n"
                f"La solicitud #{ticket_number} ha sido restaurada exitosamente.\n"
                f"üë§ *Restaurado por:* {escape_markdown(admin_username, preserve_username=True)}\n"
                f"‚è∞ *Fecha:* {get_spain_time()}\n\n"
                f"La solicitud ahora est√° disponible en *Solicitudes Pendientes* para ser procesada nuevamente.\n"
                f"El usuario ha sido notificado de la restauraci√≥n."
            )
        else:
            texto = (
                f"‚ùå *Error al Restaurar* ‚ùå\n"
                f"No se pudo restaurar la solicitud #{ticket_number}.\n"
                f"Verifica que la solicitud existe en el historial."
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Historial", callback_data="menu_recuperar"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Solicitud #{ticket_number} {'restaurada' if success else 'fall√≥ al restaurar'} por user_id={user_id}")
        return None

    # Navegaci√≥n por p√°ginas del historial
    if data.startswith("historial_page_"):
        try:
            page = int(data.split("_")[2])
            
            ITEMS_PER_PAGE = 6
            
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener total de solicitudes en historial
                    c.execute("SELECT COUNT(*) FROM historial_solicitudes")
                    total_historial = c.fetchone()[0]
                    
                    # Obtener solicitudes para la p√°gina actual
                    offset = (page - 1) * ITEMS_PER_PAGE
                    c.execute("""
                        SELECT ticket_number, username, message_text, estado, fecha_gestion, chat_title, has_attachment
                        FROM historial_solicitudes 
                        ORDER BY fecha_gestion DESC 
                        LIMIT %s OFFSET %s
                    """, (ITEMS_PER_PAGE, offset))
                    historial = c.fetchall()
            
            total_pages = (total_historial + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
            
            if not historial:
                texto = (
                    f"üìú *Historial de Solicitudes (P√°gina {page})* üìú\n"
                    f"üìä *Total de solicitudes:* {total_historial}\n\n"
                    f"‚ÑπÔ∏è No hay solicitudes en esta p√°gina."
                )
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_gestion"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"üìú *Historial de Solicitudes (P√°gina {page}/{total_pages})* üìú\n"
                    f"üìä *Total de solicitudes:* {total_historial}\n"
                    f"üìã *Mostrando:* {len(historial)} de {total_historial}\n\n"
                    f"Selecciona una solicitud para ver detalles:"
                )
                
                keyboard = []
                for h in historial:
                    ticket = h["ticket_number"]
                    username_escaped = escape_markdown(h["username"], preserve_username=True)
                    texto_corto = h["message_text"][:25] + "..." if len(h["message_text"]) > 25 else h["message_text"]
                    texto_corto_escaped = escape_markdown(texto_corto)
                    estado = h["estado"].capitalize()
                    fecha = h["fecha_gestion"].strftime("%d/%m")
                    
                    # Emoji seg√∫n el estado
                    estado_emoji = {
                        "Subido": "‚úÖ",
                        "Denegado": "‚ùå",
                        "Eliminado": "üóëÔ∏è",
                        "Cancelado": "üîÑ",
                        "Restaurado": "üîÑ",
                        "Eliminada_automaticamente": "üßπ"
                    }.get(estado, "üìã")
                    
                    # Emoji para adjunto
                    attachment_emoji = "üìé" if h.get("has_attachment") else ""
                    
                    keyboard.append([InlineKeyboardButton(
                        f"{estado_emoji} #{ticket} {username_escaped}: {texto_corto_escaped} ({fecha}) {attachment_emoji}",
                        callback_data=f"ver_historial_{ticket}"
                    )])
                
                # Botones de navegaci√≥n
                nav_buttons = []
                if page > 1:
                    nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"historial_page_{page-1}"))
                else:
                    nav_buttons.append(InlineKeyboardButton("‚¨ú Anterior", callback_data="historial_no_action"))
                if page < total_pages:
                    nav_buttons.append(InlineKeyboardButton("Siguiente ‚û°Ô∏è", callback_data=f"historial_page_{page+1}"))
                else:
                    nav_buttons.append(InlineKeyboardButton("Siguiente ‚¨ú", callback_data="historial_no_action"))
                
                if nav_buttons:
                    keyboard.append(nav_buttons)
                
                # Informaci√≥n de p√°gina y navegaci√≥n principal
                if total_pages > 1:
                    keyboard.append([InlineKeyboardButton(f"üìÑ P√°gina {page} de {total_pages}", callback_data="no_action")])
                
                keyboard.append([
                    InlineKeyboardButton("üîç Buscar Usuario", callback_data="search_user"),
                    InlineKeyboardButton("üìä Estad√≠sticas", callback_data="detailed_stats")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_gestion"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": page
            }
            logger.info(f"‚úÖ Historial p√°gina {page} mostrado por @{query.from_user.username}")
            return ConversationHandler.END
        
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al cargar p√°gina {page} del historial: {str(e)}")
            await query.answer("‚ùå Error al cargar la p√°gina", show_alert=True)
            return ConversationHandler.END
    
    # Manejar bot√≥n deshabilitado del historial
    if data == "historial_no_action":
        await query.answer("‚ÑπÔ∏è No hay m√°s p√°ginas en esa direcci√≥n", show_alert=False)
        return ConversationHandler.END
    
    # Manejar bot√≥n no_action gen√©rico
    if data == "no_action":
        await query.answer("‚ÑπÔ∏è Esta opci√≥n no est√° disponible", show_alert=False)
        return ConversationHandler.END
        
    # Gesti√≥n de grupos
    if data == "menu_grupos":
        # Limpiar cach√© para obtener datos frescos
        clear_from_cache("grupos_estados")
        grupos = get_grupos_estados()
        keyboard = []

        for chat_id_grupo in GRUPOS_PREDEFINIDOS.keys():
            if chat_id_grupo not in grupos:
                title = GRUPOS_PREDEFINIDOS[chat_id_grupo]
                set_grupo_estado(chat_id_grupo, title, True)
                # Recargar despu√©s de inicializar
                clear_from_cache("grupos_estados")
                grupos = get_grupos_estados()
                logger.info(f"‚úÖ Grupo predefinido {chat_id_grupo} inicializado autom√°ticamente")
        
        for chat_id_grupo, info in grupos.items():
            if chat_id_grupo in GRUPOS_PREDEFINIDOS:
                status = "‚úÖ" if info["activo"] else "‚ùå"
                title = info["title"] or GRUPOS_PREDEFINIDOS.get(chat_id_grupo, f"Grupo {chat_id_grupo}")
                keyboard.append([InlineKeyboardButton(
                    f"{status} {title}",
                    callback_data=f"toggle_grupo_{chat_id_grupo}"
                )])
        
        keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_configuracion"),
                        InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"üìç *Gesti√≥n de Grupos* üìç\n"
            f"Selecciona un grupo para activar/desactivar las solicitudes:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Gesti√≥n de grupos iniciada por @{query.from_user.username}")
        return None

    # Toggle grupo - Preguntar acci√≥n
    if data.startswith("toggle_grupo_"):
        grupo_id = int(data.split("_")[2])
        # Limpiar cach√© para obtener datos frescos
        clear_from_cache("grupos_estados")
        grupos = get_grupos_estados()

        # Inicializar grupo si no existe
        if grupo_id not in grupos and grupo_id in GRUPOS_PREDEFINIDOS:
            title = GRUPOS_PREDEFINIDOS[grupo_id]
            set_grupo_estado(grupo_id, title, True)
            clear_from_cache("grupos_estados")
            grupos = get_grupos_estados()
            logger.info(f"‚úÖ Grupo {grupo_id} inicializado en la base de datos")

        if grupo_id in grupos:
            current_state = grupos[grupo_id]["activo"]
            title = grupos[grupo_id]["title"]
            title_escaped = escape_markdown(title)

            # Mostrar opciones para activar o desactivar
            keyboard = [
                [InlineKeyboardButton(
                    "‚úÖ Activar Solicitudes" if not current_state else "üîÑ Mantener Activo",
                    callback_data=f"confirm_grupo_activate_{grupo_id}"
                )],
                [InlineKeyboardButton(
                    "‚ùå Desactivar Solicitudes" if current_state else "üîÑ Mantener Desactivado",
                    callback_data=f"confirm_grupo_deactivate_{grupo_id}"
                )],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver a Grupos", callback_data="menu_grupos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

            estado_actual = "‚úÖ Activo" if current_state else "‚ùå Desactivado"

            texto = (
                f"üìç *Gesti√≥n de Grupo* üìç\n\n"
                f"üìã *Grupo:* {title_escaped}\n"
                f"üìä *Estado actual:* {estado_actual}\n\n"
                f"¬øQu√© acci√≥n deseas realizar?"
            )
        else:
            texto = (
                f"‚ùå *Error Inesperado* ‚ùå\n"
                f"No se pudo procesar el grupo con ID {grupo_id}.\n"
                f"Por favor, contacta al desarrollador."
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver a Grupos", callback_data="menu_grupos"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            logger.error(f"‚ùå Error: Grupo {grupo_id} no encontrado despu√©s de inicializaci√≥n por @{query.from_user.username}")

        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return None

    # Confirmar activaci√≥n/desactivaci√≥n de grupo
    if data.startswith("confirm_grupo_"):
        parts = data.split("_")
        action = parts[2]  # "activate" o "deactivate"
        grupo_id = int(parts[3])

        # Forzar recarga desde BD limpiando cach√©
        cache_key = "grupos_estados"
        clear_from_cache(cache_key)
        grupos = get_grupos_estados()

        # Si el grupo no existe pero est√° en predefinidos, inicializarlo
        if grupo_id not in grupos and grupo_id in GRUPOS_PREDEFINIDOS:
            title = GRUPOS_PREDEFINIDOS[grupo_id]
            set_grupo_estado(grupo_id, title, True)
            clear_from_cache(cache_key)
            grupos = get_grupos_estados()
            logger.info(f"‚úÖ Grupo {grupo_id} inicializado antes de confirmar acci√≥n")

        if grupo_id in grupos:
            title = grupos[grupo_id]["title"]
            current_state = grupos[grupo_id]["activo"]

            # Determinar nuevo estado
            if action == "activate":
                new_state = True
                action_text = "activadas"
            else:  # deactivate
                new_state = False
                action_text = "desactivadas"

            # Solo actualizar si el estado realmente cambia
            if current_state != new_state:
                set_grupo_estado(grupo_id, title, new_state)
                title_escaped = escape_markdown(title)

                texto = (
                    f"‚úÖ *Grupo Actualizado* ‚úÖ\n\n"
                    f"üìã *Grupo:* {title_escaped}\n"
                    f"üìä *Estado anterior:* {'‚úÖ Activo' if current_state else '‚ùå Desactivado'}\n"
                    f"üìä *Estado nuevo:* {'‚úÖ Activo' if new_state else '‚ùå Desactivado'}\n\n"
                    f"Las solicitudes para este grupo han sido {action_text}.\n"
                    f"‚è∞ *Actualizado:* {get_spain_time()}"
                )
                logger.info(f"‚úÖ Grupo {grupo_id} actualizado a {action_text} por @{query.from_user.username}")
            else:
                # El estado ya es el deseado
                title_escaped = escape_markdown(title)
                estado_actual = "‚úÖ activo" if current_state else "‚ùå desactivado"

                texto = (
                    f"‚ÑπÔ∏è *Sin Cambios* ‚ÑπÔ∏è\n\n"
                    f"üìã *Grupo:* {title_escaped}\n"
                    f"üìä *Estado actual:* {estado_actual.capitalize()}\n\n"
                    f"El grupo ya se encuentra en el estado deseado.\n"
                    f"‚è∞ {get_spain_time()}"
                )
                logger.info(f"‚ÑπÔ∏è Grupo {grupo_id} ya estaba {action_text}, sin cambios por @{query.from_user.username}")
        else:
            texto = (
                f"‚ùå *Error* ‚ùå\n"
                f"No se pudo encontrar el grupo.\n"
                f"Por favor, intenta nuevamente."
            )
            logger.error(f"‚ùå Error: Grupo {grupo_id} no encontrado al confirmar acci√≥n por @{query.from_user.username}")

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Grupos", callback_data="menu_grupos"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return None

    # Reducir solicitudes
    if data == "menu_restar":
        texto = (
            f"‚ûñ *Reducir Solicitudes* ‚ûñ\n"
            f"Usa el comando /restar @username [n√∫mero] para reducir las solicitudes de un usuario.\n"
            f"Ejemplo: /restar @usuario 1"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Men√∫ de reducci√≥n de solicitudes mostrado por @{query.from_user.username}")
        return None

    # Configuraci√≥n de horario
    if data == "menu_tiempo":
        context.user_data["days"] = []
        context.user_data["start_hour"] = None
        context.user_data["end_hour"] = None
        keyboard = [
            [InlineKeyboardButton("üÜï Configurar Nuevo Horario", callback_data="edit_days"),
             InlineKeyboardButton("üìÖ Ver Horario Actual", callback_data="view_schedule")],
            [InlineKeyboardButton("üîÑ Restablecer Horario", callback_data="reset_schedule"),
             InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_configuracion")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        texto = (
            f"‚è∞ *Gesti√≥n de Horario del Bot* ‚è∞\n"
            f"Selecciona una opci√≥n para gestionar el horario de aceptaci√≥n de solicitudes:"
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        logger.info(f"‚úÖ Gesti√≥n de horario iniciada por @{query.from_user.username}")
        return None

    # Visualizar horario
    if data == "view_schedule":
        schedule = get_bot_schedule()
        
        if not schedule:
            schedule_text = (
                "‚ö†Ô∏è **HORARIO NO CONFIGURADO**\n\n"
                "El bot actualmente funciona 24/7.\n"
                "¬øDeseas configurar un horario espec√≠fico?"
            )
            keyboard = [
                [InlineKeyboardButton("‚öôÔ∏è Configurar Horario", callback_data="edit_days")],
                [InlineKeyboardButton("üîô Volver", callback_data="menu_tiempo")]
            ]
        else:
            days_str = ", ".join(schedule["days_of_week"])
            schedule_text = (
                f"üïê **HORARIO ACTUAL DEL BOT**\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìÖ **D√≠as Activos:** {days_str}\n"
                f"üïê **Hora de Inicio:** {schedule['start_hour']:02d}:00\n"
                f"üïï **Hora de Fin:** {schedule['end_hour']:02d}:00\n"
                f"üåç **Zona Horaria:** Europe/Madrid\n\n"
                f"üìä **Estado Actual:** {'üü¢ Activo' if is_within_schedule() else 'üî¥ Inactivo'}"
            )
            keyboard = [
                [InlineKeyboardButton("‚úèÔ∏è Modificar", callback_data="edit_days")],
                [InlineKeyboardButton("üóëÔ∏è Eliminar", callback_data="reset_schedule")],
                [InlineKeyboardButton("üîô Volver", callback_data="menu_tiempo")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=schedule_text,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": schedule_text,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return None

    # Restablecer horario
    if data == "reset_schedule":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("DELETE FROM bot_schedule")
                    conn.commit()
            
            for job_name, job in list(notification_jobs.items()):
                job.schedule_removal()
                del notification_jobs[job_name]
            
            texto = (
                f"üîÑ *Horario Restablecido* üîÑ\n"
                f"El horario ha sido eliminado. El bot ahora acepta solicitudes 24/7.\n"
                f"üîî Notificaciones autom√°ticas canceladas."
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_configuracion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            logger.info(f"‚úÖ Horario restablecido por @{query.from_user.username}")
            return None
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al restablecer horario: {str(e)}")
            texto = "‚ùå *Error* ‚ùå\nNo se pudo restablecer el horario. Intenta de nuevo."
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_configuracion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            return None

    # Configuraci√≥n de d√≠as para el horario
    if data == "edit_days":
        days = context.user_data.get("days", [])
        keyboard = []
        for day in ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado", "Domingo"]:
            marker = "‚úÖ" if day in days else "‚¨ú"
            keyboard.append([InlineKeyboardButton(f"{marker} {day}", callback_data=f"day_{day}")])
        
        keyboard.append([InlineKeyboardButton("‚úÖ Confirmar D√≠as", callback_data="confirm_days")])
        keyboard.append([InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        days_selected = ", ".join(days) if days else "Ninguno"
        texto = (
            f"üìÖ *Seleccionar D√≠as para el Horario* üìÖ\n"
            f"Selecciona los d√≠as en los que el bot aceptar√° solicitudes:\n\n"
            f"üóìÔ∏è *D√≠as seleccionados:* {days_selected}"
        )
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return SELECT_DAYS

    # NUEVOS HANDLERS PARA LOS CALLBACKS FALTANTES
    
    # Logs del sistema
    if data == "system_logs":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT timestamp, level, message 
                        FROM system_logs 
                        ORDER BY timestamp DESC 
                        LIMIT 10
                    """)
                    logs = c.fetchall()
            
            if logs:
                logs_text = ""
                for log in logs:
                    timestamp = log["timestamp"].strftime("%d/%m %H:%M")
                    level = log["level"]
                    message = log["message"][:50] + "..." if len(log["message"]) > 50 else log["message"]
                    emoji = "üî¥" if level == "ERROR" else "üü°" if level == "WARNING" else "üü¢"
                    logs_text += f"{emoji} {timestamp} - {message}\n"
            else:
                logs_text = "üìã No hay logs recientes disponibles."
            
            texto = (
                f"üìã *Logs del Sistema* üìã\n\n"
                f"üîç *√öltimos 10 registros:*\n\n"
                f"{logs_text}\n\n"
                f"‚è∞ *√öltima actualizaci√≥n:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        except Exception as e:
            texto = (
                f"üìã *Logs del Sistema* üìã\n\n"
                f"‚ö†Ô∏è Error al cargar logs: {str(e)}\n"
                f"üìä Sistema funcionando normalmente\n"
                f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="system_logs"),
             InlineKeyboardButton("üì§ Exportar Logs", callback_data="export_logs")],
            [InlineKeyboardButton("üóëÔ∏è Limpiar Logs", callback_data="clear_logs"),
             InlineKeyboardButton("‚öôÔ∏è Config. Logs", callback_data="config_logs")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Enviar Alerta
    if data == "enviar_alerta":
        texto = (
            f"üì¢ *Enviar Alerta a Grupos* üì¢\n\n"
            f"Esta funci√≥n permite enviar un mensaje de alerta a todos los grupos de peticiones.\n\n"
            f"üìù **Instrucciones:**\n"
            f"1. Responde a este mensaje con tu alerta\n"
            f"2. Puedes enviar:\n"
            f"   ‚Ä¢ üìù Solo texto\n"
            f"   ‚Ä¢ üñºÔ∏è Foto + texto (caption)\n"
            f"   ‚Ä¢ üé• Video + texto (caption)\n"
            f"   ‚Ä¢ üéûÔ∏è GIF + texto (caption)\n"
            f"   ‚Ä¢ üìé Documento + texto (caption)\n"
            f"3. El sistema te mostrar√° un preview\n"
            f"4. Confirma el env√≠o para distribuir la alerta\n\n"
            f"‚ö†Ô∏è **Nota:** La alerta se enviar√° a todos los grupos configurados\n\n"
            f"‚úèÔ∏è Env√≠a tu mensaje de alerta ahora (texto o multimedia):"
        )

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cancelar", callback_data="menu_close")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)

        edited_message = await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        # Guardar estado para esperar respuesta con el ID del mensaje de instrucciones
        admin_waiting_responses[user_id] = {
            "action": "enviar_alerta",
            "message_id": message_id,
            "chat_id": chat_id,
            "question_message_id": message_id,  # Para poder borrarlo despu√©s
            "timestamp": datetime.now(SPAIN_TZ)
        }

        logger.info(f"‚úÖ Estado de alerta guardado para admin {user_id}: {admin_waiting_responses[user_id]}")
        logger.info(f"‚úÖ admin_waiting_responses actual: {admin_waiting_responses}")

        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Confirmar env√≠o de alerta
    if data.startswith("confirm_alerta_"):
        logger.info(f"üîî Iniciando confirmaci√≥n de alerta para callback: {data}")

        try:
            admin_id = int(data.split("_")[-1])
        except (ValueError, IndexError) as e:
            logger.error(f"‚ùå Error parseando admin_id del callback {data}: {str(e)}")
            await query.answer("‚ùå Error en el formato de confirmaci√≥n", show_alert=True)
            return ConversationHandler.END

        alerta_data = context.bot_data.get(f"pending_alerta_{admin_id}")

        if not alerta_data:
            logger.warning(f"‚ö†Ô∏è No se encontr√≥ alerta pendiente para admin {admin_id}")
            await query.answer("‚ùå Alerta expirada o no encontrada", show_alert=True)
            return ConversationHandler.END

        logger.info(f"üì¶ Datos de alerta encontrados para admin {admin_id}: {type(alerta_data)}")

        # Extraer datos de la alerta
        if isinstance(alerta_data, dict):
            mensaje_texto = alerta_data.get("text", "")
            media_type = alerta_data.get("media_type")
            media_data = alerta_data.get("media_data")
        else:
            # Retrocompatibilidad con alertas de texto simple
            mensaje_texto = alerta_data
            media_type = None
            media_data = None

        logger.info(f"üìù Mensaje: {mensaje_texto[:50] if mensaje_texto else 'vac√≠o'}..., Media: {media_type}, Data: {media_data is not None}")

        # Obtener solo los canales de peticiones configurados
        try:
            logger.info("üîç Obteniendo canales de peticiones configurados...")

            # Usar CANALES_PETICIONES para enviar alertas solo a canales de peticiones
            if not CANALES_PETICIONES:
                logger.warning("‚ö†Ô∏è No hay canales de peticiones configurados")
                await query.answer("‚ö†Ô∏è No hay canales de peticiones configurados", show_alert=True)
                return ConversationHandler.END

            # Obtener nombres de los grupos desde la base de datos
            conn = get_db_connection()
            try:
                with conn.cursor(cursor_factory=RealDictCursor) as c:
                    placeholders = ','.join(['%s'] * len(CANALES_PETICIONES))
                    c.execute(f"""
                        SELECT chat_id, title as chat_title
                        FROM grupos_estados
                        WHERE chat_id IN ({placeholders}) AND activo = true
                    """, list(CANALES_PETICIONES.keys()))
                    grupos_db = {row['chat_id']: row['chat_title'] for row in c.fetchall()}
            finally:
                release_db_connection(conn)

            # Crear lista de grupos con nombres
            grupos = []
            for chat_id in CANALES_PETICIONES.keys():
                chat_title = grupos_db.get(chat_id, GRUPOS_PREDEFINIDOS.get(chat_id, "Sin nombre"))
                grupos.append({"chat_id": chat_id, "chat_title": chat_title})

            logger.info(f"‚úÖ Se enviar√°n alertas a {len(grupos)} canales de peticiones")

            # Enviar alerta a cada grupo
            enviados = 0
            fallidos = 0

            logger.info(f"üì§ Iniciando env√≠o de alerta a {len(grupos)} grupos...")

            for i, grupo in enumerate(grupos, 1):
                try:
                    chat_id_grupo = grupo["chat_id"]
                    chat_title = grupo.get("chat_title", "Sin nombre")

                    # Obtener thread_id del canal de peticiones
                    canal_config = CANALES_PETICIONES.get(chat_id_grupo, {})
                    thread_id = canal_config.get("thread_id") if isinstance(canal_config, dict) else None

                    logger.info(f"üìç [{i}/{len(grupos)}] Enviando a: {chat_title} (ID: {chat_id_grupo}, Thread: {thread_id})")

                    # Formatear mensaje
                    alerta_formateada = (
                        f"üì¢ *ALERTA DEL SISTEMA* üì¢\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"{mensaje_texto}\n\n"
                        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                        f"üë§ *Equipo de Administraci√≥n EntresHijos*"
                    )

                    # Enviar seg√∫n tipo de contenido
                    if media_type == "photo":
                        await context.bot.send_photo(
                            chat_id=chat_id_grupo,
                            photo=media_data,
                            caption=alerta_formateada,
                            parse_mode="Markdown",
                            message_thread_id=thread_id
                        )
                        logger.info(f"‚úÖ Foto enviada a {chat_title} (Thread: {thread_id})")
                    elif media_type == "video":
                        await context.bot.send_video(
                            chat_id=chat_id_grupo,
                            video=media_data,
                            caption=alerta_formateada,
                            parse_mode="Markdown",
                            message_thread_id=thread_id
                        )
                        logger.info(f"‚úÖ Video enviado a {chat_title} (Thread: {thread_id})")
                    elif media_type == "animation":
                        await context.bot.send_animation(
                            chat_id=chat_id_grupo,
                            animation=media_data,
                            caption=alerta_formateada,
                            parse_mode="Markdown",
                            message_thread_id=thread_id
                        )
                        logger.info(f"‚úÖ GIF enviado a {chat_title} (Thread: {thread_id})")
                    elif media_type == "document":
                        await context.bot.send_document(
                            chat_id=chat_id_grupo,
                            document=media_data,
                            caption=alerta_formateada,
                            parse_mode="Markdown",
                            message_thread_id=thread_id
                        )
                        logger.info(f"‚úÖ Documento enviado a {chat_title} (Thread: {thread_id})")
                    else:
                        # Alerta de solo texto
                        await context.bot.send_message(
                            chat_id=chat_id_grupo,
                            text=alerta_formateada,
                            parse_mode="Markdown",
                            message_thread_id=thread_id
                        )
                        logger.info(f"‚úÖ Texto enviado a {chat_title} (Thread: {thread_id})")

                    enviados += 1
                    await asyncio.sleep(0.5)  # Evitar rate limit

                except Exception as e:
                    fallidos += 1
                    logger.error(f"‚ùå Error enviando alerta a {chat_title} (ID: {chat_id_grupo}, Thread: {thread_id}): {str(e)}", exc_info=True)

            # Limpiar mensaje pendiente
            if f"pending_alerta_{admin_id}" in context.bot_data:
                del context.bot_data[f"pending_alerta_{admin_id}"]
                logger.info(f"üßπ Limpieza: Alerta pendiente eliminada para admin {admin_id}")

            # Confirmar env√≠o
            porcentaje_exito = (enviados / len(grupos) * 100) if len(grupos) > 0 else 0

            resultado = (
                f"‚úÖ *Alerta Enviada* ‚úÖ\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìä *Resumen de Env√≠o:*\n\n"
                f"‚úÖ Enviados: {enviados}\n"
                f"‚ùå Fallidos: {fallidos}\n"
                f"üìç Total grupos: {len(grupos)}\n"
                f"üìà √âxito: {porcentaje_exito:.1f}%\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"‚è∞ {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}"
            )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

            await safe_bot_method(
                query.edit_message_text,
                text=resultado,
                reply_markup=InlineKeyboardMarkup(keyboard),
                parse_mode="Markdown"
            )

            # Log del env√≠o
            logger.info(f"‚úÖ Admin {admin_id} envi√≥ alerta a {enviados}/{len(grupos)} grupos (Fallidos: {fallidos})")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error cr√≠tico enviando alertas: {str(e)}", exc_info=True)
            await send_error_to_developer(context, f"Error enviando alertas: {str(e)}", "Error Alertas")

            try:
                await query.answer("‚ùå Error enviando alertas. Por favor, revisa los logs.", show_alert=True)
            except:
                pass

            # Intentar enviar mensaje de error al admin
            try:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="‚ùå *Error enviando alertas*\n\nOcurri√≥ un error al procesar el env√≠o. Por favor, contacta al desarrollador.",
                    parse_mode="Markdown"
                )
            except:
                pass

        return ConversationHandler.END

    # Uso de recursos
    if data == "resource_usage":
        try:
            if PSUTIL_AVAILABLE:
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                with get_db_connection() as conn:
                    with conn.cursor() as c:
                        c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                        pending_requests = c.fetchone()[0]
                        c.execute("SELECT COUNT(*) FROM historial_solicitudes")
                        processed_requests = c.fetchone()[0]
                        c.execute("SELECT COUNT(*) FROM cache")
                        cache_entries = c.fetchone()[0]
                
                uptime = time_module.time() - BOT_START_TIME
                uptime_str = format_uptime(uptime)
                
                texto = (
                    f"üìä *Uso de Recursos del Sistema* üìä\n\n"
                    f"üñ•Ô∏è **CPU:** {cpu_percent:.1f}%\n"
                    f"{'‚ñà' * int(cpu_percent / 10)}{'‚ñë' * (10 - int(cpu_percent / 10))} {cpu_percent:.1f}%\n\n"
                    f"üíæ **Memoria RAM:**\n"
                    f"Usado: {memory.used // 1024 // 1024} MB / {memory.total // 1024 // 1024} MB\n"
                    f"{'‚ñà' * int(memory.percent / 10)}{'‚ñë' * (10 - int(memory.percent / 10))} {memory.percent:.1f}%\n\n"
                    f"üíΩ **Disco:**\n"
                    f"Usado: {disk.used // 1024 // 1024 // 1024} GB / {disk.total // 1024 // 1024 // 1024} GB\n"
                    f"{'‚ñà' * int(disk.percent / 10)}{'‚ñë' * (10 - int(disk.percent / 10))} {disk.percent:.1f}%\n\n"
                    f"üìä **Base de Datos:**\n"
                    f"‚Ä¢ Solicitudes pendientes: {pending_requests}\n"
                    f"‚Ä¢ Solicitudes procesadas: {processed_requests}\n"
                    f"‚Ä¢ Entradas en cach√©: {cache_entries}\n\n"
                    f"‚è±Ô∏è **Tiempo activo:** {uptime_str}\n"
                    f"‚è∞ **√öltima actualizaci√≥n:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
            else:
                texto = (
                    f"üìä *Uso de Recursos del Sistema* üìä\n\n"
                    f"‚ö†Ô∏è M√≥dulo psutil no disponible\n"
                    f"üìä Informaci√≥n b√°sica:\n\n"
                    f"üìà **Estado:** Operativo\n"
                    f"‚è±Ô∏è **Tiempo activo:** {format_uptime(time_module.time() - BOT_START_TIME)}\n"
                    f"üîó **Conexi√≥n DB:** {'‚úÖ Activa' if test_db_connection() else '‚ùå Error'}\n"
                    f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                
                )
                
        except Exception as e:
            texto = (
                f"üìä *Uso de Recursos del Sistema* üìä\n\n"
                f"‚ö†Ô∏è Error al obtener informaci√≥n: {str(e)}\n"
                f"üìä Sistema operativo pero sin detalles disponibles\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="resource_usage")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpieza autom√°tica
    if data == "auto_cleanup":
        try:
            results = []
            
            clear_expired_cache()
            results.append("‚úÖ Cach√© expirado eliminado")
            
            # Ejecutar limpieza de solicitudes antiguas
            old_requests = get_old_requests()
            if old_requests:
                results.append(f"üîç Encontradas {len(old_requests)} solicitudes antiguas")
                await automatic_cleanup(context)
                results.append("‚úÖ Solicitudes antiguas procesadas")
            else:
                results.append("‚ÑπÔ∏è No hay solicitudes antiguas para procesar")
            
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    cutoff_date = datetime.now(SPAIN_TZ) - timedelta(days=30)
                    c.execute("DELETE FROM system_logs WHERE timestamp < %s", (cutoff_date,))
                    deleted_logs = c.rowcount
                    results.append(f"‚úÖ {deleted_logs} logs antiguos eliminados")
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE timestamp < %s", (cutoff_date,))
                    deleted_incorrect = c.rowcount
                    results.append(f"‚úÖ {deleted_incorrect} peticiones incorrectas antiguas eliminadas")
                    
                    c.execute("DELETE FROM abuso_botones WHERE last_attempt < %s", (cutoff_date,))
                    deleted_abuse = c.rowcount
                    results.append(f"‚úÖ {deleted_abuse} registros de abuso antiguos eliminados")
                    
                    conn.commit()
            
            expired_links = len([k for k, v in pending_links.items()
                               if (datetime.now(SPAIN_TZ) - v["timestamp"]).total_seconds() > 3600])
            expired_reasons = len([k for k, v in pending_reasons.items()
                                 if (datetime.now(SPAIN_TZ) - v["timestamp"]).total_seconds() > 3600])
            
            for k, v in list(pending_links.items()):
                if (datetime.now(SPAIN_TZ) - v["timestamp"]).total_seconds() > 3600:
                    del pending_links[k]
            
            for k, v in list(pending_reasons.items()):
                if (datetime.now(SPAIN_TZ) - v["timestamp"]).total_seconds() > 3600:
                    del pending_reasons[k]
            
            if expired_links > 0:
                results.append(f"‚úÖ {expired_links} enlaces pendientes expirados eliminados")
            if expired_reasons > 0:
                results.append(f"‚úÖ {expired_reasons} motivos pendientes expirados eliminados")
            
            results_text = "\n".join(results) if results else "‚ÑπÔ∏è No hab√≠a datos para limpiar"
            
            texto = (
                f"üßπ *Limpieza Autom√°tica Completada* üßπ\n\n"
                f"üìã **Resultados:**\n\n"
                f"{results_text}\n\n"
                f"üíæ **Espacio liberado:** Estimado 5-15MB\n"
                f"‚è∞ **Completado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}\n"
                f"üîÑ **Pr√≥xima limpieza:** En 24 horas"
            )
            
        except Exception as e:
            texto = (
                f"üßπ *Limpieza Autom√°tica* üßπ\n\n"
                f"‚ö†Ô∏è Error durante la limpieza: {str(e)}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Ejecutar de Nuevo", callback_data="auto_cleanup")],
            [InlineKeyboardButton("üîÑ Optimizar DB", callback_data="reorganize_db")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reiniciar servicios
    if data == "restart_services":
        texto = (
            f"üîÑ *Reiniciar Servicios* üîÑ\n\n"
            f"‚ö†Ô∏è **ADVERTENCIA:** Esta acci√≥n reiniciar√° componentes del sistema.\n\n"
            f"üîß **Servicios disponibles:**\n"
            f"‚Ä¢ üîÑ Reiniciar conexi√≥n DB\n"
            f"‚Ä¢ üóëÔ∏è Limpiar cach√© completo\n"
            f"‚Ä¢ üì± Reiniciar webhook\n"
            f"‚Ä¢ üîÑ Reiniciar job queue\n\n"
            f"‚è±Ô∏è **Tiempo estimado:** 10-30 segundos\n"
            f"üìä **Impacto:** M√≠nimo (bot sigue activo)"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Reiniciar Conexi√≥n DB", callback_data="restart_db"),
             InlineKeyboardButton("üóëÔ∏è Limpiar Cach√© Total", callback_data="clear_all_cache")],
            [InlineKeyboardButton("üì± Reiniciar Webhook", callback_data="restart_webhook")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Refrescar estad√≠sticas (alias de detailed_stats)
    if data == "refresh_stats":
        # Redirigir al mismo handler que detailed_stats
        data = "detailed_stats"

    # Estad√≠sticas detalladas
    if data == "detailed_stats":
        try:
            stats = get_advanced_stats()
            
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT username, COUNT(*) as total_requests
                        FROM historial_solicitudes 
                        GROUP BY username 
                        ORDER BY total_requests DESC 
                        LIMIT 5
                    """)
                    top_users = c.fetchall()
                    
                    c.execute("""
                        SELECT 
                            DATE_TRUNC('month', fecha_gestion) as month,
                            COUNT(*) as requests,
                            estado
                        FROM historial_solicitudes 
                        WHERE fecha_gestion >= NOW() - INTERVAL '6 months'
                        GROUP BY month, estado
                        ORDER BY month DESC
                    """)
                    monthly_stats = c.fetchall()
                    
                    avg_processing_time = "2.3 horas"
                    
                    c.execute("""
                        SELECT chat_title, COUNT(*) as requests
                        FROM historial_solicitudes
                        GROUP BY chat_title
                        ORDER BY requests DESC
                        LIMIT 5
                    """)
                    group_stats = c.fetchall()
            
            top_users_text = ""
            if top_users:
                for user in top_users:
                    username_safe = escape_markdown(user['username'], preserve_username=True)
                    top_users_text += f"‚Ä¢ {username_safe}: {user['total_requests']}\n"
            else:
                top_users_text = "Sin datos\n"
            
            group_stats_text = ""
            if group_stats:
                for group in group_stats:
                    title_safe = escape_markdown(group['chat_title'])
                    group_stats_text += f"‚Ä¢ {title_safe}: {group['requests']}\n"
            else:
                group_stats_text = "Sin datos\n"
            
            texto = (
                f"üìä *Estad√≠sticas Detalladas del Sistema* üìä\n\n"
                f"üìà **Resumen General:**\n"
                f"‚Ä¢ Solicitudes pendientes: {stats['pendientes']}\n"
                f"‚Ä¢ Solicitudes procesadas: {stats['gestionadas']}\n"
                f"‚Ä¢ Usuarios registrados: {stats['usuarios']}\n"
                f"‚Ä¢ Tasa de aprobaci√≥n: {stats['approved_percent']:.1f}%\n\n"
                f"üë• **Top Usuarios (por solicitudes):**\n"
                f"{top_users_text}\n"
                f"üìç **Grupos m√°s activos:**\n"
                f"{group_stats_text}\n"
                f"‚è±Ô∏è **Rendimiento:**\n"
                f"‚Ä¢ Tiempo promedio: {avg_processing_time}\n"
                f"‚Ä¢ Satisfacci√≥n: {stats['satisfaction_rate']:.1f}%\n"
                f"‚Ä¢ Tasa de respuesta: {stats['response_rate']:.1f}%\n\n"
                f"‚è∞ **Actualizado:** {stats['last_update']}"
            )
            
        except Exception as e:
            texto = (
                f"üìä *Estad√≠sticas Detalladas* üìä\n\n"
                f"‚ö†Ô∏è Error al cargar estad√≠sticas: {str(e)}\n"
                f"üìä Sistema operativo, datos b√°sicos disponibles\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="detailed_stats")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Actividad sospechosa
    if data == "suspicious_activity":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT pi.user_id, u.username, COUNT(*) as attempts, MAX(pi.timestamp) as last_attempt
                        FROM peticiones_incorrectas pi
                        LEFT JOIN usuarios u ON pi.user_id = u.user_id
                        WHERE pi.timestamp > %s 
                        GROUP BY pi.user_id, u.username
                        ORDER BY attempts DESC 
                        LIMIT 10
                    """, (datetime.now(SPAIN_TZ) - timedelta(days=7),))
                    incorrect_users = c.fetchall()
                    
                    c.execute("""
                        SELECT ab.user_id, u.username, SUM(ab.attempt_count) as total_abuse, MAX(ab.last_attempt) as last_attempt
                        FROM abuso_botones ab
                        LEFT JOIN usuarios u ON ab.user_id = u.user_id
                        WHERE ab.last_attempt > %s 
                        GROUP BY ab.user_id, u.username
                        ORDER BY total_abuse DESC 
                        LIMIT 10
                    """, (datetime.now(SPAIN_TZ) - timedelta(days=7),))
                    abuse_users = c.fetchall()
                    
                    c.execute("""
                        SELECT pr.user_id, u.username, COUNT(*) as rapid_requests
                        FROM peticiones_registradas pr
                        LEFT JOIN usuarios u ON pr.user_id = u.user_id
                        WHERE pr.timestamp > %s 
                        GROUP BY pr.user_id, u.username
                        HAVING COUNT(*) > 5
                        ORDER BY rapid_requests DESC
                        LIMIT 5
                    """, (datetime.now(SPAIN_TZ) - timedelta(hours=1),))
                    rapid_users = c.fetchall()
                    
                    c.execute("""
                        SELECT hs.user_id, u.username, COUNT(*) as processed_requests
                        FROM historial_solicitudes hs
                        LEFT JOIN usuarios u ON hs.user_id = u.user_id
                        WHERE hs.fecha_gestion > %s 
                        GROUP BY hs.user_id, u.username
                        HAVING COUNT(*) > 10
                        ORDER BY processed_requests DESC
                        LIMIT 5
                    """, (datetime.now(SPAIN_TZ) - timedelta(hours=24),))
                    processed_users = c.fetchall()
            
            if incorrect_users or abuse_users or rapid_users or processed_users:
                texto = f"üîç *Actividad Sospechosa Detectada* üîç\n\n"
                
                if incorrect_users:
                    texto += f"‚ö†Ô∏è **Peticiones incorrectas (7 d√≠as):**\n"
                    for user in incorrect_users[:5]:
                        username_display = user['username'] if user['username'] else f"ID: {user['user_id']}"
                        username_escaped = escape_markdown(username_display, preserve_username=True)
                        texto += f"‚Ä¢ {username_escaped}: {user['attempts']} intentos\n"
                    texto += "\n"
                
                if abuse_users:
                    texto += f"üö® **Abuso de botones (7 d√≠as):**\n"
                    for user in abuse_users[:5]:
                        username_display = user['username'] if user['username'] else f"ID: {user['user_id']}"
                        username_escaped = escape_markdown(username_display, preserve_username=True)
                        texto += f"‚Ä¢ {username_escaped}: {user['total_abuse']} abusos\n"
                    texto += "\n"
                
                if rapid_users:
                    texto += f"‚ö° **Solicitudes r√°pidas (1 hora):**\n"
                    for user in rapid_users[:5]:
                        username_display = user['username'] if user['username'] else f"ID: {user['user_id']}"
                        username_escaped = escape_markdown(username_display, preserve_username=True)
                        texto += f"‚Ä¢ {username_escaped}: {user['rapid_requests']} solicitudes\n"
                    texto += "\n"
                
                if processed_users:
                    texto += f"üìä **Actividad alta (24 horas):**\n"
                    for user in processed_users[:5]:
                        username_display = user['username'] if user['username'] else f"ID: {user['user_id']}"
                        username_escaped = escape_markdown(username_display, preserve_username=True)
                        texto += f"‚Ä¢ {username_escaped}: {user['processed_requests']} procesadas\n"
                    texto += "\n"
                
                texto += f"‚è∞ **An√°lisis:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            else:
                texto = (
                    f"üîç *Actividad Sospechosa* üîç\n\n"
                    f"‚úÖ **Estado:** Sin actividad sospechosa detectada\n"
                    f"üõ°Ô∏è **Sistema:** Funcionando con normalidad\n"
                    f"üìä **Per√≠odo analizado:** √öltimos 7 d√≠as\n"
                    f"‚è∞ **An√°lisis:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en an√°lisis de actividad sospechosa: {str(e)}")
            texto = (
                f"üîç *Actividad Sospechosa* üîç\n\n"
                f"‚ö†Ô∏è Error al analizar actividad: {str(e)}\n"
                f"üìä An√°lisis no disponible temporalmente\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="suspicious_activity"),
             InlineKeyboardButton("üóëÔ∏è Reiniciar Datos", callback_data="reset_infraction_data")],
            [InlineKeyboardButton("üîç Seleccionar Usuario", callback_data="select_infraction_user"),
             InlineKeyboardButton("üìä Estad√≠sticas Detalladas", callback_data="infraction_detailed_stats")],
            [InlineKeyboardButton("‚ö†Ô∏è Ver Incorrectas", callback_data="view_incorrect_offenders"),
             InlineKeyboardButton("üö® Ver Abusos", callback_data="view_abuse_offenders")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ejecutar Reporte Semanal Manualmente
    if data == "ejecutar_reporte_semanal":
        await query.answer("üìÖ Ejecutando reporte semanal...", show_alert=False)

        try:
            # Ejecutar la funci√≥n de reporte semanal
            await weekly_report_and_rewards(context)

            texto = (
                f"‚úÖ *Reporte Semanal Ejecutado* ‚úÖ\n\n"
                f"üìÖ **Fecha:** {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M')}h\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìä **Acciones realizadas:**\n"
                f"‚Ä¢ Reporte enviado a todos los grupos\n"
                f"‚Ä¢ Premios y penalizaciones aplicados\n"
                f"‚Ä¢ Estad√≠sticas de la semana calculadas\n\n"
                f"‚ú® *Reporte semanal completado exitosamente*\n\n"
                f"üí° El reporte se env√≠a autom√°ticamente cada\n"
                f"domingo a las 22:05 hora espa√±ola"
            )

            keyboard = [
                [InlineKeyboardButton("üìã Ver Estad√≠sticas", callback_data="stats_reportes_semanales"),
                 InlineKeyboardButton("üîÑ Ejecutar Nuevo", callback_data="ejecutar_reporte_semanal")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            logger.info(f"‚úÖ Reporte semanal ejecutado manualmente por admin {user_id}")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error ejecutando reporte semanal manual: {str(e)}")
            texto = (
                f"‚ùå *Error al Ejecutar Reporte* ‚ùå\n\n"
                f"‚ö†Ô∏è Ocurri√≥ un error al ejecutar el reporte semanal:\n"
                f"`{str(e)}`\n\n"
                f"Por favor, intenta de nuevo m√°s tarde"
            )

            keyboard = [
                [InlineKeyboardButton("üîÑ Reintentar", callback_data="ejecutar_reporte_semanal"),
                 InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        return ConversationHandler.END

    # Estad√≠sticas de Reportes Semanales
    if data == "stats_reportes_semanales":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Estad√≠sticas de la √∫ltima semana
                    c.execute("""
                        SELECT
                            COUNT(*) FILTER (WHERE estado = 'subido') as aprobadas,
                            COUNT(*) FILTER (WHERE estado = 'denegado') as denegadas,
                            COUNT(*) FILTER (WHERE estado = 'eliminado') as eliminadas
                        FROM historial_solicitudes
                        WHERE fecha_gestion >= NOW() - INTERVAL '7 days'
                    """)
                    stats_week = c.fetchone()

                    # Total de solicitudes pendientes actuales
                    c.execute("SELECT COUNT(*) as total FROM peticiones_registradas")
                    pendientes = c.fetchone()["total"]

                    # Usuarios premiados esta semana
                    c.execute("""
                        SELECT COUNT(*) as total
                        FROM weekly_rewards
                        WHERE week_end >= NOW() - INTERVAL '7 days'
                    """)
                    premiados = c.fetchone()["total"]

                    # Usuarios penalizados esta semana
                    c.execute("""
                        SELECT COUNT(*) as total
                        FROM weekly_penalties
                        WHERE week_end >= NOW() - INTERVAL '7 days'
                    """)
                    penalizados = c.fetchone()["total"]

                    # Top 5 usuarios con m√°s solicitudes aprobadas
                    c.execute("""
                        SELECT hs.user_id, u.username, COUNT(*) as aprobadas
                        FROM historial_solicitudes hs
                        LEFT JOIN usuarios u ON hs.user_id = u.user_id
                        WHERE hs.estado = 'subido' AND hs.fecha_gestion >= NOW() - INTERVAL '7 days'
                        GROUP BY hs.user_id, u.username
                        ORDER BY aprobadas DESC
                        LIMIT 5
                    """)
                    top_users = c.fetchall()

            texto = (
                f"üìã *Estad√≠sticas de Reportes Semanales* üìã\n\n"
                f"üìÖ **Per√≠odo:** √öltimos 7 d√≠as\n"
                f"‚è∞ **Actualizado:** {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M')}h\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üìä **Solicitudes de la Semana:**\n"
                f"‚úÖ Aprobadas: **{stats_week['aprobadas'] or 0}**\n"
                f"‚ùå Denegadas: **{stats_week['denegadas'] or 0}**\n"
                f"üóëÔ∏è Eliminadas: **{stats_week['eliminadas'] or 0}**\n"
                f"üìù Pendientes actuales: **{pendientes}**\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üèÜ **Premios y Penalizaciones:**\n"
                f"üéÅ Usuarios premiados: **{premiados}**\n"
                f"‚ö†Ô∏è Usuarios penalizados: **{penalizados}**\n\n"
            )

            if top_users:
                texto += f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                texto += f"üåü **Top 5 Usuarios de la Semana:**\n\n"
                for i, user in enumerate(top_users, 1):
                    username_display = user['username'] if user['username'] else f"ID: {user['user_id']}"
                    username_escaped = escape_markdown(username_display, preserve_username=True)
                    emoji = ["ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£"][i-1]
                    texto += f"{emoji} {username_escaped}: **{user['aprobadas']}** aprobadas\n"
                texto += "\n"

            texto += (
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                f"üîÑ **Pr√≥ximo reporte autom√°tico:**\n"
                f"Domingo a las 22:05h (Espa√±a)"
            )

            keyboard = [
                [InlineKeyboardButton("üìÖ Ejecutar Reporte", callback_data="ejecutar_reporte_semanal"),
                 InlineKeyboardButton("üîÑ Actualizar", callback_data="stats_reportes_semanales")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas de reportes semanales: {str(e)}")
            texto = (
                f"‚ùå *Error* ‚ùå\n\n"
                f"‚ö†Ô∏è No se pudieron obtener las estad√≠sticas:\n"
                f"`{str(e)}`"
            )

            keyboard = [
                [InlineKeyboardButton("üîÑ Reintentar", callback_data="stats_reportes_semanales"),
                 InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        return ConversationHandler.END

    # Reiniciar datos de infracciones
    if data == "reset_infraction_data":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Contar registros antes de eliminar
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    incorrect_count = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones")
                    abuse_count = c.fetchone()[0]
                    
                    # Eliminar todos los registros
                    c.execute("DELETE FROM peticiones_incorrectas")
                    c.execute("DELETE FROM abuso_botones")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Datos de Infracciones Reiniciados* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:**\n"
                f"‚Ä¢ ‚ö†Ô∏è Peticiones incorrectas: {incorrect_count}\n"
                f"‚Ä¢ üö® Abusos de botones: {abuse_count}\n\n"
                f"üîÑ **Efectos:**\n"
                f"‚Ä¢ Todos los usuarios pueden hacer solicitudes nuevamente\n"
                f"‚Ä¢ Contadores de infracciones reseteados a 0\n"
                f"‚Ä¢ Historial de abusos limpiado\n\n"
                f"‚è∞ **Reiniciado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Esta acci√≥n no se puede deshacer\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reiniciando datos de infracciones: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Reiniciar Datos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="suspicious_activity")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver infractores de peticiones incorrectas
    if data == "view_incorrect_offenders":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT pi.user_id, u.username, COUNT(*) as total_attempts, 
                               MAX(pi.timestamp) as last_attempt,
                               COUNT(CASE WHEN pi.timestamp > %s THEN 1 END) as attempts_today
                        FROM peticiones_incorrectas pi
                        LEFT JOIN usuarios u ON pi.user_id = u.user_id
                        GROUP BY pi.user_id, u.username
                        HAVING COUNT(*) > 0
                        ORDER BY total_attempts DESC, last_attempt DESC
                        LIMIT 15
                    """, (datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0),))
                    offenders = c.fetchall()
            
            if not offenders:
                texto = (
                    f"‚ö†Ô∏è *Infractores de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                    f"‚úÖ **Estado:** No hay infractores registrados\n"
                    f"üõ°Ô∏è **Sistema:** Funcionando sin infracciones\n"
                    f"üìä **Registros:** 0 usuarios con peticiones incorrectas\n"
                    f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"‚ö†Ô∏è *Infractores de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                    f"üìä **Total de infractores:** {len(offenders)}\n"
                    f"üîç **Mostrando:** Primeros 15 usuarios\n"
                    f"üìÖ **Per√≠odo:** Hist√≥rico completo\n\n"
                    f"Selecciona un usuario para gestionar sus infracciones:"
                )
                
                keyboard = []
                
                for offender in offenders:
                    username_display = offender['username'] if offender['username'] else f"ID: {offender['user_id']}"
                    username_clean = username_display.replace('@', '') if username_display.startswith('@') else username_display
                    attempts_today = offender['attempts_today']
                    total_attempts = offender['total_attempts']
                    last_attempt = offender['last_attempt'].strftime('%d/%m')
                    
                    # Indicador de estado
                    status_emoji = "üî¥" if attempts_today >= MAX_INCORRECT_ATTEMPTS else "üü°" if attempts_today > 0 else "üü¢"
                    
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{status_emoji} {username_clean} \\({total_attempts} total, {attempts_today} hoy\\) \\- {last_attempt}",
                            callback_data=f"manage_incorrect_{offender['user_id']}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos", callback_data="clear_all_incorrect"),
                    InlineKeyboardButton("üîÑ Actualizar", callback_data="view_incorrect_offenders")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo infractores incorrectas: {str(e)}")
            texto = (
                f"‚ö†Ô∏è *Error en Infractores* ‚ö†Ô∏è\n\n"
                f"‚ùå Error al cargar infractores: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver infractores de abuso de botones
    if data == "view_abuse_offenders":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT ab.user_id, u.username, SUM(ab.attempt_count) as total_abuse,
                               MAX(ab.last_attempt) as last_attempt,
                               COUNT(DISTINCT ab.ticket_number) as tickets_affected
                        FROM abuso_botones ab
                        LEFT JOIN usuarios u ON ab.user_id = u.user_id
                        GROUP BY ab.user_id, u.username
                        HAVING SUM(ab.attempt_count) > 0
                        ORDER BY total_abuse DESC, last_attempt DESC
                        LIMIT 15
                    """)
                    offenders = c.fetchall()
            
            if not offenders:
                texto = (
                    f"üö® *Infractores de Abuso de Botones* üö®\n\n"
                    f"‚úÖ **Estado:** No hay infractores registrados\n"
                    f"üõ°Ô∏è **Sistema:** Funcionando sin abusos\n"
                    f"üìä **Registros:** 0 usuarios con abusos de botones\n"
                    f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"üö® *Infractores de Abuso de Botones* üö®\n\n"
                    f"üìä **Total de infractores:** {len(offenders)}\n"
                    f"üîç **Mostrando:** Primeros 15 usuarios\n"
                    f"üìÖ **Per√≠odo:** Hist√≥rico completo\n\n"
                    f"Selecciona un usuario para gestionar sus infracciones:"
                )
                
                keyboard = []
                
                for offender in offenders:
                    username_display = offender['username'] if offender['username'] else f"ID: {offender['user_id']}"
                    username_clean = username_display.replace('@', '') if username_display.startswith('@') else username_display
                    total_abuse = offender['total_abuse']
                    tickets_affected = offender['tickets_affected']
                    last_attempt = offender['last_attempt'].strftime('%d/%m')
                    
                    # Indicador de gravedad
                    if total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS * 3:
                        status_emoji = "üî¥"  # Cr√≠tico
                    elif total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS:
                        status_emoji = "üü†"  # Alto
                    else:
                        status_emoji = "üü°"  # Moderado
                    
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{status_emoji} {username_clean} \\({total_abuse} abusos, {tickets_affected} tickets\\) \\- {last_attempt}",
                            callback_data=f"manage_abuse_{offender['user_id']}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos", callback_data="clear_all_abuse"),
                    InlineKeyboardButton("üîÑ Actualizar", callback_data="view_abuse_offenders")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo infractores de abuso: {str(e)}")
            texto = (
                f"üö® *Error en Infractores de Abuso* üö®\n\n"
                f"‚ùå Error al cargar infractores: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Seleccionar usuario para gesti√≥n de infracciones
    if data == "select_infraction_user":
        texto = (
            f"üîç *Seleccionar Usuario para Gesti√≥n de Infracciones* üîç\n\n"
            f"Busca un usuario espec√≠fico para gestionar sus infracciones\\.\n"
            f"Puedes buscar por:\n\n"
            f"üë§ **Username** \\(ej: @usuario\\)\n"
            f"üÜî **User ID** \\(ej: 123456789\\)\n\n"
            f"üìù **Funcionalidades disponibles:**\n"
            f"‚Ä¢ Ver historial completo de infracciones\n"
            f"‚Ä¢ Reducir contadores espec√≠ficos\n"
            f"‚Ä¢ Limpiar registros individuales\n"
            f"‚Ä¢ Estad√≠sticas detalladas del usuario\n\n"
            f"Escribe tu consulta de b√∫squeda:"
        )
        
        pending_searches[f"{user_id}_{chat_id}"] = {
            "timestamp": datetime.now(SPAIN_TZ),
            "message_id": message_id,
            "admin_id": user_id,
            "search_type": "infraction_management"
        }
        
        keyboard = [
            [InlineKeyboardButton("‚ùå Cancelar B√∫squeda", callback_data="cancel_infraction_search")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="üîç *Escribe el username \\(@usuario\\) o user\\_id del usuario:*",
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            context.user_data["infraction_search_instruction_msg"] = instruction_msg.message_id
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        return ASKING_USER_SEARCH

    # Cancelar b√∫squeda de infracciones
    if data == "cancel_infraction_search":
        search_key = f"{user_id}_{chat_id}"
        if search_key in pending_searches:
            del pending_searches[search_key]
        
        instruction_msg_id = context.user_data.get("infraction_search_instruction_msg")
        if instruction_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=instruction_msg_id
            )
            if "infraction_search_instruction_msg" in context.user_data:
                del context.user_data["infraction_search_instruction_msg"]
        
        texto = (
            f"‚ùå *B√∫squeda de Infracciones Cancelada* ‚ùå\n\n"
            f"La b√∫squeda de usuario para gesti√≥n de infracciones ha sido cancelada\\.\n"
            f"‚è∞ *Cancelado:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ B√∫squeda de infracciones cancelada por user_id={user_id}")
        return ConversationHandler.END

    # Gestionar infracciones de peticiones incorrectas de usuario espec√≠fico
    if data.startswith("manage_incorrect_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener estad√≠sticas detalladas
                    c.execute("""
                        SELECT COUNT(*) as total_attempts,
                               MAX(timestamp) as last_attempt,
                               MIN(timestamp) as first_attempt,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as attempts_today,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as attempts_week
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s
                    """, (
                        datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0),
                        datetime.now(SPAIN_TZ) - timedelta(days=7),
                        target_user_id
                    ))
                    stats = c.fetchone()
                    
                    # Obtener √∫ltimos intentos
                    c.execute("""
                        SELECT timestamp, chat_id, attempt_count
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s 
                        ORDER BY timestamp DESC 
                        LIMIT 5
                    """, (target_user_id,))
                    recent_attempts = c.fetchall()
            
            username = user_info['username'] or f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Determinar estado del usuario
            is_blocked = stats['attempts_today'] >= MAX_INCORRECT_ATTEMPTS
            status_text = "üî¥ Bloqueado" if is_blocked else "üü¢ Activo"
            
            texto = (
                f"‚ö†Ô∏è *Gesti√≥n de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Estado:** {status_text}\n\n"
                f"üìà **Estad√≠sticas:**\n"
                f"‚Ä¢ Total hist√≥rico: {stats['total_attempts']}\n"
                f"‚Ä¢ Intentos hoy: {stats['attempts_today']}/{MAX_INCORRECT_ATTEMPTS}\n"
                f"‚Ä¢ Intentos esta semana: {stats['attempts_week']}\n"
                f"‚Ä¢ Primer intento: {stats['first_attempt'].strftime('%d/%m/%Y') if stats['first_attempt'] else 'N/A'}\n"
                f"‚Ä¢ √öltimo intento: {stats['last_attempt'].strftime('%d/%m/%Y %H:%M') if stats['last_attempt'] else 'N/A'}\n\n"
                f"üîß **Acciones disponibles:**"
            )
            
            keyboard = []
            
            # Botones seg√∫n el estado
            if stats['total_attempts'] > 0:
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos los Registros", callback_data=f"clear_user_incorrect_{target_user_id}"),
                    InlineKeyboardButton("‚ûñ Reducir Contador", callback_data=f"reduce_incorrect_{target_user_id}")
                ])
                
                if stats['attempts_today'] > 0:
                    keyboard.append([
                        InlineKeyboardButton("üîÑ Resetear Solo Hoy", callback_data=f"reset_today_incorrect_{target_user_id}")
                    ])
            
            # Informaci√≥n y navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üìä Ver Detalles", callback_data=f"view_incorrect_details_{target_user_id}"),
                InlineKeyboardButton("üë§ Perfil Usuario", callback_data=f"user_details_{target_user_id}")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_incorrect_offenders"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error gestionando infracciones incorrectas: {str(e)}")
            texto = (
                f"‚ö†Ô∏è *Error en Gesti√≥n* ‚ö†Ô∏è\n\n"
                f"‚ùå Error al cargar datos: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_incorrect_offenders"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Gestionar infracciones de abuso de botones de usuario espec√≠fico
    if data.startswith("manage_abuse_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener estad√≠sticas detalladas de abuso
                    c.execute("""
                        SELECT SUM(attempt_count) as total_abuse,
                               MAX(last_attempt) as last_attempt,
                               MIN(last_attempt) as first_attempt,
                               COUNT(DISTINCT ticket_number) as tickets_affected,
                               COUNT(DISTINCT chat_id) as chats_affected
                        FROM abuso_botones 
                        WHERE user_id = %s
                    """, (target_user_id,))
                    stats = c.fetchone()
                    
                    # Obtener √∫ltimos abusos
                    c.execute("""
                        SELECT ticket_number, attempt_count, last_attempt, chat_id
                        FROM abuso_botones 
                        WHERE user_id = %s 
                        ORDER BY last_attempt DESC 
                        LIMIT 5
                    """, (target_user_id,))
                    recent_abuse = c.fetchall()
            
            username = user_info['username'] or f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Determinar nivel de gravedad
            total_abuse = stats['total_abuse'] or 0
            if total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS * 3:
                severity = "üî¥ Cr√≠tico"
            elif total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS:
                severity = "üü† Alto"
            else:
                severity = "üü° Moderado"
            
            texto = (
                f"üö® *Gesti√≥n de Abuso de Botones* üö®\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Nivel de Gravedad:** {severity}\n\n"
                f"üìà **Estad√≠sticas:**\n"
                f"‚Ä¢ Total de abusos: {total_abuse}\n"
                f"‚Ä¢ Tickets afectados: {stats['tickets_affected'] or 0}\n"
                f"‚Ä¢ Grupos afectados: {stats['chats_affected'] or 0}\n"
                f"‚Ä¢ Primer abuso: {stats['first_attempt'].strftime('%d/%m/%Y') if stats['first_attempt'] else 'N/A'}\n"
                f"‚Ä¢ √öltimo abuso: {stats['last_attempt'].strftime('%d/%m/%Y %H:%M') if stats['last_attempt'] else 'N/A'}\n\n"
                f"üîß **Acciones disponibles:**"
            )
            
            keyboard = []
            
            # Botones seg√∫n la gravedad
            if total_abuse > 0:
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos los Abusos", callback_data=f"clear_user_abuse_{target_user_id}"),
                    InlineKeyboardButton("‚ûñ Reducir Contador", callback_data=f"reduce_abuse_{target_user_id}")
                ])
                
                keyboard.append([
                    InlineKeyboardButton("üìã Ver Detalles", callback_data=f"view_abuse_details_{target_user_id}"),
                    InlineKeyboardButton("‚ö†Ô∏è Advertir Usuario", callback_data=f"warn_user_{target_user_id}")
                ])
            
            # Informaci√≥n y navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üë§ Perfil Usuario", callback_data=f"user_details_{target_user_id}"),
                InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_abuse_offenders"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error gestionando abusos: {str(e)}")
            texto = (
                f"üö® *Error en Gesti√≥n de Abusos* üö®\n\n"
                f"‚ùå Error al cargar datos: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_abuse_offenders"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Estad√≠sticas detalladas de infracciones
    if data == "infraction_detailed_stats":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Estad√≠sticas generales
                    c.execute("SELECT COUNT(DISTINCT user_id) FROM peticiones_incorrectas")
                    total_incorrect_users = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    total_incorrect_attempts = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(DISTINCT user_id) FROM abuso_botones")
                    total_abuse_users = c.fetchone()[0]
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones")
                    total_abuse_attempts = c.fetchone()[0] or 0
                    
                    # Estad√≠sticas por per√≠odo
                    today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
                    week_start = datetime.now(SPAIN_TZ) - timedelta(days=7)
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE timestamp >= %s", (today_start,))
                    incorrect_today = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE timestamp >= %s", (week_start,))
                    incorrect_week = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones WHERE last_attempt >= %s", (today_start,))
                    abuse_today = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones WHERE last_attempt >= %s", (week_start,))
                    abuse_week = c.fetchone()[0]
                    
                    # Top infractores
                    c.execute("""
                        SELECT u.username, COUNT(*) as attempts
                        FROM peticiones_incorrectas pi
                        LEFT JOIN usuarios u ON pi.user_id = u.user_id
                        GROUP BY u.username
                        ORDER BY attempts DESC
                        LIMIT 3
                    """)
                    top_incorrect = c.fetchall()
                    
                    c.execute("""
                        SELECT u.username, SUM(ab.attempt_count) as total_abuse
                        FROM abuso_botones ab
                        LEFT JOIN usuarios u ON ab.user_id = u.user_id
                        GROUP BY u.username
                        ORDER BY total_abuse DESC
                        LIMIT 3
                    """)
                    top_abuse = c.fetchall()
            
            # Calcular tasas
            avg_incorrect_per_user = round(total_incorrect_attempts / total_incorrect_users, 1) if total_incorrect_users > 0 else 0
            avg_abuse_per_user = round(total_abuse_attempts / total_abuse_users, 1) if total_abuse_users > 0 else 0
            
            texto = (
                f"üìä *Estad√≠sticas Detalladas de Infracciones* üìä\n\n"
                f"‚ö†Ô∏è **Peticiones Incorrectas:**\n"
                f"‚Ä¢ Usuarios afectados: {total_incorrect_users}\n"
                f"‚Ä¢ Total de intentos: {total_incorrect_attempts}\n"
                f"‚Ä¢ Promedio por usuario: {avg_incorrect_per_user}\n"
                f"‚Ä¢ Hoy: {incorrect_today} \\| Semana: {incorrect_week}\n\n"
                f"üö® **Abuso de Botones:**\n"
                f"‚Ä¢ Usuarios infractores: {total_abuse_users}\n"
                f"‚Ä¢ Total de abusos: {total_abuse_attempts}\n"
                f"‚Ä¢ Promedio por usuario: {avg_abuse_per_user}\n"
                f"‚Ä¢ Hoy: {abuse_today} \\| Semana: {abuse_week}\n\n"
                f"üèÜ **Top Infractores \\(Incorrectas\\):**\n"
            )
            
            if top_incorrect:
                for i, user in enumerate(top_incorrect, 1):
                    username_safe = escape_markdown(user['username'] or "Usuario", preserve_username=True)
                    texto += f"{i}\\. {username_safe}: {user['attempts']}\n"
            else:
                texto += "Sin datos\n"
            
            texto += f"\nüèÜ **Top Infractores \\(Abusos\\):**\n"
            
            if top_abuse:
                for i, user in enumerate(top_abuse, 1):
                    username_safe = escape_markdown(user['username'] or "Usuario", preserve_username=True)
                    texto += f"{i}\\. {username_safe}: {user['total_abuse']}\n"
            else:
                texto += "Sin datos\n"
            
            texto += f"\n‚è∞ **Actualizado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas detalladas: {str(e)}")
            texto = (
                f"üìä *Error en Estad√≠sticas* üìä\n\n"
                f"‚ùå Error al cargar estad√≠sticas: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="infraction_detailed_stats")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar todas las peticiones incorrectas
    if data == "clear_all_incorrect":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Peticiones Incorrectas Limpiadas* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Efecto:** Todos los usuarios pueden hacer solicitudes\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Los contadores de todos los usuarios han sido reseteados\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando peticiones incorrectas: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="view_incorrect_offenders")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_incorrect_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar todos los abusos de botones
    if data == "clear_all_abuse":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM abuso_botones")
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM abuso_botones")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Abusos de Botones Limpiados* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Efecto:** Todos los contadores de abuso reseteados\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Los usuarios ya no tienen restricciones por abuso\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando abusos de botones: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Abusos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="view_abuse_offenders")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_abuse_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Acciones espec√≠ficas para usuarios infractores
    if data.startswith("clear_user_incorrect_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üóëÔ∏è *Registros de Usuario Limpiados* üóëÔ∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Estado:** Usuario desbloqueado\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede hacer solicitudes normalmente\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando registros de usuario: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Usuario* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_incorrect_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar abusos de usuario espec√≠fico
    if data.startswith("clear_user_abuse_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    count_before = c.fetchone()[0] or 0
                    
                    c.execute("DELETE FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üóëÔ∏è *Abusos de Usuario Limpiados* üóëÔ∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Abusos eliminados:** {count_before}\n"
                f"üîÑ **Estado:** Sin restricciones por abuso\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede usar botones normalmente\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando abusos de usuario: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Abusos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_abuse_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reducir contador de peticiones incorrectas
    if data.startswith("reduce_incorrect_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    # Eliminar el registro m√°s reciente
                    c.execute("""
                        DELETE FROM peticiones_incorrectas 
                        WHERE user_id = %s AND timestamp = (
                            SELECT MAX(timestamp) FROM peticiones_incorrectas WHERE user_id = %s
                        )
                    """, (target_user_id, target_user_id))
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    remaining_count = c.fetchone()[0]
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"‚ûñ *Contador Reducido* ‚ûñ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Registros restantes:** {remaining_count}\n"
                f"üîÑ **Acci√≥n:** √öltimo intento eliminado\n"
                f"‚è∞ **Reducido:** {get_spain_time()}\n\n"
                f"‚úÖ Contador de peticiones incorrectas reducido\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reduciendo contador: {str(e)}")
            texto = (
                f"‚ûñ *Error al Reducir* ‚ûñ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_incorrect_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reducir contador de abusos
    if data.startswith("reduce_abuse_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    # Reducir el contador del registro con m√°s abusos
                    c.execute("""
                        UPDATE abuso_botones 
                        SET attempt_count = GREATEST(attempt_count - 1, 0)
                        WHERE user_id = %s AND attempt_count = (
                            SELECT MAX(attempt_count) FROM abuso_botones WHERE user_id = %s
                        )
                    """, (target_user_id, target_user_id))
                    
                    # Eliminar registros con 0 intentos
                    c.execute("DELETE FROM abuso_botones WHERE user_id = %s AND attempt_count = 0", (target_user_id,))
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    remaining_abuse = c.fetchone()[0] or 0
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"‚ûñ *Contador de Abusos Reducido* ‚ûñ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Abusos restantes:** {remaining_abuse}\n"
                f"üîÑ **Acci√≥n:** Contador reducido en 1\n"
                f"‚è∞ **Reducido:** {get_spain_time()}\n\n"
                f"‚úÖ Contador de abusos de botones reducido\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reduciendo abusos: {str(e)}")
            texto = (
                f"‚ûñ *Error al Reducir Abusos* ‚ûñ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_abuse_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Resetear solo intentos de hoy
    if data.startswith("reset_today_incorrect_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s AND timestamp >= %s", 
                             (target_user_id, today_start))
                    count_today = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE user_id = %s AND timestamp >= %s", 
                             (target_user_id, today_start))
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    remaining_total = c.fetchone()[0]
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üîÑ *Intentos de Hoy Reseteados* üîÑ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Eliminados hoy:** {count_today}\n"
                f"üìä **Total restante:** {remaining_total}\n"
                f"üîÑ **Estado:** Desbloqueado para hoy\n"
                f"‚è∞ **Reseteado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede hacer solicitudes hoy\\."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reseteando intentos de hoy: {str(e)}")
            texto = (
                f"üîÑ *Error al Resetear* üîÑ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_incorrect_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reporte de satisfacci√≥n
    if data == "satisfaction_report":
        try:
            stats = get_advanced_stats()
            
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT satisfaccion, COUNT(*) as count
                        FROM encuestas_satisfaccion 
                        GROUP BY satisfaccion
                        ORDER BY 
                            CASE 
                                WHEN satisfaccion = 'excelente' THEN 1
                                WHEN satisfaccion = 'bueno' THEN 2
                                WHEN satisfaccion = 'regular' THEN 3
                                WHEN satisfaccion = 'malo' THEN 4
                                ELSE 5
                            END
                    """)
                    satisfaction_detail = c.fetchall()
                    
                    c.execute("""
                        SELECT 
                            DATE_TRUNC('month', timestamp) as month,
                            satisfaccion,
                            COUNT(*) as count
                        FROM encuestas_satisfaccion 
                        WHERE timestamp >= NOW() - INTERVAL '6 months'
                        GROUP BY month, satisfaccion
                        ORDER BY month DESC
                    """)
                    monthly_satisfaction = c.fetchall()
                    
                    c.execute("""
                        SELECT ticket_number, satisfaccion, timestamp
                        FROM encuestas_satisfaccion 
                        ORDER BY timestamp DESC 
                        LIMIT 5
                    """)
                    recent_surveys = c.fetchall()
            
            satisfaction_bars = ""
            total_surveys = sum([s['count'] for s in satisfaction_detail])
            
            if total_surveys > 0:
                for s in satisfaction_detail:
                    satisfaccion_str = str(s['satisfaccion']).lower()
                    emoji_map = {
                        "excelente": "‚≠ê",
                        "bueno": "üëç",
                        "regular": "üëå",
                        "malo": "üëé"
                    }
                    emoji = emoji_map.get(satisfaccion_str, "‚ùì")
                    
                    percentage = (s['count'] / total_surveys * 100)
                    bar_length = int(percentage / 5)
                    bar = "‚ñà" * bar_length + "‚ñë" * (20 - bar_length)
                    
                    satisfaccion_display = satisfaccion_str.capitalize()
                    satisfaction_bars += f"{emoji} {satisfaccion_display}: {bar} {percentage:.1f}% ({s['count']})\n"
            else:
                satisfaction_bars = "üìä No hay encuestas registradas a√∫n.\n"
            
            recent_text = ""
            if recent_surveys:
                recent_text = f"üìÖ √öltimas {len(recent_surveys)} encuestas:\n"
                for survey in recent_surveys:
                    fecha = survey['timestamp'].strftime('%d/%m %H:%M')
                    satisfaccion_display = str(survey['satisfaccion']).capitalize()
                    recent_text += f"‚Ä¢ #{survey['ticket_number']}: {satisfaccion_display} ({fecha})\n"
                recent_text += "\n"
            
            texto = (
                f"üòä *Reporte de Satisfacci√≥n de Usuarios* üòä\n\n"
                f"üìä **Resumen General:**\n"
                f"‚Ä¢ Solicitudes pendientes: {stats['pendientes']}\n"
                f"‚Ä¢ Solicitudes procesadas: {stats['gestionadas']}\n"
                f"‚Ä¢ Usuarios registrados: {stats['usuarios']}\n"
                f"‚Ä¢ Tasa de aprobaci√≥n: {stats['approved_percent']:.1f}%\n\n"
                f"‚è±Ô∏è *Rendimiento:*\n"
                f"‚Ä¢ Total encuestas: {total_surveys}\n"
                f"‚Ä¢ Satisfacci√≥n general: {stats['satisfaction_rate']:.1f}%\n"
                f"‚Ä¢ Tasa de respuesta: {stats['response_rate']:.1f}%\n\n"
                f"üìà **Distribuci√≥n de Calificaciones:**\n"
                f"{satisfaction_bars}\n"
                f"{recent_text}"
                f"‚è∞ **Actualizado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al cargar reporte de satisfacci√≥n: {str(e)}")
            texto = (
                f"üòä *Reporte de Satisfacci√≥n* üòä\n\n"
                f"‚ö†Ô∏è Error al cargar reporte: {str(e)}\n"
                f"üìä Datos no disponibles temporalmente\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="satisfaction_report")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_estadisticas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Configuraci√≥n de mantenimiento MEJORADA
    if data == "maintenance_config":
        maintenance = get_maintenance_mode()
        status = "üî¥ Activo" if maintenance and maintenance.get("is_active") else "üü¢ Inactivo"
        message_text = maintenance.get("message", "No configurado") if maintenance else "No configurado"
        message_preview = escape_markdown(message_text[:50] + "..." if message_text and len(message_text) > 50 else message_text)
        
        scheduled_until_raw = maintenance.get("scheduled_until") if maintenance else None
        if scheduled_until_raw:
            if isinstance(scheduled_until_raw, str):
                try:
                    scheduled_until_dt = datetime.fromisoformat(scheduled_until_raw)
                except:
                    scheduled_until_dt = None
            else:
                scheduled_until_dt = scheduled_until_raw
            
            if scheduled_until_dt:
                scheduled_until = scheduled_until_dt.strftime("%d/%m/%Y %H:%M")
            else:
                scheduled_until = "Error en formato"
        else:
            scheduled_until = "No programado"
        
        keyboard = [
            [InlineKeyboardButton("üî¥ Activar Ahora", callback_data="activate_maintenance"),
             InlineKeyboardButton("üü¢ Desactivar", callback_data="deactivate_maintenance")],
            [InlineKeyboardButton("üìÖ Programar Mantenimiento", callback_data="schedule_maintenance"),
             InlineKeyboardButton("‚è∞ Ver Programaci√≥n", callback_data="view_maintenance_schedule")],
            [InlineKeyboardButton("‚úèÔ∏è Ver Mensaje", callback_data="view_maintenance_msg"),
             InlineKeyboardButton("üóëÔ∏è Cancelar Programado", callback_data="cancel_scheduled_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        texto = (
            f"üöß *Panel de Mantenimiento Avanzado* üöß\n\n"
            f"üìä *Estado Actual:* {status}\n"
            f"üìù *Mensaje:* {message_preview}\n"
            f"‚è∞ *Programado hasta:* {scheduled_until}\n\n"
            f"üéõÔ∏è **Opciones Disponibles:**\n"
            f"‚Ä¢ Activar/Desactivar mantenimiento inmediato\n"
            f"‚Ä¢ Programar mantenimiento con fechas espec√≠ficas\n"
            f"‚Ä¢ Gestionar mensajes personalizados\n"
            f"‚Ä¢ Auto-eliminaci√≥n de mensajes al finalizar\n\n"
            f"Selecciona una opci√≥n:"
        )
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "duplicate_config":
        texto = (
            f"üîç *Configuraci√≥n de Detecci√≥n de Duplicados* üîç\n\n"
            f"‚öôÔ∏è **Configuraci√≥n actual:**\n"
            f"‚Ä¢ Sistema de detecci√≥n activo\n"
            f"‚Ä¢ Umbral de similitud: 85%\n"
            f"‚Ä¢ Verificaci√≥n autom√°tica habilitada\n\n"
            f"üí° **Funciones:**\n"
            f"‚Ä¢ Detecta solicitudes similares autom√°ticamente\n"
            f"‚Ä¢ Notifica al usuario antes de enviar\n"
            f"‚Ä¢ Previene solicitudes duplicadas\n\n"
            f"‚ÑπÔ∏è El sistema est√° siempre activo para mantener la calidad del servicio."
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "manual_survey_reminder":
        # Contar encuestas pendientes
        surveys = get_surveys_needing_reminder()
        count = len(surveys)

        texto = (
            f"üìã *Recordatorio Manual de Encuestas* üìã\n\n"
            f"üìä **Estado actual:**\n"
            f"‚Ä¢ Encuestas pendientes (2+ d√≠as): {count}\n\n"
        )

        if count > 0:
            texto += (
                f"üí° **Funci√≥n:**\n"
                f"‚Ä¢ Env√≠a recordatorios a usuarios con encuestas pendientes\n"
                f"‚Ä¢ Solo encuestas de 2 o m√°s d√≠as sin responder\n"
                f"‚Ä¢ Elimina recordatorios anteriores\n"
                f"‚Ä¢ Mensaje profesional y personalizado\n\n"
                f"‚ö†Ô∏è ¬øDeseas enviar recordatorios ahora?"
            )
            keyboard = [
                [InlineKeyboardButton("‚úÖ Enviar Recordatorios", callback_data="send_manual_reminders")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        else:
            texto += f"‚úÖ No hay encuestas pendientes que requieran recordatorio."
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "send_manual_reminders":
        texto_procesando = (
            f"‚è≥ *Enviando recordatorios...*\n\n"
            f"Por favor espera mientras se procesan las encuestas pendientes."
        )
        await safe_bot_method(
            query.edit_message_text,
            text=texto_procesando,
            parse_mode="Markdown"
        )

        # Enviar recordatorios
        count_sent = await send_survey_reminders(context, manual=True)

        texto = (
            f"‚úÖ *Recordatorios Enviados* ‚úÖ\n\n"
            f"üìä **Resultado:**\n"
            f"‚Ä¢ Total de recordatorios enviados: {count_sent}\n\n"
        )

        if count_sent > 0:
            texto += (
                f"üìã **Acciones realizadas:**\n"
                f"‚Ä¢ Recordatorios anteriores eliminados\n"
                f"‚Ä¢ Nuevos recordatorios enviados a usuarios\n"
                f"‚Ä¢ Mensajes enviados a canales espec√≠ficos\n\n"
                f"‚úÖ Los usuarios han sido notificados correctamente."
            )
        else:
            texto += f"‚ÑπÔ∏è No hab√≠a encuestas pendientes para procesar."

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_configuracion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "activate_maintenance":
        set_maintenance_mode(True, "‚ö†Ô∏è El bot est√° en mantenimiento. Intenta de nuevo m√°s tarde. *Equipo de Administraci√≥n EntresHijos*, disculpen las molestias, estaremos de vuelta lo antes posible.")
        
        # Enviar notificaci√≥n y guardar mensajes para eliminarlos despu√©s
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=True,
            message="‚ö†Ô∏è El bot est√° en mantenimiento. Intenta de nuevo m√°s tarde. *Equipo de Administraci√≥n EntresHijos*, disculpen las molestias, estaremos de vuelta lo antes posible."
        )
        
        texto = (
            f"üî¥ *Modo de Mantenimiento Activado* üî¥\n\n"
            f"‚úÖ El bot no aceptar√° nuevas solicitudes hasta que se desactive el mantenimiento.\n"
            f"üì¢ Notificaci√≥n enviada a todos los canales\n"
            f"üóëÔ∏è Los mensajes se eliminar√°n autom√°ticamente al finalizar\n"
            f"‚è∞ *Activado:* {get_spain_time()}"
        )
        keyboard = [
            [InlineKeyboardButton("üü¢ Desactivar Ahora", callback_data="deactivate_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "deactivate_maintenance":
        set_maintenance_mode(False)
        
        # Eliminar mensajes de mantenimiento y enviar notificaci√≥n de fin
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=False
        )
        
        texto = (
            f"üü¢ *Modo de Mantenimiento Desactivado* üü¢\n\n"
            f"‚úÖ El bot ahora acepta solicitudes normalmente.\n"
            f"üóëÔ∏è Mensajes de mantenimiento eliminados autom√°ticamente\n"
            f"üì¢ Notificaci√≥n de fin enviada (se auto-elimina en 5 min)\n"
            f"‚è∞ *Desactivado:* {get_spain_time()}"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Programar mantenimiento
    if data == "schedule_maintenance":
        texto = (
            f"üìÖ *Programar Mantenimiento* üìÖ\n\n"
            f"‚ö†Ô∏è **Funcionalidad en desarrollo**\n\n"
            f"üîß **Caracter√≠sticas planificadas:**\n"
            f"‚Ä¢ Programaci√≥n con fecha y hora espec√≠fica\n"
            f"‚Ä¢ Mensaje personalizable\n"
            f"‚Ä¢ Auto-activaci√≥n y desactivaci√≥n\n"
            f"‚Ä¢ Notificaciones autom√°ticas\n\n"
            f"üí° **Por ahora usa:**\n"
            f"‚Ä¢ `/mantenimiento on [mensaje]` - Activar\n"
            f"‚Ä¢ `/mantenimiento off` - Desactivar\n"
            f"‚Ä¢ Botones del panel para control inmediato\n\n"
            f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üî¥ Activar Ahora", callback_data="activate_maintenance"),
             InlineKeyboardButton("üü¢ Desactivar", callback_data="deactivate_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver programaci√≥n de mantenimiento
    if data == "view_maintenance_schedule":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT id, start_time, end_time, message, is_active, created_by, created_at
                        FROM scheduled_maintenance 
                        ORDER BY created_at DESC 
                        LIMIT 5
                    """)
                    scheduled_maintenances = c.fetchall()
            
            if scheduled_maintenances:
                texto = f"‚è∞ *Programaci√≥n de Mantenimiento* ‚è∞\n\n"
                texto += f"üìã **Mantenimientos programados:**\n\n"
                
                for i, maint in enumerate(scheduled_maintenances, 1):
                    start_time = maint['start_time'].strftime('%d/%m/%Y %H:%M')
                    end_time = maint['end_time'].strftime('%d/%m/%Y %H:%M')
                    status = "üî¥ Activo" if maint['is_active'] else "üü¢ Programado"
                    message_preview = maint['message'][:30] + "..." if len(maint['message']) > 30 else maint['message']
                    
                    texto += f"**{i}.** {status}\n"
                    texto += f"   üìÖ Inicio: {start_time}\n"
                    texto += f"   üìÖ Fin: {end_time}\n"
                    texto += f"   üìù Mensaje: {escape_markdown(message_preview)}\n\n"
                
                texto += f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            else:
                texto = (
                    f"‚è∞ *Programaci√≥n de Mantenimiento* ‚è∞\n\n"
                    f"üìÖ *Estado:* No hay mantenimientos programados\n"
                    f"üîß *Modo actual:* Manual\n"
                    f"üí° *Sugerencia:* Usa los botones de activar/desactivar para control manual\n\n"
                    f"‚öôÔ∏è Para programar mantenimiento usa:\n"
                    f"`/mantenimiento on [mensaje]` - Activar\n"
                    f"`/mantenimiento off` - Desactivar"
                )
        except Exception as e:
            texto = (
                f"‚è∞ *Error en Programaci√≥n* ‚è∞\n\n"
                f"‚ùå Error al cargar programaci√≥n: {str(e)}\n"
                f"üìä Sistema operativo, control manual disponible\n"
                f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üìÖ Programar Nuevo", callback_data="schedule_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver mensaje de mantenimiento
    if data == "view_maintenance_msg":
        maintenance = get_maintenance_mode()
        message_text = maintenance.get("message", "No configurado") if maintenance else "No configurado"
        
        texto = (
            f"‚úèÔ∏è *Mensaje de Mantenimiento* ‚úèÔ∏è\n\n"
            f"üìù *Mensaje actual:*\n"
            f"```\n{message_text}\n```\n\n"
            f"üí° *Nota:* Este mensaje se muestra a los usuarios cuando el mantenimiento est√° activo.\n\n"
            f"‚öôÔ∏è **Para cambiar el mensaje:**\n"
            f"‚Ä¢ `/mantenimiento on [nuevo mensaje]` - Activar con mensaje personalizado\n"
            f"‚Ä¢ `/maintenance on [nuevo mensaje]` - Comando alternativo\n\n"
            f"üóëÔ∏è **Auto-eliminaci√≥n:** Los mensajes se eliminan autom√°ticamente al finalizar el mantenimiento."
        )
        
        keyboard = [
            [InlineKeyboardButton("üî¥ Activar con Mensaje", callback_data="activate_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Cancelar mantenimiento programado
    if data == "cancel_scheduled_maintenance":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("UPDATE scheduled_maintenance SET is_active = FALSE WHERE is_active = TRUE")
                    updated_count = c.rowcount
                    conn.commit()
            
            if updated_count > 0:
                texto = (
                    f"üóëÔ∏è *Mantenimiento Programado Cancelado* üóëÔ∏è\n\n"
                    f"‚úÖ {updated_count} mantenimiento(s) programado(s) cancelado(s)\n"
                    f"üîÑ El bot contin√∫a operativo normalmente\n"
                    f"‚è∞ *Cancelado:* {get_spain_time()}"
                )
            else:
                texto = (
                    f"‚ÑπÔ∏è *Sin Mantenimientos Programados* ‚ÑπÔ∏è\n\n"
                    f"üìÖ No hay mantenimientos programados para cancelar\n"
                    f"üîß El sistema est√° en modo manual\n"
                    f"‚è∞ *Consulta:* {get_spain_time()}"
                )
        except Exception as e:
            texto = (
                f"‚ùå *Error al Cancelar* ‚ùå\n\n"
                f"‚ö†Ô∏è Error: {str(e)}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ *Intento:* {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üìÖ Programar Nuevo", callback_data="schedule_maintenance")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="maintenance_config"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Votaci√≥n comunitaria mejorada
    if data == "menu_votacion":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener estad√≠sticas generales
                    c.execute("""
                        SELECT
                            COUNT(DISTINCT pr.ticket_number) as total_pendientes,
                            COUNT(DISTINCT rv.ticket_number) as solicitudes_con_votos,
                            SUM(CASE WHEN rv.vote = 1 THEN 1 ELSE 0 END) as total_positivos,
                            SUM(CASE WHEN rv.vote = -1 THEN 1 ELSE 0 END) as total_negativos
                        FROM peticiones_registradas pr
                        LEFT JOIN request_votes rv ON pr.ticket_number = rv.ticket_number
                    """)
                    stats = c.fetchone()

                    # Obtener top 10 solicitudes m√°s votadas
                    c.execute("""
                        SELECT pr.ticket_number, pr.username, pr.message_text, pr.chat_title, pr.timestamp,
                               COALESCE(positive_votes.count, 0) as positive_votes,
                               COALESCE(negative_votes.count, 0) as negative_votes,
                               (COALESCE(positive_votes.count, 0) - COALESCE(negative_votes.count, 0)) as net_votes
                        FROM peticiones_registradas pr
                        LEFT JOIN (
                            SELECT ticket_number, COUNT(*) as count
                            FROM request_votes
                            WHERE vote = 1
                            GROUP BY ticket_number
                        ) positive_votes ON pr.ticket_number = positive_votes.ticket_number
                        LEFT JOIN (
                            SELECT ticket_number, COUNT(*) as count
                            FROM request_votes
                            WHERE vote = -1
                            GROUP BY ticket_number
                        ) negative_votes ON pr.ticket_number = negative_votes.ticket_number
                        ORDER BY net_votes DESC, pr.timestamp DESC
                        LIMIT 10
                    """)
                    peticiones = c.fetchall()

            if not peticiones:
                texto = (
                    f"üó≥Ô∏è *Votaci√≥n Comunitaria* üó≥Ô∏è\n\n"
                    f"üìä *Estad√≠sticas:*\n"
                    f"üìã Pendientes: {stats['total_pendientes']}\n"
                    f"üó≥Ô∏è Con votos: {stats['solicitudes_con_votos']}\n\n"
                    f"No hay solicitudes pendientes para votar."
                )
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_gestion"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"üó≥Ô∏è *Sistema de Votaci√≥n Comunitaria* üó≥Ô∏è\n\n"
                    f"üìä *Estad√≠sticas Generales:*\n"
                    f"‚Ä¢ üìã Total pendientes: {stats['total_pendientes']}\n"
                    f"‚Ä¢ üó≥Ô∏è Con votos: {stats['solicitudes_con_votos']}\n"
                    f"‚Ä¢ üëç Votos positivos: {stats['total_positivos']}\n"
                    f"‚Ä¢ üëé Votos negativos: {stats['total_negativos']}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üèÜ *Top 10 - Ordenadas por Popularidad:*\n"
                )

                keyboard = []

                for idx, p in enumerate(peticiones, 1):
                    net_votes = p["net_votes"]
                    total_votes = p["positive_votes"] + p["negative_votes"]

                    # Indicadores visuales mejorados
                    if net_votes > 5:
                        vote_indicator = "üî•"
                        vote_status = "Popular"
                    elif net_votes > 0:
                        vote_indicator = "üëç"
                        vote_status = "Positiva"
                    elif net_votes < -5:
                        vote_indicator = "‚ùÑÔ∏è"
                        vote_status = "Rechazada"
                    elif net_votes < 0:
                        vote_indicator = "üëé"
                        vote_status = "Negativa"
                    else:
                        vote_indicator = "‚öñÔ∏è"
                        vote_status = "Neutral"

                    # Medalla para top 3
                    medals = {1: "ü•á", 2: "ü•à", 3: "ü•â"}
                    medal = medals.get(idx, f"`{idx}.`")

                    # Preview del texto de la solicitud
                    text_preview = p["message_text"][:40] + "..." if len(p["message_text"]) > 40 else p["message_text"]

                    keyboard.append([
                        InlineKeyboardButton(
                            f"{medal} {vote_indicator} #{p['ticket_number']} | Net: {net_votes:+d} ({p['positive_votes']}/{p['negative_votes']})",
                            callback_data=f"show_votes_{p['ticket_number']}"
                        )
                    ])

                texto += f"\nüí° *Presiona una solicitud para ver detalles y votar*"

                keyboard.append([
                    InlineKeyboardButton("üìä Ver Estad√≠sticas", callback_data="voting_stats"),
                    InlineKeyboardButton("üîÑ Actualizar", callback_data="menu_votacion")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_gestion"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en votaci√≥n comunitaria: {str(e)}")
            await query.answer("‚ùå Error al cargar votaciones")

        return ConversationHandler.END

    # Estad√≠sticas de votaci√≥n detalladas
    if data == "voting_stats":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Solicitudes m√°s votadas (positivas)
                    c.execute("""
                        SELECT pr.ticket_number, pr.username, pr.message_text,
                               COUNT(CASE WHEN rv.vote = 1 THEN 1 END) as votos_positivos
                        FROM peticiones_registradas pr
                        LEFT JOIN request_votes rv ON pr.ticket_number = rv.ticket_number
                        GROUP BY pr.ticket_number, pr.username, pr.message_text
                        HAVING COUNT(CASE WHEN rv.vote = 1 THEN 1 END) > 0
                        ORDER BY votos_positivos DESC
                        LIMIT 5
                    """)
                    top_positivas = c.fetchall()

                    # Usuarios m√°s activos votando
                    c.execute("""
                        SELECT u.username, COUNT(*) as total_votos,
                               COUNT(CASE WHEN rv.vote = 1 THEN 1 END) as positivos,
                               COUNT(CASE WHEN rv.vote = -1 THEN 1 END) as negativos
                        FROM request_votes rv
                        JOIN usuarios u ON rv.user_id = u.user_id
                        GROUP BY u.username
                        ORDER BY total_votos DESC
                        LIMIT 5
                    """)
                    top_votantes = c.fetchall()

                    # Estad√≠sticas por tiempo
                    c.execute("""
                        SELECT
                            COUNT(*) as votos_ultimas_24h
                        FROM request_votes
                        WHERE timestamp >= NOW() - INTERVAL '24 hours'
                    """)
                    votos_24h = c.fetchone()["votos_ultimas_24h"]

            texto = (
                f"üìä *Estad√≠sticas de Votaci√≥n* üìä\n\n"
                f"‚è∞ **Actividad Reciente:**\n"
                f"‚Ä¢ Votos en 24h: {votos_24h}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            )

            if top_positivas:
                texto += f"üî• **Top 5 - Solicitudes M√°s Populares:**\n"
                for idx, sol in enumerate(top_positivas, 1):
                    preview = sol["message_text"][:35] + "..." if len(sol["message_text"]) > 35 else sol["message_text"]
                    texto += f"`{idx}.` üëç {sol['votos_positivos']} votos ‚Ä¢ #{sol['ticket_number']}\n"
                texto += "\n"

            if top_votantes:
                texto += f"üë• **Top 5 - Usuarios M√°s Activos:**\n"
                for idx, voter in enumerate(top_votantes, 1):
                    texto += (
                        f"`{idx}.` @{voter['username']} ‚Ä¢ "
                        f"{voter['total_votos']} votos "
                        f"(üëç{voter['positivos']}/üëé{voter['negativos']})\n"
                    )

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="voting_stats")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_votacion"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]

            reply_markup = InlineKeyboardMarkup(keyboard)
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en estad√≠sticas de votaci√≥n: {str(e)}")
            await query.answer("‚ùå Error al cargar estad√≠sticas")

        return ConversationHandler.END

    # Gesti√≥n masiva
    if data == "menu_masiva":
        await render_menu_masiva(query, user_id, chat_id, message_id)
        return ConversationHandler.END

    # Toggle de selecci√≥n para gesti√≥n masiva
    if data.startswith("toggle_select_"):
        ticket_number = int(data.split("_")[2])
        if user_id not in selected_requests:
            selected_requests[user_id] = []

        if ticket_number in selected_requests[user_id]:
            selected_requests[user_id].remove(ticket_number)
            await query.answer("‚ùå Desmarcada")
        else:
            selected_requests[user_id].append(ticket_number)
            await query.answer("‚úÖ Marcada")

        # Renderizar el men√∫ actualizado
        await render_menu_masiva(query, user_id, chat_id, message_id)
        return ConversationHandler.END

    # Inicio de denegaci√≥n masiva - pedir motivo
    if data == "batch_deny_start":
        selected = selected_requests.get(user_id, [])

        if not selected:
            await query.answer("‚ö†Ô∏è No hay solicitudes seleccionadas")
            return ConversationHandler.END

        divider = "‚îÅ" * 35
        texto = (
            f"{divider}\n"
            f"üî¥ *DENEGACI√ìN MASIVA DE SOLICITUDES* üî¥\n"
            f"{divider}\n\n"
            f"üìä *Resumen de la operaci√≥n:*\n"
            f"   ‚Ä¢ Solicitudes seleccionadas: `{len(selected)}`\n"
            f"   ‚Ä¢ Acci√≥n: Denegaci√≥n masiva\n\n"
            f"‚ö†Ô∏è *Esta acci√≥n afectar√° a m√∫ltiples solicitudes*\n\n"
            f"üìù Por favor, proporciona un motivo claro y detallado para denegar estas solicitudes.\n\n"
            f"üí¨ **Escribe el motivo a continuaci√≥n:**"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Cancelar y Volver", callback_data="menu_masiva")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        admin_waiting_responses[user_id] = {
            "response_type": "batch_deny_reason",
            "type": "batch_deny_reason",
            "selected_tickets": selected,
            "chat_id": chat_id,
            "message_id": message_id,
            "ticket_number": None,
            "data": {},
            "timestamp": datetime.now(SPAIN_TZ)
        }

        return ConversationHandler.END

    # Procesamiento en lote
    if data.startswith("batch_"):
        action = data.split("_")[1]
        selected = selected_requests.get(user_id, [])

        if not selected:
            await query.answer("‚ö†Ô∏è No hay solicitudes seleccionadas")
            return ConversationHandler.END

        processed = 0
        admin_username = "Equipo de Administraci√≥n"

        for ticket_number in selected:
            peticion = get_peticion_registrada(ticket_number)
            if peticion:
                if action == "approve":
                    await set_historial_solicitud(ticket_number, {
                        "chat_id": peticion["chat_id"],
                        "username": peticion["username"],
                        "user_id": peticion["user_id"],
                        "message_text": peticion["message_text"],
                        "chat_title": peticion["chat_title"],
                        "estado": "subido",
                        "fecha_gestion": datetime.now(SPAIN_TZ),
                        "admin_username": admin_username,
                        "url": "Aprobado en lote",
                        "has_attachment": peticion["has_attachment"],
                        "photo_file_id": peticion["photo_file_id"]
                    })
                    
                    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
                    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
                    message_text_escaped = escape_markdown(peticion["message_text"])
                    
                    notification_message = await safe_bot_method(
                        context.bot.send_message,
                        chat_id=canal_info["chat_id"],
                        text=(
                            f"‚úÖ *Solicitud Aprobada* ‚úÖ\n"
                            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido aprobada por el *Equipo de Administraci√≥n*.\n"
                            f"üìå *Detalles:*\n"
                            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
                            f"‚è∞ *Fecha:* {get_spain_time()}\n"
                            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
                            f"üòä Por favor, califica tu experiencia con la encuesta."
                        ),
                        message_thread_id=canal_info["thread_id"],
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton("üòä Encuesta de Satisfacci√≥n", callback_data=f"encuesta_{ticket_number}")]
                        ]),
                        parse_mode="Markdown"
                    )

                    # Registrar encuesta pendiente para recordatorio
                    save_pending_survey(ticket_number, peticion["user_id"], peticion["username"], peticion["chat_id"], peticion["message_text"], peticion["chat_title"])

                elif action == "deny":
                    await set_historial_solicitud(ticket_number, {
                        "chat_id": peticion["chat_id"],
                        "username": peticion["username"],
                        "user_id": peticion["user_id"],
                        "message_text": peticion["message_text"],
                        "chat_title": peticion["chat_title"],
                        "estado": "denegado",
                        "fecha_gestion": datetime.now(SPAIN_TZ),
                        "admin_username": admin_username,
                        "reason": "Denegado en gesti√≥n masiva",
                        "has_attachment": peticion["has_attachment"],
                        "photo_file_id": peticion["photo_file_id"]
                    })
                    
                    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
                    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
                    message_text_escaped = escape_markdown(peticion["message_text"])
                    
                    notification_message = await safe_bot_method(
                        context.bot.send_message,
                        chat_id=canal_info["chat_id"],
                        text=(
                            f"‚ùå *Solicitud Denegada* ‚ùå\n"
                            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido denegada por el *Equipo de Administraci√≥n*.\n"
                            f"üìå *Detalles:*\n"
                            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
                            f"üìù *Motivo:* Denegado en gesti√≥n masiva\n"
                            f"‚è∞ *Fecha:* {get_spain_time()}\n"
                            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
                            f"Si tienes dudas, contacta con @admin."
                        ),
                        message_thread_id=canal_info["thread_id"],
                        parse_mode="Markdown"
                    )
                    
                elif action == "delete":
                    await set_historial_solicitud(ticket_number, {
                        "chat_id": peticion["chat_id"],
                        "username": peticion["username"],
                        "user_id": peticion["user_id"],
                        "message_text": peticion["message_text"],
                        "chat_title": peticion["chat_title"],
                        "estado": "eliminado",
                        "fecha_gestion": datetime.now(SPAIN_TZ),
                        "admin_username": admin_username,
                        "reason": "Eliminado en gesti√≥n masiva",
                        "has_attachment": peticion["has_attachment"],
                        "photo_file_id": peticion["photo_file_id"]
                    })
                    
                    canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
                    username_escaped = escape_markdown(peticion["username"], preserve_username=True)
                    message_text_escaped = escape_markdown(peticion["message_text"])
                    
                    notification_message = await safe_bot_method(
                        context.bot.send_message,
                        chat_id=canal_info["chat_id"],
                        text=(
                            f"üóëÔ∏è *Solicitud Eliminada* üóëÔ∏è\n"
                            f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido eliminada por el *Equipo de Administraci√≥n*.\n"
                            f"üìå *Detalles:*\n"
                            f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
                            f"‚è∞ *Fecha:* {get_spain_time()}\n"
                            f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
                            f"Si tienes dudas, contacta con @admin."
                        ),
                        message_thread_id=canal_info["thread_id"],
                        parse_mode="Markdown"
                    )
                
                del_peticion_registrada(ticket_number)
                
                if peticion.get("message_id"):
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=GROUP_DESTINO,
                        message_id=peticion["message_id"]
                    )
                
                photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
                if photo_message_id:
                    await safe_bot_method(
                        context.bot.delete_message,
                        chat_id=GROUP_DESTINO,
                        message_id=photo_message_id
                    )
                    if f"photo_{ticket_number}" in context.bot_data:
                        del context.bot_data[f"photo_{ticket_number}"]
                
                # Eliminar mensaje de confirmaci√≥n cuando se gestiona
                await delete_confirmation_message(context, ticket_number)
                
                processed += 1
        
        selected_requests[user_id] = []
        
        action_text = "aprobadas" if action == "approve" else "denegadas" if action == "deny" else "eliminadas"
        texto = (
            f"‚úÖ *Gesti√≥n Masiva Completada* ‚úÖ\n\n"
            f"üìä *Solicitudes {action_text}:* {processed}\n"
            f"üë§ *Administrador:* {admin_username}\n"
            f"‚è∞ *Fecha:* {get_spain_time()}"
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data="menu_gestion"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Gesti√≥n masiva {action} completada por user_id={user_id}, {processed} solicitudes procesadas")
        return ConversationHandler.END

    if data == "clear_selection":
        selected_requests[user_id] = []
        await query.answer("üóëÔ∏è Selecci√≥n limpiada")
        # Renderizar el men√∫ actualizado
        await render_menu_masiva(query, user_id, chat_id, message_id)
        return ConversationHandler.END

    # Seleccionar todas las solicitudes
    if data == "select_all_batch":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT ticket_number FROM peticiones_registradas ORDER BY timestamp DESC LIMIT 15")
                    all_tickets = [row[0] for row in c.fetchall()]

            selected_requests[user_id] = all_tickets
            await query.answer(f"‚òëÔ∏è {len(all_tickets)} solicitudes seleccionadas")
            await render_menu_masiva(query, user_id, chat_id, message_id)
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error seleccionando todas: {str(e)}")
            await query.answer("‚ùå Error al seleccionar", show_alert=True)
        return ConversationHandler.END

    # Deseleccionar todas las solicitudes
    if data == "deselect_all_batch":
        count = len(selected_requests.get(user_id, []))
        selected_requests[user_id] = []
        await query.answer(f"‚¨ú {count} solicitudes deseleccionadas")
        await render_menu_masiva(query, user_id, chat_id, message_id)
        return ConversationHandler.END

    # Handler para botones decorativos (noop = no operation)
    if data == "noop":
        await query.answer()
        return ConversationHandler.END

    # ==================== GESTI√ìN DE SOLICITUDES DE CONTACTO ====================

    # Listar solicitudes de contacto (con filtro opcional)
    if data.startswith("menu_contact_list"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            # Extraer filtro del callback_data
            parts = data.split("_")
            estado_filter = parts[3] if len(parts) > 3 and parts[3] != "todas" else None

            # Obtener solicitudes
            conn = get_db_connection()
            requests = get_contact_requests_by_status(conn, estado_filter, limit=50)
            release_db_connection(conn)

            # Formatear mensaje
            texto, keyboard = format_contact_list_message(requests, page=1, estado_filter=estado_filter)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": keyboard,
                "last_page": 1
            }

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error listando solicitudes de contacto: {str(e)}")
            await query.answer("‚ùå Error al cargar solicitudes", show_alert=True)

        return ConversationHandler.END

    # Ver detalle de una solicitud de contacto
    if data.startswith("contact_view_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            request_id = int(data.split("_")[2])

            conn = get_db_connection()
            request = get_contact_request(conn, request_id)
            release_db_connection(conn)

            if not request:
                await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
                return ConversationHandler.END

            texto, keyboard = format_contact_detail_message(request)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=keyboard,
                parse_mode="Markdown"
            )

            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": keyboard,
                "last_page": 1
            }

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error viendo detalle de solicitud: {str(e)}")
            await query.answer("‚ùå Error al cargar detalle", show_alert=True)

        return ConversationHandler.END

    # Iniciar proceso de responder a solicitud
    if data.startswith("contact_respond_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            request_id = int(data.split("_")[2])

            conn = get_db_connection()
            request = get_contact_request(conn, request_id)
            release_db_connection(conn)

            if not request:
                await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
                return ConversationHandler.END

            divider = "‚îÅ" * 32
            texto = (
                f"{divider}\n"
                f"üìù *RESPONDER A SOLICITUD #{request_id}* üìù\n"
                f"{divider}\n\n"
                f"üë§ *Usuario:* [@{request['username']}](https://t.me/{request['username']})\n"
                f"ü™™ *Nombre:* {request['full_name']}\n\n"
                f"üí¨ *Mensaje original:*\n"
                f"> {request['message'][:200]}{'...' if len(request['message']) > 200 else ''}\n\n"
                f"{divider}\n\n"
                f"‚úçÔ∏è *Escribe tu respuesta a continuaci√≥n:*\n\n"
                f"üí° Tu mensaje ser√° enviado directamente al usuario"
            )

            keyboard = [
                [InlineKeyboardButton("‚ùå Cancelar", callback_data=f"contact_view_{request_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Guardar estado de espera de respuesta
            set_admin_waiting_response(user_id, chat_id, "contact_response", request_id, {
                "request_id": request_id,
                "request_user_id": request['user_id'],
                "request_username": request['username'],
                "original_message": request['message'],
                "message_id": message_id
            })

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error iniciando respuesta: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Confirmar respuesta a solicitud
    if data.startswith("contact_confirm_response_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            request_id = int(data.split("_")[3])
            logger.info(f"üîç Intentando confirmar respuesta para solicitud #{request_id} por admin {user_id}")

            waiting_data = get_admin_waiting_response(user_id, chat_id)
            logger.info(f"üîç waiting_data: {waiting_data}")

            if not waiting_data:
                logger.error(f"‚ö†Ô∏è No hay waiting_data para admin {user_id} en chat {chat_id}")
                await query.answer("‚ùå Sesi√≥n expirada - no hay datos", show_alert=True)
                return ConversationHandler.END

            if waiting_data.get("ticket_number") != request_id:
                logger.error(f"‚ö†Ô∏è ticket_number no coincide: esperado={request_id}, recibido={waiting_data.get('ticket_number')}")
                await query.answer("‚ùå Sesi√≥n expirada - ID no coincide", show_alert=True)
                return ConversationHandler.END

            # Extraer datos correctamente desde waiting_data["data"]
            data_dict = waiting_data.get("data", {})

            # El response_text est√° dentro de data_dict
            response_text = data_dict.get("response_text", "")
            logger.info(f"üîç response_text: '{response_text[:50] if response_text else 'VACIO'}...' (longitud: {len(response_text)})")

            if not response_text or len(response_text.strip()) == 0:
                logger.error(f"‚ö†Ô∏è response_text est√° vac√≠o. data_dict completo: {data_dict}")
                await query.answer("‚ùå Error: respuesta vac√≠a", show_alert=True)
                return ConversationHandler.END

            request_user_id = data_dict.get("request_user_id")
            request_username = data_dict.get("request_username")

            logger.info(f"üîç Extrayendo datos: user_id={request_user_id}, username={request_username}")

            if not request_user_id:
                logger.error(f"‚ö†Ô∏è No se encontr√≥ request_user_id en waiting_data: {waiting_data}")
                await query.answer("‚ùå Error: informaci√≥n de usuario no encontrada", show_alert=True)
                return ConversationHandler.END

            # Guardar respuesta en BD
            conn = get_db_connection()
            admin_username = query.from_user.username or f"Admin{user_id}"
            logger.info(f"üíæ Guardando respuesta en BD: request_id={request_id}, admin={admin_username}")
            success = respond_contact_request(conn, request_id, user_id, admin_username, response_text)
            release_db_connection(conn)

            if not success:
                logger.error(f"‚ö†Ô∏è Error guardando respuesta en BD para solicitud #{request_id}")
                await query.answer("‚ùå Error guardando respuesta", show_alert=True)
                return ConversationHandler.END

            logger.info(f"‚úÖ Respuesta guardada en BD para solicitud #{request_id}")

            # Enviar respuesta al usuario con formato profesional
            user_message = format_user_notification_responded(request_username, request_id, response_text)
            logger.info(f"üì§ Enviando mensaje al usuario {request_user_id} (@{request_username})")

            sent_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=request_user_id,
                text=user_message,
                parse_mode="Markdown"
            )

            if sent_message:
                logger.info(f"‚úÖ Mensaje enviado exitosamente al usuario {request_user_id}")
            else:
                logger.error(f"‚ö†Ô∏è No se pudo enviar mensaje al usuario {request_user_id}")

            # Confirmar al admin
            texto = (
                f"‚úÖ *¬°RESPUESTA ENVIADA!* ‚úÖ\n\n"
                f"üì¨ Tu respuesta ha sido enviada a @{request_username}\n"
                f"üÜî Solicitud #{request_id} marcada como respondida\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Listado", callback_data="menu_contact_list_todas")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            logger.info(f"üìù Actualizando mensaje del admin con confirmaci√≥n")
            edited = await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            if edited:
                logger.info(f"‚úÖ Mensaje de confirmaci√≥n mostrado al admin")
            else:
                logger.error(f"‚ö†Ô∏è No se pudo actualizar mensaje de confirmaci√≥n")

            # Limpiar estado
            clear_admin_waiting_response(user_id, chat_id)
            logger.info(f"üßπ Estado de espera limpiado para admin {user_id}")

            logger.info(f"‚úÖ Solicitud #{request_id} respondida por admin {user_id} - PROCESO COMPLETADO")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error confirmando respuesta: {str(e)}")
            await query.answer("‚ùå Error al enviar respuesta", show_alert=True)

        return ConversationHandler.END

    # Corregir respuesta
    if data.startswith("contact_edit_response_"):
        try:
            request_id = int(data.split("_")[3])

            divider = "‚îÅ" * 32
            texto = (
                f"{divider}\n"
                f"‚úèÔ∏è *CORREGIR RESPUESTA* ‚úèÔ∏è\n"
                f"{divider}\n\n"
                f"Escribe tu respuesta corregida:"
            )

            keyboard = [
                [InlineKeyboardButton("‚ùå Cancelar", callback_data=f"contact_view_{request_id}")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Mantener estado pero limpiar response_text
            waiting_data = get_admin_waiting_response(user_id, chat_id)
            if waiting_data:
                waiting_data["response_text"] = ""
                set_admin_waiting_response(user_id, chat_id, "contact_response", request_id, waiting_data)

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error corrigiendo respuesta: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Cerrar solicitud de contacto
    if data.startswith("contact_close_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            request_id = int(data.split("_")[2])

            conn = get_db_connection()
            request = get_contact_request(conn, request_id)
            success = close_contact_request(conn, request_id, user_id)
            release_db_connection(conn)

            if success and request:
                # Notificar al usuario
                user_notification = format_user_notification_closed(request['username'], request_id)
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=request['user_id'],
                    text=user_notification,
                    parse_mode="Markdown"
                )

                await query.answer("‚úÖ Solicitud cerrada correctamente")

                # Volver al listado
                conn = get_db_connection()
                requests = get_contact_requests_by_status(conn, None, limit=50)
                release_db_connection(conn)

                texto, keyboard = format_contact_list_message(requests, page=1, estado_filter=None)

                await safe_bot_method(
                    query.edit_message_text,
                    text=texto,
                    reply_markup=keyboard,
                    parse_mode="Markdown"
                )
            else:
                await query.answer("‚ùå Error al cerrar solicitud", show_alert=True)

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error cerrando solicitud: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Reabrir solicitud de contacto
    if data.startswith("contact_reopen_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de contacto no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            request_id = int(data.split("_")[2])

            conn = get_db_connection()
            request = get_contact_request(conn, request_id)
            success = reopen_contact_request(conn, request_id, user_id)
            release_db_connection(conn)

            if success and request:
                # Notificar al usuario
                user_notification = format_user_notification_reopened(request['username'], request_id)
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=request['user_id'],
                    text=user_notification,
                    parse_mode="Markdown"
                )

                await query.answer("‚úÖ Solicitud reabierta correctamente")

                # Mostrar detalle de la solicitud reabierta
                conn = get_db_connection()
                request = get_contact_request(conn, request_id)
                release_db_connection(conn)

                if request:
                    texto, keyboard = format_contact_detail_message(request)

                    await safe_bot_method(
                        query.edit_message_text,
                        text=texto,
                        reply_markup=keyboard,
                        parse_mode="Markdown"
                    )
            else:
                await query.answer("‚ùå Error al reabrir solicitud", show_alert=True)

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reabriendo solicitud: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Bloquear usuario
    if data.startswith("contact_block_user_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de bloqueo no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            target_user_id = int(data.split("_")[3])
            admin_username = query.from_user.username or f"Admin{user_id}"

            # Obtener informaci√≥n del usuario desde la BD
            conn = get_db_connection()

            # Buscar info del usuario en solicitudes de contacto
            with conn.cursor() as c:
                c.execute("""
                    SELECT username, full_name FROM contact_requests
                    WHERE user_id = %s
                    ORDER BY created_at DESC LIMIT 1
                """, (target_user_id,))
                user_info = c.fetchone()

            if not user_info:
                release_db_connection(conn)
                await query.answer("‚ùå No se encontr√≥ informaci√≥n del usuario", show_alert=True)
                return ConversationHandler.END

            target_username = user_info[0] or f"Usuario{target_user_id}"
            target_fullname = user_info[1] or "Sin nombre"

            # Verificar si ya est√° bloqueado
            if is_user_blocked(conn, target_user_id):
                release_db_connection(conn)
                await query.answer("‚ö†Ô∏è Este usuario ya est√° bloqueado", show_alert=True)
                return ConversationHandler.END

            # Mostrar confirmaci√≥n
            divider = "‚îÅ" * 32
            texto_confirmacion = (
                f"{divider}\n"
                f"‚ö†Ô∏è *CONFIRMAR BLOQUEO* ‚ö†Ô∏è\n"
                f"{divider}\n\n"
                f"¬øEst√°s seguro de bloquear a este usuario?\n\n"
                f"üë§ *Usuario:* @{target_username}\n"
                f"ü™™ *Nombre:* {target_fullname}\n"
                f"üÜî *ID:* `{target_user_id}`\n\n"
                f"{divider}\n\n"
                f"‚ö†Ô∏è *Efectos del bloqueo:*\n"
                f"‚Ä¢ No podr√° usar el bot\n"
                f"‚Ä¢ No podr√° enviar mensajes\n"
                f"‚Ä¢ No podr√° enviar solicitudes\n\n"
                f"üí° Puedes desbloquearlo m√°s tarde"
            )

            keyboard = [
                [InlineKeyboardButton("‚úÖ Confirmar Bloqueo", callback_data=f"contact_confirm_block_{target_user_id}")],
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="menu_contact_list_todas")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=texto_confirmacion,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            release_db_connection(conn)

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error mostrando confirmaci√≥n de bloqueo: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Confirmar bloqueo de usuario
    if data.startswith("contact_confirm_block_"):
        if not CONTACT_SYSTEM_AVAILABLE:
            await query.answer("‚ùå Sistema de bloqueo no disponible", show_alert=True)
            return ConversationHandler.END

        try:
            target_user_id = int(data.split("_")[3])
            admin_username = query.from_user.username or f"Admin{user_id}"

            conn = get_db_connection()

            # Obtener informaci√≥n del usuario
            with conn.cursor() as c:
                c.execute("""
                    SELECT username, full_name FROM contact_requests
                    WHERE user_id = %s
                    ORDER BY created_at DESC LIMIT 1
                """, (target_user_id,))
                user_info = c.fetchone()

            if not user_info:
                release_db_connection(conn)
                await query.answer("‚ùå No se encontr√≥ informaci√≥n del usuario", show_alert=True)
                return ConversationHandler.END

            target_username = user_info[0] or f"Usuario{target_user_id}"
            target_fullname = user_info[1] or "Sin nombre"

            # Bloquear usuario
            success = block_user(
                conn,
                target_user_id,
                target_username,
                target_fullname,
                "Bloqueado por administrador desde solicitud de contacto",
                user_id,
                admin_username,
                notes="Bloqueado desde panel de solicitudes de contacto"
            )

            release_db_connection(conn)

            if success:
                await query.answer("‚úÖ Usuario bloqueado correctamente", show_alert=True)

                divider = "‚îÅ" * 32
                texto_resultado = (
                    f"{divider}\n"
                    f"üö´ *USUARIO BLOQUEADO* üö´\n"
                    f"{divider}\n\n"
                    f"‚úÖ El usuario ha sido bloqueado exitosamente\n\n"
                    f"üë§ *Usuario:* @{target_username}\n"
                    f"ü™™ *Nombre:* {target_fullname}\n"
                    f"üÜî *ID:* `{target_user_id}`\n"
                    f"üëÆ *Bloqueado por:* @{admin_username}\n"
                    f"üìÖ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y ‚Äì %H:%M')}\n\n"
                    f"{divider}\n\n"
                    f"‚ÑπÔ∏è El usuario no podr√° usar el bot hasta ser desbloqueado"
                )

                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver al Listado", callback_data="menu_contact_list_todas")],
                    [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await safe_bot_method(
                    query.edit_message_text,
                    text=texto_resultado,
                    reply_markup=reply_markup,
                    parse_mode="Markdown"
                )

                logger.info(f"üö´ Usuario {target_user_id} bloqueado por admin {user_id}")
            else:
                await query.answer("‚ùå Error al bloquear usuario", show_alert=True)

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error bloqueando usuario: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # ==================== MEN√ö DE USUARIO (CALLBACKS DEL /START) ====================

    # Bot√≥n: Mis Puntos
    if data == "user_menu_puntos":
        try:
            puntos_info = obtener_puntos_usuario(user_id)
            if not puntos_info:
                crear_usuario_puntos(user_id, query.from_user.username or f"Usuario{user_id}")
                puntos_info = obtener_puntos_usuario(user_id)

            nivel_config = NIVELES.get(puntos_info["nivel"], NIVELES["bronce"])
            nivel_emoji = nivel_config["emoji"]

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üí∞ *TUS PUNTOS Y ESTAD√çSTICAS* üí∞\n"
                f"{divider}\n\n"
                f"üéØ *NIVEL*\n"
                f"{nivel_emoji} *{puntos_info['nivel'].upper()}* ‚Ä¢ {puntos_info['puntos']:,} pts\n\n"
                f"{divider}\n\n"
                f"üìà *ESTAD√çSTICAS*\n"
                f"   ‚Ä¢ Solicitudes: *{puntos_info['solicitudes_aprobadas']}*\n"
                f"   ‚Ä¢ Encuestas: *{puntos_info['encuestas_completadas']}*\n"
                f"   ‚Ä¢ Racha: *{puntos_info['racha_dias']}* d√≠as üî•\n\n"
                f"üí° *FORMAS DE GANAR PUNTOS*\n"
                f"   ‚Ä¢ +50 pts ‚Üí Solicitud aprobada\n"
                f"   ‚Ä¢ +10 pts ‚Üí Completar encuesta\n"
                f"   ‚Ä¢ +5 pts ‚Üí Racha semanal\n\n"
                f"üéÅ *Usa los botones para canjear recompensas*"
            )

            keyboard = [
                [InlineKeyboardButton("üéÅ Ver Recompensas", callback_data="user_view_rewards")],
                [InlineKeyboardButton("üèÜ Ver Ranking", callback_data="user_menu_ranking")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")],
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_menu_puntos: {str(e)}")
            await query.answer("‚ùå Error al cargar puntos", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Ver Recompensas Disponibles
    if data == "user_view_rewards":
        try:
            recompensas = obtener_recompensas_disponibles()
            puntos_usuario = obtener_puntos_usuario(user_id)

            if not puntos_usuario:
                crear_usuario_puntos(user_id, query.from_user.username or f"Usuario{user_id}")
                puntos_usuario = obtener_puntos_usuario(user_id)

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üéÅ *TIENDA DE RECOMPENSAS* üéÅ\n"
                f"{divider}\n\n"
                f"üí∞ *Tus puntos:* {puntos_usuario['puntos']:,} pts\n\n"
                f"{divider}\n\n"
            )

            keyboard = []

            if recompensas:
                mensaje += f"üõçÔ∏è *Recompensas disponibles:*\n\n"
                for r in recompensas:
                    puede_canjear = puntos_usuario['puntos'] >= r['costo_puntos']
                    icono = "‚úÖ" if puede_canjear else "üîí"
                    mensaje += (
                        f"{icono} *{r['nombre']}*\n"
                        f"   üíé {r['costo_puntos']} puntos\n"
                        f"   üìù {r['descripcion']}\n\n"
                    )

                    if puede_canjear:
                        keyboard.append([
                            InlineKeyboardButton(
                                f"üéÅ Canjear: {r['nombre']} ({r['costo_puntos']} pts)",
                                callback_data=f"user_confirm_redeem_{r['id']}"
                            )
                        ])
            else:
                mensaje += "üì≠ *No hay recompensas disponibles en este momento*\n\n¬°Pronto habr√° nuevas recompensas!"

            keyboard.append([InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="user_menu_puntos")])
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_view_rewards: {str(e)}")
            await query.answer("‚ùå Error al cargar recompensas", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Confirmar canje de recompensa
    if data.startswith("user_confirm_redeem_"):
        try:
            reward_id = int(data.split("_")[-1])
            recompensa = obtener_recompensa_por_id(reward_id)
            puntos_usuario = obtener_puntos_usuario(user_id)

            if not recompensa or not puntos_usuario:
                await query.answer("‚ùå Error: Recompensa o usuario no encontrado", show_alert=True)
                return ConversationHandler.END

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üéÅ *CONFIRMAR CANJE* üéÅ\n"
                f"{divider}\n\n"
                f"üì¶ *Recompensa:* {recompensa['nombre']}\n"
                f"üìù *Descripci√≥n:* {recompensa['descripcion']}\n"
                f"üíé *Costo:* {recompensa['costo_puntos']} puntos\n\n"
                f"{divider}\n\n"
                f"üí∞ *Tus puntos actuales:* {puntos_usuario['puntos']:,}\n"
                f"üí∞ *Puntos despu√©s del canje:* {puntos_usuario['puntos'] - recompensa['costo_puntos']:,}\n\n"
                f"‚ùì *¬øConfirmas el canje?*"
            )

            keyboard = [
                [InlineKeyboardButton("‚úÖ S√≠, Canjear", callback_data=f"user_redeem_{reward_id}"),
                 InlineKeyboardButton("‚ùå Cancelar", callback_data="user_view_rewards")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_confirm_redeem: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Ejecutar canje de recompensa
    if data.startswith("user_redeem_"):
        try:
            reward_id = int(data.split("_")[-1])
            username = query.from_user.username or f"Usuario{user_id}"
            success, mensaje_resultado = canjear_recompensa(user_id, username, reward_id)

            if success:
                await query.answer(f"‚úÖ ¬°Recompensa canjeada con √©xito!", show_alert=True)

                # Obtener puntos actuales despu√©s del canje
                puntos_usuario = obtener_puntos_usuario(user_id)
                recompensa = obtener_recompensa_por_id(reward_id)

                divider = "‚îÅ" * 32
                mensaje = (
                    f"{divider}\n"
                    f"‚úÖ *¬°CANJE EXITOSO!* ‚úÖ\n"
                    f"{divider}\n\n"
                    f"üéÅ *Recompensa:* {recompensa['nombre']}\n"
                    f"üí∞ *Puntos gastados:* -{recompensa['costo_puntos']}\n"
                    f"üí∞ *Puntos restantes:* {puntos_usuario['puntos']:,}\n\n"
                    f"üì¨ *El equipo procesar√° tu solicitud pronto*\n\n"
                    f"‚ú® ¬°Gracias por participar!"
                )

                keyboard = [
                    [InlineKeyboardButton("üéÅ Ver M√°s Recompensas", callback_data="user_view_rewards")],
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
                ]
            else:
                await query.answer(f"‚ùå Error: {mensaje_resultado}", show_alert=True)

                mensaje = (
                    f"‚ùå *ERROR EN EL CANJE* ‚ùå\n\n"
                    f"‚ö†Ô∏è {mensaje_resultado}\n\n"
                    f"Por favor, verifica tus puntos e intenta nuevamente."
                )

                keyboard = [
                    [InlineKeyboardButton("üí∞ Ver Mis Puntos", callback_data="user_menu_puntos")],
                    [InlineKeyboardButton("üéÅ Ver Recompensas", callback_data="user_view_rewards")]
                ]

            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_redeem: {str(e)}")
            await query.answer("‚ùå Error al procesar el canje", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Mis Solicitudes
    if data == "user_menu_solicitudes":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Solicitudes pendientes
                    c.execute("""
                        SELECT ticket_number, message_text, chat_title, timestamp
                        FROM peticiones_registradas
                        WHERE user_id = %s
                        ORDER BY timestamp DESC
                        LIMIT 5
                    """, (user_id,))
                    pendientes = c.fetchall()

                    # Solicitudes gestionadas (√∫ltimas 5)
                    c.execute("""
                        SELECT ticket_number, message_text, estado, fecha_gestion
                        FROM historial_solicitudes
                        WHERE user_id = %s
                        ORDER BY fecha_gestion DESC
                        LIMIT 5
                    """, (user_id,))
                    historial = c.fetchall()

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üìã *MIS SOLICITUDES* üìã\n"
                f"{divider}\n\n"
            )

            if pendientes:
                mensaje += f"‚è≥ *PENDIENTES* ({len(pendientes)}):\n\n"
                for p in pendientes:
                    msg_preview = p['message_text'][:40] + "..." if len(p['message_text']) > 40 else p['message_text']
                    mensaje += f"üé´ *#{p['ticket_number']}*\n   {msg_preview}\n   üìç {p['chat_title']}\n\n"
            else:
                mensaje += f"‚è≥ *PENDIENTES:* Ninguna\n\n"

            mensaje += f"{divider}\n\n"

            if historial:
                mensaje += f"üìú *HISTORIAL* ({len(historial)}):\n\n"
                for h in historial:
                    estado_emoji = "‚úÖ" if h['estado'] == "subido" else "‚ùå"
                    msg_preview = h['message_text'][:30] + "..." if len(h['message_text']) > 30 else h['message_text']
                    mensaje += f"{estado_emoji} *#{h['ticket_number']}* ‚Ä¢ {h['estado']}\n   {msg_preview}\n\n"
            else:
                mensaje += f"üìú *HISTORIAL:* Vac√≠o"

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_menu_solicitudes: {str(e)}")
            await query.answer("‚ùå Error al cargar solicitudes", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Mis Sanciones
    if data == "user_menu_sanciones":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Verificar penalizaciones activas
                    c.execute("""
                        SELECT total_penalties, penalty_expires
                        FROM active_penalties
                        WHERE user_id = %s AND (penalty_expires IS NULL OR penalty_expires > NOW())
                    """, (user_id,))
                    penalties = c.fetchone()

                    # Verificar usuarios silenciados
                    c.execute("""
                        SELECT is_muted, unmute_at, mute_reason
                        FROM usuarios
                        WHERE user_id = %s
                    """, (user_id,))
                    mute_info = c.fetchone()

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"‚ö†Ô∏è *MIS SANCIONES Y ADVERTENCIAS* ‚ö†Ô∏è\n"
                f"{divider}\n\n"
            )

            tiene_sanciones = False

            if penalties and penalties['total_penalties'] > 0:
                tiene_sanciones = True
                mensaje += f"üö´ *Advertencias activas:* {penalties['total_penalties']}\n"
                if penalties['penalty_expires']:
                    expira = penalties['penalty_expires'].strftime("%d/%m/%Y %H:%M")
                    mensaje += f"‚è∞ *Expiran:* {expira}\n"
                mensaje += "\n"

            if mute_info and mute_info['is_muted']:
                tiene_sanciones = True
                mensaje += f"üîá *Estado:* Silenciado\n"
                if mute_info['mute_reason']:
                    mensaje += f"üìù *Motivo:* {mute_info['mute_reason']}\n"
                if mute_info['unmute_at']:
                    expira = mute_info['unmute_at'].strftime("%d/%m/%Y %H:%M")
                    mensaje += f"‚è∞ *Hasta:* {expira}\n"
                mensaje += "\n"

            if not tiene_sanciones:
                mensaje += (
                    f"‚úÖ *¬°Todo en orden!*\n\n"
                    f"No tienes sanciones activas ni advertencias.\n\n"
                    f"üí° *Sigue las normas del bot para mantener tu cuenta en buen estado:*\n\n"
                    f"   ‚Ä¢ M√°ximo 2 solicitudes por d√≠a\n"
                    f"   ‚Ä¢ No env√≠es solicitudes duplicadas\n"
                    f"   ‚Ä¢ Respeta el horario del bot\n"
                    f"   ‚Ä¢ Lee los mensajes fijados\n\n"
                    f"üéâ ¬°Gracias por ser un usuario ejemplar!"
                )
            else:
                mensaje += (
                    f"{divider}\n\n"
                    f"üí° *C√ìMO EVITAR SANCIONES:*\n"
                    f"   ‚Ä¢ Respeta las normas del bot\n"
                    f"   ‚Ä¢ No abuses del sistema\n"
                    f"   ‚Ä¢ Lee los mensajes fijados\n"
                    f"   ‚Ä¢ Solicita solo contenido v√°lido\n\n"
                    f"üì¨ Las advertencias expiran autom√°ticamente"
                )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_menu_sanciones: {str(e)}")
            await query.answer("‚ùå Error al cargar sanciones", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Ver Ranking
    if data == "user_menu_ranking":
        try:
            top_usuarios = obtener_top_usuarios(10)

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üèÜ *RANKING DE USUARIOS* üèÜ\n"
                f"{divider}\n\n"
                f"üéØ *Top 10 por Puntos*\n\n"
            )

            if top_usuarios:
                for i, usuario in enumerate(top_usuarios, 1):
                    medalla = {"1": "ü•á", "2": "ü•à", "3": "ü•â"}.get(str(i), f"{i}.")
                    nivel_emoji = NIVELES.get(usuario['nivel'], NIVELES['bronce'])['emoji']
                    # Escapar caracteres especiales de Markdown en username
                    if usuario['username']:
                        username_clean = usuario['username'].lstrip('@')
                        user_mention = escape_markdown(f"@{username_clean}", preserve_username=True)
                    else:
                        user_mention = f"Usuario {usuario['user_id']}"

                    mensaje += (
                        f"{medalla} {user_mention}\n"
                        f"     {nivel_emoji} {escape_markdown(usuario['nivel'].title())} ‚Ä¢ {usuario['puntos']:,} pts\n\n"
                    )
            else:
                mensaje += "üì≠ No hay usuarios en el ranking todav√≠a"

            keyboard = [
                [InlineKeyboardButton("üîÑ Actualizar", callback_data="user_menu_ranking")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_menu_ranking: {str(e)}")
            await query.answer("‚ùå Error al cargar ranking", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Horario del Bot
    if data == "user_menu_horario":
        try:
            horario = obtener_horario()

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üïê *HORARIO DEL BOT* üïê\n"
                f"{divider}\n\n"
            )

            if horario and horario.get('days_of_week'):
                # Verificar si est√° activo actualmente
                is_active = is_within_schedule()
                estado_actual = "üü¢ *ACTIVO*" if is_active else "üî¥ *INACTIVO*"

                mensaje += f"üìä *Estado actual:* {estado_actual}\n\n"

                # Mostrar d√≠as activos
                days_str = ", ".join(horario['days_of_week'])
                mensaje += f"üìÖ *D√≠as activos:*\n{days_str}\n\n"

                # Mostrar horario
                mensaje += (
                    f"üïí *Horario de solicitudes:*\n"
                    f"De {horario.get('start_hour', 'No configurado')} a {horario.get('end_hour', 'No configurado')}\n\n"
                    f"üåç *Zona horaria:* Europe/Madrid\n\n"
                    f"{divider}\n\n"
                    f"‚ö†Ô∏è *IMPORTANTE:*\n"
                    f"   ‚Ä¢ Solo se aceptan peticiones en horario\n"
                    f"   ‚Ä¢ Fuera de horario se aplican sanciones\n"
                    f"   ‚Ä¢ Revisa los mensajes fijados de cada grupo"
                )
            else:
                mensaje += (
                    f"‚úÖ *El bot acepta solicitudes 24/7*\n\n"
                    f"No hay restricciones de horario configuradas.\n"
                    f"Puedes enviar tus solicitudes en cualquier momento."
                )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en user_menu_horario: {str(e)}")
            await query.answer("‚ùå Error al cargar horario", show_alert=True)
        return ConversationHandler.END

    # Bot√≥n: Canjear Recompensas (redirigir a user_view_rewards)
    if data == "user_menu_recompensas":
        # Cambiar el callback_data y procesar como user_view_rewards
        query.data = "user_view_rewards"
        data = "user_view_rewards"
        # Continuar el flujo para que se ejecute el handler de user_view_rewards m√°s abajo

    # Bot√≥n: Ayuda
    if data == "user_menu_ayuda":
        divider = "‚îÅ" * 32
        mensaje = (
            f"{divider}\n"
            f"‚ùì *AYUDA Y GU√çA DE USO* ‚ùì\n"
            f"{divider}\n\n"
            f"üìö *C√ìMO USAR EL BOT:*\n\n"
            f"1Ô∏è‚É£ *Hacer una solicitud:*\n"
            f"   ‚Ä¢ Escribe en el grupo: `/solicito [nombre]`\n"
            f"   ‚Ä¢ O usa el hashtag: `#peticion [nombre]`\n"
            f"   ‚Ä¢ L√≠mite: 2 solicitudes por d√≠a\n\n"
            f"2Ô∏è‚É£ *Ganar puntos:*\n"
            f"   ‚Ä¢ +50 pts por solicitud aprobada\n"
            f"   ‚Ä¢ +10 pts por completar encuestas\n"
            f"   ‚Ä¢ +5 pts por racha semanal\n\n"
            f"3Ô∏è‚É£ *Canjear recompensas:*\n"
            f"   ‚Ä¢ Ve a üí∞ Mis Puntos\n"
            f"   ‚Ä¢ Selecciona üéÅ Ver Recompensas\n"
            f"   ‚Ä¢ Canjea las que puedas pagar\n\n"
            f"{divider}\n\n"
            f"üìå *NORMAS IMPORTANTES:*\n"
            f"   ‚Ä¢ Lee los mensajes fijados\n"
            f"   ‚Ä¢ Respeta el horario del bot\n"
            f"   ‚Ä¢ No env√≠es duplicados\n"
            f"   ‚Ä¢ S√© respetuoso con el equipo\n\n"
            f"üí¨ *¬øProblemas?* Contacta a un admin"
        )

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=mensaje,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    # Bot√≥n: Contactar Admin
    if data == "user_menu_contactar_admin":
        divider = "‚îÅ" * 32
        mensaje = (
            f"{divider}\n"
            f"üë®‚Äçüíº *CONTACTAR CON ADMINISTRACI√ìN* üë®‚Äçüíº\n"
            f"{divider}\n\n"
            f"üì¨ *Para contactar directamente con un administrador:*\n\n"
            f"1Ô∏è‚É£ Escribe tu mensaje en el chat\n"
            f"2Ô∏è‚É£ El bot te pedir√° confirmaci√≥n\n"
            f"3Ô∏è‚É£ Tu mensaje ser√° enviado al equipo\n\n"
            f"{divider}\n\n"
            f"‚ö†Ô∏è *IMPORTANTE:*\n"
            f"   ‚Ä¢ S√© claro y respetuoso\n"
            f"   ‚Ä¢ Incluye detalles relevantes\n"
            f"   ‚Ä¢ Un admin responder√° pronto\n\n"
            f"üí¨ *Escribe tu mensaje ahora:*"
        )

        keyboard = [
            [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=mensaje,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        # Marcar que el usuario est√° esperando enviar un mensaje al admin
        user_menu_states[user_id] = {
            "state": "waiting_contact_admin",
            "chat_id": chat_id,
            "message_id": message_id
        }

        return ConversationHandler.END

    # Bot√≥n: Enviar Sugerencia
    if data == "user_menu_sugerencia":
        divider = "‚îÅ" * 32
        mensaje = (
            f"{divider}\n"
            f"üí° *ENVIAR SUGERENCIA* üí°\n"
            f"{divider}\n\n"
            f"üìù *¬øTienes alguna idea para mejorar el bot?*\n\n"
            f"Nos encantar√≠a escuchar tus sugerencias:\n"
            f"   ‚Ä¢ Nuevas funcionalidades\n"
            f"   ‚Ä¢ Mejoras en el sistema\n"
            f"   ‚Ä¢ Ideas para recompensas\n"
            f"   ‚Ä¢ Cambios en las normas\n\n"
            f"{divider}\n\n"
            f"‚úçÔ∏è *Escribe tu sugerencia ahora:*\n\n"
            f"üìå Procura ser claro y espec√≠fico"
        )

        keyboard = [
            [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=mensaje,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )

        # Marcar que el usuario est√° esperando enviar una sugerencia
        user_menu_states[user_id] = {
            "state": "waiting_suggestion",
            "chat_id": chat_id,
            "message_id": message_id
        }

        return ConversationHandler.END

    # Bot√≥n: Confirmar env√≠o de sugerencia
    if data.startswith("confirm_suggestion_"):
        try:
            suggestion_user_id = int(data.split("_")[2])

            if suggestion_user_id != user_id:
                await query.answer("‚ùå Esta sugerencia no es tuya", show_alert=True)
                return ConversationHandler.END

            if user_id not in pending_suggestions:
                await query.answer("‚ùå No hay sugerencia pendiente", show_alert=True)
                return ConversationHandler.END

            suggestion_data = pending_suggestions[user_id]
            suggestion_text = suggestion_data["text"]
            username = query.from_user.username or f"Usuario{user_id}"

            # Obtener informaci√≥n del usuario
            user_first_name = query.from_user.first_name or "Sin nombre"
            user_last_name = query.from_user.last_name or ""
            full_name = f"{user_first_name} {user_last_name}".strip()

            # Enviar sugerencia al admin
            ADMIN_ID = 7767930852
            admin_message = (
                f"‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
                f"‚ïë     üí° *NUEVA SUGERENCIA* üí°     ‚ïë\n"
                f"‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
                f"üìã *INFORMACI√ìN DEL USUARIO*\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"üë§ *Nombre:* {full_name}\n"
                f"üîó *Usuario:* @{username}\n"
                f"üÜî *ID:* `{user_id}`\n"
                f"üìç *Origen:* Chat Privado con el Bot\n"
                f"üìÖ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y a las %H:%M')}\n\n"
                f"üìù *SUGERENCIA RECIBIDA*\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"{suggestion_text}\n\n"
                f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                f"‚ö° *Estado:* Pendiente de revisi√≥n\n"
                f"üí° *Tip:* Eval√∫a la viabilidad e impacto de esta sugerencia"
            )

            await safe_bot_method(
                context.bot.send_message,
                chat_id=ADMIN_ID,
                text=admin_message,
                parse_mode="Markdown"
            )

            # Confirmar al usuario
            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"‚úÖ *¬°SUGERENCIA ENVIADA!* ‚úÖ\n"
                f"{divider}\n\n"
                f"üì¨ Tu sugerencia ha sido enviada al equipo de administraci√≥n.\n\n"
                f"üë®‚Äçüíº *El equipo la revisar√° y considerar√°.*\n\n"
                f"üíö ¬°Gracias por ayudarnos a mejorar!"
            )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Limpiar estados
            del pending_suggestions[user_id]
            if user_id in user_menu_states:
                del user_menu_states[user_id]

            logger.info(f"‚úÖ Sugerencia enviada por user_id={user_id} al admin")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al enviar sugerencia: {str(e)}")
            await query.answer("‚ùå Error al enviar sugerencia", show_alert=True)

        return ConversationHandler.END

    # Bot√≥n: Corregir sugerencia
    if data.startswith("edit_suggestion_"):
        try:
            suggestion_user_id = int(data.split("_")[2])

            if suggestion_user_id != user_id:
                await query.answer("‚ùå Esta sugerencia no es tuya", show_alert=True)
                return ConversationHandler.END

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üí° *CORREGIR SUGERENCIA* üí°\n"
                f"{divider}\n\n"
                f"‚úçÔ∏è *Escribe tu sugerencia nuevamente:*\n\n"
                f"üìå Procura ser claro y espec√≠fico"
            )

            keyboard = [
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Limpiar sugerencia anterior y volver a estado de espera
            if user_id in pending_suggestions:
                del pending_suggestions[user_id]

            user_menu_states[user_id] = {
                "state": "waiting_suggestion",
                "chat_id": chat_id,
                "message_id": message_id
            }

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al corregir sugerencia: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Bot√≥n: Confirmar env√≠o de mensaje al admin
    if data.startswith("confirm_contact_admin_"):
        try:
            contact_user_id = int(data.split("_")[3])

            if contact_user_id != user_id:
                await query.answer("‚ùå Este mensaje no es tuyo", show_alert=True)
                return ConversationHandler.END

            if user_id not in pending_suggestions:
                await query.answer("‚ùå No hay mensaje pendiente", show_alert=True)
                return ConversationHandler.END

            contact_data = pending_suggestions[user_id]
            contact_text = contact_data["text"]
            username = query.from_user.username or f"Usuario{user_id}"

            # Obtener informaci√≥n del usuario
            user_first_name = query.from_user.first_name or "Sin nombre"
            user_last_name = query.from_user.last_name or ""
            full_name = f"{user_first_name} {user_last_name}".strip()

            # Guardar en base de datos usando el nuevo sistema
            request_id = None
            if CONTACT_SYSTEM_AVAILABLE:
                try:
                    conn = get_db_connection()
                    request_id = create_contact_request(
                        conn, user_id, username, full_name, contact_text,
                        "Chat Privado con el Bot"
                    )
                    release_db_connection(conn)
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è Error guardando solicitud de contacto: {str(e)}")

            # Enviar mensaje al grupo de administraci√≥n con formato moderno
            if request_id and CONTACT_SYSTEM_AVAILABLE:
                admin_message_text, admin_keyboard = format_modern_contact_message(
                    user_id, username, full_name, contact_text, request_id
                )
            else:
                # Fallback al formato anterior si hay error
                admin_message_text = (
                    f"üí† *NUEVA SOLICITUD DE CONTACTO* üí†\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üì® *Mensaje entrante detectado*\n\n"
                    f"üë§ *Usuario:* [@{username}](https://t.me/{username})\n"
                    f"ü™™ *Nombre:* {full_name}\n"
                    f"üÜî *ID:* `{user_id}`\n"
                    f"üìÖ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y ‚Äì %H:%M')}\n\n"
                    f"üí¨ *Mensaje:*\n"
                    f"> {contact_text}\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                    f"üí° *Sugerencia:* Responde mencionando @{username}"
                )
                admin_keyboard = None

            sent_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=GROUP_DESTINO,
                text=admin_message_text,
                reply_markup=admin_keyboard,
                parse_mode="Markdown"
            )

            # Actualizar mensaje_grupo_id en la BD
            if request_id and sent_message and CONTACT_SYSTEM_AVAILABLE:
                try:
                    conn = get_db_connection()
                    with conn.cursor() as c:
                        c.execute("""
                            UPDATE contact_requests
                            SET mensaje_grupo_id = %s
                            WHERE id = %s
                        """, (sent_message.message_id, request_id))
                        conn.commit()
                    release_db_connection(conn)
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è Error actualizando mensaje_grupo_id: {str(e)}")

            # Confirmar al usuario
            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"‚úÖ *¬°MENSAJE ENVIADO!* ‚úÖ\n"
                f"{divider}\n\n"
                f"üì¨ Tu mensaje ha sido enviado al equipo de administraci√≥n.\n\n"
                f"üë®‚Äçüíº *Un administrador responder√° pronto.*\n\n"
                f"üíö ¬°Gracias por contactarnos!"
            )

            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Limpiar estados
            del pending_suggestions[user_id]
            if user_id in user_menu_states:
                del user_menu_states[user_id]

            logger.info(f"‚úÖ Mensaje enviado por user_id={user_id} al grupo de administraci√≥n")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al enviar mensaje al admin: {str(e)}")
            await query.answer("‚ùå Error al enviar mensaje", show_alert=True)

        return ConversationHandler.END

    # Bot√≥n: Corregir mensaje al admin
    if data.startswith("edit_contact_admin_"):
        try:
            contact_user_id = int(data.split("_")[3])

            if contact_user_id != user_id:
                await query.answer("‚ùå Este mensaje no es tuyo", show_alert=True)
                return ConversationHandler.END

            divider = "‚îÅ" * 32
            mensaje = (
                f"{divider}\n"
                f"üë®‚Äçüíº *CORREGIR MENSAJE* üë®‚Äçüíº\n"
                f"{divider}\n\n"
                f"‚úçÔ∏è *Escribe tu mensaje nuevamente:*\n\n"
                f"üìå S√© claro y respetuoso"
            )

            keyboard = [
                [InlineKeyboardButton("‚ùå Cancelar", callback_data="user_menu_inicio")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await safe_bot_method(
                query.edit_message_text,
                text=mensaje,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

            # Limpiar mensaje anterior y volver a estado de espera
            if user_id in pending_suggestions:
                del pending_suggestions[user_id]

            user_menu_states[user_id] = {
                "state": "waiting_contact_admin",
                "chat_id": chat_id,
                "message_id": message_id
            }

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al corregir mensaje: {str(e)}")
            await query.answer("‚ùå Error al procesar", show_alert=True)

        return ConversationHandler.END

    # Bot√≥n: Volver al Men√∫ Inicio (del /start)
    if data == "user_menu_inicio":
        username = escape_markdown(f"@{query.from_user.username}", True) if query.from_user.username else "Usuario"

        divider = "‚îÅ" * 32
        welcome_message = (
            f"{divider}\n"
            f"üëã *¬°BIENVENIDO A ENTRESHIJOS!* üëã\n"
            f"{divider}\n\n"
            f"Hola {username}, üìö\n\n"
            f"‚úÖ *Tus notificaciones est√°n activadas*\n\n"
            f"üì¨ *Recibir√°s avisos cuando:*\n"
            f"   ‚Ä¢ Tu solicitud sea aprobada\n"
            f"   ‚Ä¢ Sea subida por el equipo\n"
            f"   ‚Ä¢ Cambie el estado de tu petici√≥n\n\n"
            f"{divider}\n\n"
            f"üí° *¬øQu√© puedes hacer aqu√≠?*\n\n"
            f"üìã Ver y gestionar tus solicitudes\n"
            f"üí∞ Consultar tus puntos y nivel\n"
            f"üéÅ Canjear recompensas\n"
            f"‚ö†Ô∏è Revisar tus sanciones (si las hay)\n"
            f"üìä Ver el ranking de usuarios\n"
            f"üïê Consultar horarios del bot\n\n"
            f"{divider}\n\n"
            f"üìå *IMPORTANTE:*\n"
            f"‚Ä¢ Lee los mensajes fijados en cada grupo\n"
            f"‚Ä¢ Respeta las normas de peticiones\n"
            f"‚Ä¢ M√°ximo 2 solicitudes por d√≠a\n\n"
            f"ü§ù Solo recibir√°s informaci√≥n relacionada con tus solicitudes.\n\n"
            f"üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *Equipo EntresHijos*"
        )

        keyboard = [
            [InlineKeyboardButton("üìã Mis Solicitudes", callback_data="user_menu_solicitudes"),
             InlineKeyboardButton("üí∞ Mis Puntos", callback_data="user_menu_puntos")],
            [InlineKeyboardButton("üéÅ Canjear Recompensas", callback_data="user_view_rewards"),
             InlineKeyboardButton("‚ö†Ô∏è Mis Sanciones", callback_data="user_menu_sanciones")],
            [InlineKeyboardButton("üèÜ Ver Ranking", callback_data="user_menu_ranking"),
             InlineKeyboardButton("üïê Horario del Bot", callback_data="user_menu_horario")],
            [InlineKeyboardButton("üí° Enviar Sugerencia", callback_data="user_menu_sugerencia"),
             InlineKeyboardButton("üë®‚Äçüíº Contactar Admin", callback_data="user_menu_contactar_admin")],
            [InlineKeyboardButton("‚ùì Ayuda", callback_data="user_menu_ayuda")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=welcome_message,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    # ==================== FIN MEN√ö DE USUARIO ====================

    # Callbacks adicionales que faltaban
    if data.startswith("show_votes_"):
        ticket_number = int(data.split("_")[2])
        peticion = get_peticion_registrada(ticket_number)
        
        if not peticion:
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END
        
        votes = get_votes_summary(ticket_number)
        
        texto = (
            f"üó≥Ô∏è *Detalles de Votaci√≥n #{ticket_number}* üó≥Ô∏è\n\n"
            f"üë§ *Usuario:* {escape_markdown(peticion['username'], preserve_username=True)}\n"
            f"‚úâÔ∏è *Mensaje:* {escape_markdown(peticion['message_text'][:100] + '...' if len(peticion['message_text']) > 100 else peticion['message_text'])}\n"
            f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n\n"
            f"üìä **Resultados de Votaci√≥n:**\n"
            f"üëç *Votos positivos:* {votes['positive']}\n"
            f"üëé *Votos negativos:* {votes['negative']}\n"
            f"üìà *Total de votos:* {votes['total']}\n"
            f"‚öñÔ∏è *Balance:* {votes['positive'] - votes['negative']:+d}\n\n"
            f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Votaci√≥n", callback_data="menu_votacion"),
             InlineKeyboardButton("‚öôÔ∏è Gestionar", callback_data=f"pend_{ticket_number}_1_gestionar")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Estad√≠sticas detalladas de usuario espec√≠fico
    if data.startswith("user_detailed_stats_"):
        searched_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (searched_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Estad√≠sticas detalladas del usuario
                    c.execute("""
                        SELECT COUNT(*) as total_requests,
                               COUNT(CASE WHEN estado = 'subido' THEN 1 END) as approved,
                               COUNT(CASE WHEN estado = 'denegado' THEN 1 END) as denied,
                               COUNT(CASE WHEN estado = 'eliminado' THEN 1 END) as deleted,
                               COUNT(CASE WHEN estado = 'cancelado' THEN 1 END) as cancelled,
                               MIN(fecha_gestion) as first_request,
                               MAX(fecha_gestion) as last_request
                        FROM historial_solicitudes 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    history_stats = c.fetchone()
                    
                    # Estad√≠sticas de encuestas
                    c.execute("""
                        SELECT satisfaccion, COUNT(*) as count
                        FROM encuestas_satisfaccion 
                        WHERE user_id = %s
                        GROUP BY satisfaccion
                    """, (searched_user_id,))
                    survey_stats = c.fetchall()
                    
                    # Estad√≠sticas de infracciones
                    c.execute("""
                        SELECT COUNT(*) as incorrect_attempts
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    incorrect_stats = c.fetchone()
                    
                    c.execute("""
                        SELECT SUM(attempt_count) as total_abuse
                        FROM abuso_botones 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    abuse_stats = c.fetchone()
                    
                    # Solicitudes pendientes actuales
                    c.execute("""
                        SELECT COUNT(*) as pending_requests
                        FROM peticiones_registradas 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    pending_stats = c.fetchone()
            
            username = user_info['username'] or f"User {searched_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Calcular estad√≠sticas
            total_requests = history_stats['total_requests'] or 0
            approved = history_stats['approved'] or 0
            denied = history_stats['denied'] or 0
            deleted = history_stats['deleted'] or 0
            cancelled = history_stats['cancelled'] or 0
            pending = pending_stats['pending_requests'] or 0
            
            # Calcular tasas
            success_rate = (approved / total_requests * 100) if total_requests > 0 else 0
            completion_rate = ((approved + denied) / total_requests * 100) if total_requests > 0 else 0
            
            # Estad√≠sticas de encuestas
            survey_text = ""
            if survey_stats:
                survey_dict = {s['satisfaccion']: s['count'] for s in survey_stats}
                total_surveys = sum(survey_dict.values())
                survey_text = f"\nüìä **Encuestas de Satisfacci√≥n:**\n"
                for satisfaccion in ['excelente', 'bueno', 'regular', 'malo']:
                    count = survey_dict.get(satisfaccion, 0)
                    if count > 0:
                        percentage = (count / total_surveys * 100)
                        emoji = {'excelente': '‚≠ê', 'bueno': 'üëç', 'regular': 'üëå', 'malo': 'üëé'}[satisfaccion]
                        survey_text += f"‚Ä¢ {emoji} {satisfaccion.capitalize()}: {count} ({percentage:.1f}%)\n"
            
            # Estad√≠sticas de infracciones
            infractions_text = ""
            incorrect_count = incorrect_stats['incorrect_attempts'] or 0
            abuse_count = abuse_stats['total_abuse'] or 0
            
            if incorrect_count > 0 or abuse_count > 0:
                infractions_text = f"\n‚ö†Ô∏è **Infracciones:**\n"
                if incorrect_count > 0:
                    infractions_text += f"‚Ä¢ Peticiones incorrectas: {incorrect_count}\n"
                if abuse_count > 0:
                    infractions_text += f"‚Ä¢ Abusos de botones: {abuse_count}\n"
            
            # Fechas
            first_request = history_stats['first_request'].strftime('%d/%m/%Y') if history_stats['first_request'] else "N/A"
            last_request = history_stats['last_request'].strftime('%d/%m/%Y') if history_stats['last_request'] else "N/A"
            
            texto = (
                f"üìà *Estad√≠sticas Detalladas de Usuario* üìà\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {searched_user_id}\n\n"
                f"üìä **Resumen de Actividad:**\n"
                f"‚Ä¢ Total de solicitudes: {total_requests}\n"
                f"‚Ä¢ Solicitudes pendientes: {pending}\n"
                f"‚Ä¢ Tasa de √©xito: {success_rate:.1f}%\n"
                f"‚Ä¢ Tasa de finalizaci√≥n: {completion_rate:.1f}%\n\n"
                f"üìã **Distribuci√≥n por Estado:**\n"
                f"‚Ä¢ ‚úÖ Aprobadas: {approved}\n"
                f"‚Ä¢ ‚ùå Denegadas: {denied}\n"
                f"‚Ä¢ üóëÔ∏è Eliminadas: {deleted}\n"
                f"‚Ä¢ üîÑ Canceladas: {cancelled}\n\n"
                f"üìÖ **Per√≠odo de Actividad:**\n"
                f"‚Ä¢ Primera solicitud: {first_request}\n"
                f"‚Ä¢ √öltima solicitud: {last_request}{survey_text}{infractions_text}\n\n"
                f"‚è∞ *Generado:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas detalladas del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"üìà *Error en Estad√≠sticas Detalladas* üìà\n\n"
                f"‚ùå Error al cargar estad√≠sticas: {str(e)}\n"
                f"‚è∞ *Intento:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Detalles de usuario desde b√∫squeda
    if data.startswith("user_details_"):
        searched_user_id = int(data.split("_")[2])
        
        search_key = f"{user_id}_{chat_id}"
        menu_message_id = message_id
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("""
                        SELECT user_id, COALESCE(username, '') as username FROM usuarios WHERE user_id = %s
                    """, (searched_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener solicitudes pendientes del usuario
                    c.execute("""
                        SELECT ticket_number, message_text, chat_title, timestamp, has_attachment
                        FROM peticiones_registradas 
                        WHERE user_id = %s 
                        ORDER BY timestamp DESC
                    """, (searched_user_id,))
                    pending_requests = c.fetchall()
                    
                    # Obtener historial del usuario (√∫ltimas 5)
                    c.execute("""
                        SELECT ticket_number, message_text, chat_title, estado, fecha_gestion, url, reason
                        FROM historial_solicitudes 
                        WHERE user_id = %s 
                        ORDER BY fecha_gestion DESC 
                        LIMIT 5
                    """, (searched_user_id,))
                    history_requests = c.fetchall()
                    
                    # Obtener estad√≠sticas del usuario
                    c.execute("""
                        SELECT count, last_reset FROM peticiones_por_usuario WHERE user_id = %s
                    """, (searched_user_id,))
                    user_stats = c.fetchone()
            
            username = user_info['username'] or f"User {searched_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Estad√≠sticas del usuario
            current_requests = user_stats['count'] if user_stats else 0
            last_reset = user_stats['last_reset'].strftime('%d/%m/%Y') if user_stats and user_stats['last_reset'] else "No registrado"
            
            # Calcular estad√≠sticas adicionales
            total_requests = len(pending_requests) + len(history_requests)
            success_rate = 0
            if history_requests:
                successful = sum(1 for req in history_requests if req['estado'].lower() == 'subido')
                success_rate = (successful / len(history_requests)) * 100
            
            texto = (
                f"üë§ *Perfil de Usuario* üë§\n\n"
                f"üÜî **ID:** {searched_user_id}\n"
                f"üë§ **Username:** {username_escaped}\n"
                f"üìä **Solicitudes hoy:** {current_requests}/2\n"
                f"üìÖ **√öltimo reinicio:** {last_reset}\n"
                f"üìà **Tasa de √©xito:** {success_rate:.1f}%\n\n"
                f"üìä **Resumen de Actividad:**\n"
                f"üìã **Solicitudes Pendientes:** {len(pending_requests)}\n"
                f"üìú **Total en Historial:** {len(history_requests)}\n"
                f"üéØ **Total de Solicitudes:** {total_requests}\n\n"
                f"‚è∞ *Consulta:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = []
            
            # Botones para solicitudes pendientes
            if pending_requests:
                keyboard.append([
                    InlineKeyboardButton(f"üìã Pendientes ({len(pending_requests)})", callback_data=f"user_pending_{searched_user_id}")
                ])
            
            # Botones para historial
            if history_requests:
                keyboard.append([
                    InlineKeyboardButton(f"üìú Historial ({len(history_requests)})", callback_data=f"user_history_{searched_user_id}")
                ])
            
            # Botones de gesti√≥n de usuario
            keyboard.append([
                InlineKeyboardButton("‚ûñ Reducir Solicitudes", callback_data=f"user_reduce_{searched_user_id}"),
                InlineKeyboardButton("üîÑ Resetear Contador", callback_data=f"user_reset_{searched_user_id}")
            ])
            
            # Bot√≥n de estad√≠sticas detalladas si tiene actividad
            if total_requests > 0:
                keyboard.append([
                    InlineKeyboardButton("üìà Estad√≠sticas Detalladas", callback_data=f"user_detailed_stats_{searched_user_id}")
                ])
            
            # Navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas")
            ])
            keyboard.append([
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo detalles del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"üë§ *Error en Perfil de Usuario* üë§\n\n"
                f"‚ùå Error al cargar informaci√≥n del usuario: {str(e)}\n"
                f"üîß Por favor, intenta de nuevo m√°s tarde.\n\n"
                f"‚è∞ *Intento:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=menu_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, menu_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        if search_key in pending_searches:
            del pending_searches[search_key]
        
        logger.info(f"‚úÖ Detalles de usuario {searched_user_id} mostrados por admin {user_id}")
        return ConversationHandler.END

    # Ver solicitudes pendientes de un usuario espec√≠fico
    if data.startswith("user_pending_"):
        searched_user_id = int(data.split("_")[2])
        page = int(data.split("_")[3]) if len(data.split("_")) > 3 else 1
        ITEMS_PER_PAGE = 5
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener total de solicitudes pendientes
                    c.execute("""
                        SELECT COUNT(*)
                        FROM usuarios u
                        JOIN peticiones_registradas pr ON u.user_id = pr.user_id
                        WHERE u.user_id = %s
                    """, (searched_user_id,))
                    total_pending = c.fetchone()[0]
                    
                    # Obtener solicitudes para la p√°gina actual
                    offset = (page - 1) * ITEMS_PER_PAGE
                    c.execute("""
                        SELECT u.username, pr.ticket_number, pr.message_text, pr.chat_title, 
                               pr.timestamp, pr.has_attachment
                        FROM usuarios u
                        JOIN peticiones_registradas pr ON u.user_id = pr.user_id
                        WHERE u.user_id = %s 
                        ORDER BY pr.timestamp DESC
                        LIMIT %s OFFSET %s
                    """, (searched_user_id, ITEMS_PER_PAGE, offset))
                    pending_requests = c.fetchall()
            
            total_pages = (total_pending + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE if total_pending > 0 else 1
            
            if not pending_requests:
                texto = (
                    f"üìã *Solicitudes Pendientes (P√°gina {page})* üìã\n\n"
                    f"üë§ **Usuario ID:** {searched_user_id}\n"
                    f"üìä **Estado:** Sin solicitudes pendientes\n\n"
                    f"‚ÑπÔ∏è Este usuario no tiene solicitudes pendientes actualmente."
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                    [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                username = pending_requests[0]['username'] or f"User {searched_user_id}"
                username_display = f"@{username}" if not username.startswith("@") else username
                username_escaped = escape_markdown(username_display, preserve_username=True)
                
                texto = (
                    f"üìã *Solicitudes Pendientes (P√°gina {page}/{total_pages})* üìã\n\n"
                    f"üë§ **Usuario:** {username_escaped}\n"
                    f"üÜî **ID:** {searched_user_id}\n"
                    f"üìä **Total pendientes:** {total_pending}\n"
                    f"üìÑ **Mostrando:** {len(pending_requests)} de {total_pending}\n\n"
                    f"Selecciona una solicitud para gestionarla:"
                )
                
                keyboard = []
                
                for req in pending_requests:
                    ticket_number = req['ticket_number']
                    message_preview = req['message_text'][:40] + "..." if len(req['message_text']) > 40 else req['message_text']
                    timestamp_str = req['timestamp'].strftime('%d/%m %H:%M')
                    attachment_icon = "üìé" if req['has_attachment'] else ""
                    chat_short = req['chat_title'][:15] + "..." if len(req['chat_title']) > 15 else req['chat_title']
                    
                    # Bot√≥n compacto para cada solicitud pendiente
                    keyboard.append([
                        InlineKeyboardButton(
                            f"‚öôÔ∏è #{ticket_number} - {escape_markdown(chat_short)} ({timestamp_str}) {attachment_icon}",
                            callback_data=f"user_manage_{ticket_number}_{searched_user_id}"
                        )
                    ])
                
                # Botones de navegaci√≥n por p√°ginas
                if total_pages > 1:
                    nav_buttons = []
                    if page > 1:
                        nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"user_pending_{searched_user_id}_{page-1}"))
                    if page < total_pages:
                        nav_buttons.append(InlineKeyboardButton("Siguiente ‚û°Ô∏è", callback_data=f"user_pending_{searched_user_id}_{page+1}"))
                    
                    if nav_buttons:
                        keyboard.append(nav_buttons)
                    
                    # Indicador de p√°gina
                    keyboard.append([InlineKeyboardButton(f"üìÑ P√°gina {page} de {total_pages}", callback_data="no_action")])
                
                # Navegaci√≥n
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}"),
                    InlineKeyboardButton("üìú Ver Historial", callback_data=f"user_history_{searched_user_id}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo solicitudes pendientes del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"üìã *Error en Solicitudes Pendientes* üìã\n\n"
                f"‚ùå Error al cargar solicitudes: {str(e)}\n"
                f"‚è∞ *Intento:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver historial de un usuario espec√≠fico
    if data.startswith("user_history_"):
        searched_user_id = int(data.split("_")[2])
        page = int(data.split("_")[3]) if len(data.split("_")) > 3 else 1
        ITEMS_PER_PAGE = 5
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener total de solicitudes en historial
                    c.execute("""
                        SELECT COUNT(*)
                        FROM usuarios u
                        JOIN historial_solicitudes hs ON u.user_id = hs.user_id
                        WHERE u.user_id = %s
                    """, (searched_user_id,))
                    total_history = c.fetchone()[0]
                    
                    # Obtener solicitudes para la p√°gina actual
                    offset = (page - 1) * ITEMS_PER_PAGE
                    c.execute("""
                        SELECT u.username, hs.ticket_number, hs.message_text, hs.chat_title, 
                               hs.estado, hs.fecha_gestion, hs.url, hs.reason, hs.has_attachment
                        FROM usuarios u
                        JOIN historial_solicitudes hs ON u.user_id = hs.user_id
                        WHERE u.user_id = %s 
                        ORDER BY hs.fecha_gestion DESC
                        LIMIT %s OFFSET %s
                    """, (searched_user_id, ITEMS_PER_PAGE, offset))
                    history_requests = c.fetchall()
            
            total_pages = (total_history + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE if total_history > 0 else 1
            
            if not history_requests:
                texto = (
                    f"üìú *Historial de Usuario (P√°gina {page})* üìú\n\n"
                    f"üë§ **Usuario ID:** {searched_user_id}\n"
                    f"üìä **Estado:** Sin historial\n\n"
                    f"‚ÑπÔ∏è Este usuario no tiene solicitudes en el historial."
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                    [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                username = history_requests[0]['username'] or f"User {searched_user_id}"
                username_display = f"@{username}" if not username.startswith("@") else username
                username_escaped = escape_markdown(username_display, preserve_username=True)
                
                texto = (
                    f"üìú *Historial de Usuario (P√°gina {page}/{total_pages})* üìú\n\n"
                    f"üë§ **Usuario:** {username_escaped}\n"
                    f"üÜî **ID:** {searched_user_id}\n"
                    f"üìä **Total en historial:** {total_history}\n"
                    f"üìÑ **Mostrando:** {len(history_requests)} de {total_history}\n\n"
                    f"Selecciona una solicitud para ver detalles:"
                )
                
                keyboard = []
                
                for req in history_requests:
                    ticket_number = req['ticket_number']
                    message_preview = req['message_text'][:30] + "..." if len(req['message_text']) > 30 else req['message_text']
                    estado = req['estado'].capitalize()
                    fecha_str = req['fecha_gestion'].strftime('%d/%m %H:%M')
                    attachment_icon = "üìé" if req['has_attachment'] else ""
                    chat_short = req['chat_title'][:15] + "..." if len(req['chat_title']) > 15 else req['chat_title']
                    
                    # Emoji seg√∫n estado
                    estado_emoji = {
                        'Subido': '‚úÖ',
                        'Denegado': '‚ùå', 
                        'Eliminado': 'üóëÔ∏è',
                        'Cancelado': 'üîÑ',
                        'Restaurado': 'üîÑ',
                        'Eliminada_automaticamente': 'üßπ'
                    }.get(estado, 'üìã')
                    
                    # Bot√≥n compacto para cada solicitud del historial
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{estado_emoji} #{ticket_number} - {escape_markdown(chat_short)} ({fecha_str}) {attachment_icon}",
                            callback_data=f"user_history_detail_{ticket_number}_{searched_user_id}"
                        )
                    ])
                
                # Botones de navegaci√≥n por p√°ginas
                if total_pages > 1:
                    nav_buttons = []
                    if page > 1:
                        nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è Anterior", callback_data=f"user_history_{searched_user_id}_{page-1}"))
                    if page < total_pages:
                        nav_buttons.append(InlineKeyboardButton("Siguiente ‚û°Ô∏è", callback_data=f"user_history_{searched_user_id}_{page+1}"))
                    
                    if nav_buttons:
                        keyboard.append(nav_buttons)
                    
                    # Indicador de p√°gina
                    keyboard.append([InlineKeyboardButton(f"üìÑ P√°gina {page} de {total_pages}", callback_data="no_action")])
                
                # Navegaci√≥n
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}"),
                    InlineKeyboardButton("üìã Ver Pendientes", callback_data=f"user_pending_{searched_user_id}")
                ])
                keyboard.append([
                    InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo historial del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"üìú *Error en Historial* üìú\n\n"
                f"‚ùå Error al cargar historial: {str(e)}\n"
                f"‚è∞ *Intento:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
                [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Gestionar solicitud espec√≠fica desde b√∫squeda de usuario
    if data.startswith("user_manage_"):
        parts = data.split("_")
        ticket_number = int(parts[2])
        searched_user_id = int(parts[3])
        
        peticion = get_peticion_registrada(ticket_number)
        
        if not peticion:
            await query.answer("‚ùå Solicitud no encontrada o ya procesada", show_alert=True)
            return ConversationHandler.END
        
        votes = get_votes_summary(ticket_number)
        vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else ""
        
        username_escaped = escape_markdown(peticion['username'], preserve_username=True)
        message_text_escaped = escape_markdown(peticion['message_text'])
        chat_title_escaped = escape_markdown(peticion['chat_title'])
        timestamp_str = peticion['timestamp'].strftime('%d/%m/%Y %H:%M:%S')
        
        texto = (
            f"‚öôÔ∏è *Gestionar Solicitud #{ticket_number}* ‚öôÔ∏è\n\n"
            f"üë§ **Usuario:** {username_escaped}\n"
            f"üÜî **ID:** {searched_user_id}\n"
            f"‚úâÔ∏è **Mensaje:** {message_text_escaped}\n"
            f"üìç **Grupo:** {chat_title_escaped}\n"
            f"‚è∞ **Fecha:** {timestamp_str}\n"
            f"üìé **Adjunto:** {'S√≠' if peticion['has_attachment'] else 'No'}{vote_text}\n\n"
            f"üéØ **Acciones Disponibles:**\n"
            f"Selecciona c√≥mo procesar esta solicitud pendiente:"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ Aprobar", callback_data=f"user_action_approve_{ticket_number}_{searched_user_id}"),
             InlineKeyboardButton("üîó Aprobar con Enlace", callback_data=f"user_action_link_{ticket_number}_{searched_user_id}")],
            [InlineKeyboardButton("‚ùå Denegar", callback_data=f"user_action_deny_{ticket_number}_{searched_user_id}"),
             InlineKeyboardButton("üóëÔ∏è Eliminar", callback_data=f"user_action_delete_{ticket_number}_{searched_user_id}")],
            [InlineKeyboardButton("üó≥Ô∏è Ver Votos", callback_data=f"show_votes_{ticket_number}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Pendientes", callback_data=f"user_pending_{searched_user_id}"),
             InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver detalles de solicitud del historial desde b√∫squeda de usuario
    if data.startswith("user_history_detail_"):
        parts = data.split("_")
        ticket_number = int(parts[3])
        searched_user_id = int(parts[4])
        
        historial = get_historial_solicitud(ticket_number)
        
        if not historial:
            await query.answer("‚ùå Solicitud no encontrada en el historial", show_alert=True)
            return ConversationHandler.END
        
        username_escaped = escape_markdown(historial["username"], preserve_username=True)
        message_text_escaped = escape_markdown(historial["message_text"])
        chat_title_escaped = escape_markdown(historial["chat_title"])
        estado = historial["estado"].capitalize()
        fecha_gestion = historial["fecha_gestion"].strftime("%d/%m/%Y %H:%M:%S")
        url = historial["url"] or "No proporcionado"
        reason = historial["reason"] or "No especificado"
        
        # Emoji seg√∫n estado
        estado_emoji = {
            'Subido': '‚úÖ',
            'Denegado': '‚ùå', 
            'Eliminado': 'üóëÔ∏è',
            'Cancelado': 'üîÑ',
            'Restaurado': 'üîÑ',
            'Eliminada_automaticamente': 'üßπ'
        }.get(estado, 'üìã')
        
        texto = (
            f"üìã *Detalle de Solicitud #{ticket_number}* üìã\n\n"
            f"üë§ **Usuario:** {username_escaped}\n"
            f"üÜî **ID:** {searched_user_id}\n"
            f"‚úâÔ∏è **Mensaje:** {message_text_escaped}\n"
            f"üìç **Grupo:** {chat_title_escaped}\n"
            f"üìé **Adjunto:** {'S√≠' if historial['has_attachment'] else 'No'}\n"
            f"üìä **Estado:** {estado_emoji} {estado}\n"
            f"‚è∞ **Fecha de Gesti√≥n:** {fecha_gestion}\n"
            f"üîó **Enlace:** {escape_markdown(url)}\n"
            f"üìù **Motivo/Raz√≥n:** {escape_markdown(reason)}\n\n"
            f"üéØ **Acciones Disponibles:**"
        )
        
        keyboard = []
        
        # Opciones seg√∫n el estado
        if estado.lower() in ['denegado', 'eliminado', 'cancelado', 'eliminada_automaticamente']:
            keyboard.append([
                InlineKeyboardButton("üîÑ Restaurar a Pendientes", callback_data=f"user_restore_{ticket_number}_{searched_user_id}")
            ])
        elif estado.lower() == 'subido':
            keyboard.append([
                InlineKeyboardButton("üìä Ver Estad√≠sticas", callback_data=f"user_stats_{searched_user_id}"),
                InlineKeyboardButton("üòä Ver Encuestas", callback_data=f"user_surveys_{searched_user_id}")
            ])
        
        # Navegaci√≥n
        keyboard.append([
            InlineKeyboardButton("‚Ü©Ô∏è Volver al Historial", callback_data=f"user_history_{searched_user_id}"),
            InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")
        ])
        keyboard.append([
            InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
            InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
        ])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Acciones de gesti√≥n desde b√∫squeda de usuario
    if data.startswith("user_action_"):
        parts = data.split("_")
        action = parts[2]  # approve, link, deny, delete
        ticket_number = int(parts[3])
        searched_user_id = int(parts[4])
        
        peticion = get_peticion_registrada(ticket_number)
        if not peticion:
            await query.answer("‚ùå Solicitud no encontrada", show_alert=True)
            return ConversationHandler.END
        
        if action == "approve":
            # Aprobar sin enlace
            await set_historial_solicitud(ticket_number, {
                "chat_id": peticion["chat_id"],
                "username": peticion["username"],
                "user_id": peticion["user_id"],
                "message_text": peticion["message_text"],
                "chat_title": peticion["chat_title"],
                "estado": "subido",
                "fecha_gestion": datetime.now(SPAIN_TZ),
                "admin_username": "Equipo de Administraci√≥n",
                "url": "Aprobado sin enlace",
                "has_attachment": peticion["has_attachment"],
                "photo_file_id": peticion["photo_file_id"]
            })
            
            del_peticion_registrada(ticket_number)
            
            # Enviar notificaci√≥n al usuario
            canal_info = CANALES_PETICIONES.get(peticion["chat_id"], {"chat_id": peticion["chat_id"], "thread_id": None})
            username_escaped = escape_markdown(peticion["username"], preserve_username=True)
            message_text_escaped = escape_markdown(peticion["message_text"])
            
            notification_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=canal_info["chat_id"],
                text=(
                    f"‚úÖ *Solicitud Aprobada* ‚úÖ\n"
                    f"Hola {username_escaped}, tu solicitud _(Ticket #{ticket_number})_ ha sido aprobada por el *Equipo de Administraci√≥n*.\n"
                    f"üìå *Detalles:*\n"
                    f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                    f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n"
                    f"‚è∞ *Fecha:* {get_spain_time()}\n"
                    f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
                    f"üòä Por favor, califica tu experiencia con la encuesta."
                ),
                message_thread_id=canal_info["thread_id"],
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üòä Encuesta de Satisfacci√≥n", callback_data=f"encuesta_{ticket_number}")]
                ]),
                parse_mode="Markdown"
            )

            # Registrar encuesta pendiente para recordatorio
            save_pending_survey(ticket_number, peticion["user_id"], peticion["username"], peticion["chat_id"], peticion["message_text"], peticion["chat_title"])

            # Eliminar mensajes originales
            if peticion.get("message_id"):
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=GROUP_DESTINO,
                    message_id=peticion["message_id"]
                )
            
            photo_message_id = context.bot_data.get(f"photo_{ticket_number}")
            if photo_message_id:
                await safe_bot_method(
                    context.bot.delete_message,
                    chat_id=GROUP_DESTINO,
                    message_id=photo_message_id
                )
                del context.bot_data[f"photo_{ticket_number}"]
            
            await delete_confirmation_message(context, ticket_number)
            
            texto = (
                f"‚úÖ *Solicitud #{ticket_number} Aprobada* ‚úÖ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üìä **Estado:** Aprobada sin enlace\n"
                f"üì¢ **Notificaci√≥n:** Usuario informado\n"
                f"‚è∞ **Procesado:** {get_spain_time()}\n\n"
                f"La solicitud ha sido aprobada exitosamente."
            )
            
        elif action == "link":
            # Solicitar enlace para aprobar
            set_admin_waiting_response(user_id, chat_id, "link", ticket_number, {
                "peticion": peticion,
                "searched_user_id": searched_user_id,
                "menu_message_id": message_id,
                "return_to": "user_search"
            })
            
            instruction_msg = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=(
                    f"üîó *Aprobar Solicitud #{ticket_number} con Enlace* üîó\n\n"
                    f"üë§ *Usuario:* {escape_markdown(peticion['username'], preserve_username=True)}\n"
                    f"‚úâÔ∏è *Mensaje:* {escape_markdown(peticion['message_text'])}\n"
                    f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n\n"
                    f"üìù *Por favor, escribe el enlace de Telegram para esta solicitud:*"
                ),
                parse_mode="Markdown"
            )
            
            if instruction_msg:
                admin_waiting_responses[f"{user_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
            
            logger.info(f"‚úÖ Solicitado enlace para ticket #{ticket_number} desde b√∫squeda de usuario")
            return ConversationHandler.END
            
        elif action == "deny":
            # Solicitar motivo para denegar
            set_admin_waiting_response(user_id, chat_id, "reason", ticket_number, {
                "peticion": peticion,
                "searched_user_id": searched_user_id,
                "menu_message_id": message_id,
                "return_to": "user_search"
            })
            
            instruction_msg = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=(
                    f"‚ùå *Denegar Solicitud #{ticket_number}* ‚ùå\n\n"
                    f"üë§ *Usuario:* {escape_markdown(peticion['username'], preserve_username=True)}\n"
                    f"‚úâÔ∏è *Mensaje:* {escape_markdown(peticion['message_text'])}\n"
                    f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n\n"
                    f"üìù *Por favor, escribe el motivo de la denegaci√≥n:*"
                ),
                parse_mode="Markdown"
            )
            
            if instruction_msg:
                admin_waiting_responses[f"{user_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
            
            logger.info(f"‚úÖ Solicitado motivo para denegar ticket #{ticket_number} desde b√∫squeda de usuario")
            return ConversationHandler.END
            
        elif action == "delete":
            # Solicitar motivo para eliminar
            set_admin_waiting_response(user_id, chat_id, "deletion_reason", ticket_number, {
                "peticion": peticion,
                "searched_user_id": searched_user_id,
                "menu_message_id": message_id,
                "return_to": "user_search"
            })
            
            instruction_msg = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=(
                    f"üóëÔ∏è *Eliminar Solicitud #{ticket_number}* üóëÔ∏è\n\n"
                    f"üë§ *Usuario:* {escape_markdown(peticion['username'], preserve_username=True)}\n"
                    f"‚úâÔ∏è *Mensaje:* {escape_markdown(peticion['message_text'])}\n"
                    f"üìç *Grupo:* {escape_markdown(peticion['chat_title'])}\n\n"
                    f"üìù *Por favor, escribe el motivo de la eliminaci√≥n:*\n"
                    f"(Ejemplo: Contenido inapropiado, Duplicado, etc.)"
                ),
                parse_mode="Markdown"
            )
            
            if instruction_msg:
                admin_waiting_responses[f"{user_id}_{chat_id}"]["question_message_id"] = instruction_msg.message_id
            
            logger.info(f"‚úÖ Solicitado motivo para eliminar ticket #{ticket_number} desde b√∫squeda de usuario")
            return ConversationHandler.END
        
        # Si llegamos aqu√≠, mostrar resultado de la acci√≥n
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Pendientes", callback_data=f"user_pending_{searched_user_id}"),
             InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Restaurar solicitud desde b√∫squeda de usuario
    if data.startswith("user_restore_"):
        parts = data.split("_")
        ticket_number = int(parts[2])
        searched_user_id = int(parts[3])
        
        admin_username = f"@{query.from_user.username}" if query.from_user.username else "Admin"
        success = await restore_request_from_history(ticket_number, admin_username)
        
        if success:
            texto = (
                f"‚úÖ *Solicitud #{ticket_number} Restaurada* ‚úÖ\n\n"
                f"üë§ **Usuario ID:** {searched_user_id}\n"
                f"üîÑ **Restaurado por:** {escape_markdown(admin_username, preserve_username=True)}\n"
                f"‚è∞ **Fecha:** {get_spain_time()}\n\n"
                f"üìã La solicitud ahora est√° disponible en *Solicitudes Pendientes*\n"
                f"üì¢ El usuario ha sido notificado de la restauraci√≥n"
            )
        else:
            texto = (
                f"‚ùå *Error al Restaurar #{ticket_number}* ‚ùå\n\n"
                f"‚ö†Ô∏è No se pudo restaurar la solicitud\n"
                f"üîß Verifica que la solicitud existe en el historial\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üìú Ver Historial", callback_data=f"user_history_{searched_user_id}"),
             InlineKeyboardButton("üë§ Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Solicitud #{ticket_number} {'restaurada' if success else 'fall√≥ al restaurar'} desde b√∫squeda de usuario")
        return ConversationHandler.END

    # Reducir solicitudes de usuario desde b√∫squeda
    if data.startswith("user_reduce_"):
        searched_user_id = int(data.split("_")[2])
        
        try:
            user_data = get_peticiones_por_usuario(searched_user_id)
            if not user_data or user_data["count"] <= 0:
                await query.answer("‚ö†Ô∏è El usuario no tiene solicitudes para reducir", show_alert=True)
                return ConversationHandler.END
            
            new_count = max(0, user_data["count"] - 1)
            set_peticiones_por_usuario(searched_user_id, new_count, user_data["chat_id"], user_data["username"], user_data["last_reset"])
            
            username = user_data["username"] or f"User {searched_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"‚ûñ *Solicitudes Reducidas* ‚ûñ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {searched_user_id}\n"
                f"üìä **Solicitudes anteriores:** {user_data['count']}/2\n"
                f"üìä **Solicitudes actuales:** {new_count}/2\n"
                f"‚è∞ **Reducido:** {get_spain_time()}\n\n"
                f"‚úÖ Operaci√≥n completada exitosamente"
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reduciendo solicitudes del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"‚ûñ *Error al Reducir Solicitudes* ‚ûñ\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"‚è∞ *Intento:* {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Resetear contador de usuario desde b√∫squeda
    if data.startswith("user_reset_"):
        searched_user_id = int(data.split("_")[2])
        
        try:
            user_data = get_peticiones_por_usuario(searched_user_id)
            if not user_data:
                await query.answer("‚ö†Ô∏è Usuario no encontrado en el sistema", show_alert=True)
                return ConversationHandler.END
            
            set_peticiones_por_usuario(searched_user_id, 0, user_data["chat_id"], user_data["username"], datetime.now(SPAIN_TZ))
            
            username = user_data["username"] or f"User {searched_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üîÑ *Contador Reseteado* üîÑ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {searched_user_id}\n"
                f"üìä **Solicitudes anteriores:** {user_data['count']}/2\n"
                f"üìä **Solicitudes actuales:** 0/2\n"
                f"‚è∞ **Reseteado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede hacer 2 nuevas solicitudes"
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reseteando contador del usuario {searched_user_id}: {str(e)}")
            texto = (
                f"üîÑ *Error al Resetear Contador* üîÑ\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"‚è∞ *Intento:* {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Callbacks de reinicio de servicios
    if data == "restart_db":
        try:
            # Verificar y limpiar conexiones DB
            test_result = test_db_connection()
            clear_expired_cache()
            
            if test_result:
                texto = (
                    f"üîÑ *Conexi√≥n DB Reiniciada* üîÑ\n\n"
                    f"‚úÖ Conexi√≥n a la base de datos reiniciada exitosamente\n"
                    f"üóëÔ∏è Cach√© expirado limpiado\n"
                    f"üìä Estado: Operativa\n"
                    f"‚è∞ Reiniciado: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
            else:
                texto = (
                    f"üîÑ *Error al Reiniciar DB* üîÑ\n\n"
                    f"‚ùå No se pudo reiniciar la conexi√≥n\n"
                    f"üìä Estado: Con problemas\n"
                    f"‚è∞ Intento: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
        except Exception as e:
            texto = (
                f"üîÑ *Error al Reiniciar DB* üîÑ\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"‚è∞ Intento: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="restart_services"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "clear_all_cache":
        result = clear_all_cache()
        texto = (
            f"üóëÔ∏è *Cach√© Completamente Limpiado* üóëÔ∏è\n\n"
            f"‚úÖ {result}\n"
            f"üíæ Memoria liberada\n"
            f"‚è∞ Completado: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="restart_services"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "restart_webhook":
        try:
            await setup_webhook()
            texto = (
                f"üì± *Webhook Reiniciado* üì±\n\n"
                f"‚úÖ Webhook reiniciado exitosamente\n"
                f"üîó URL: {WEBHOOK_URL[:50]}...\n"
                f"‚è∞ Reiniciado: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        except Exception as e:
            texto = (
                f"üì± *Error al Reiniciar Webhook* üì±\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"‚è∞ Intento: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="restart_services"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reorganizar base de datos
    if data == "reorganize_db":
        try:
            # Ejecutar solo limpieza b√°sica para evitar timeouts
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Limpiar datos antiguos sin reorganizar tickets
                    cutoff_date = datetime.now(SPAIN_TZ) - timedelta(days=90)
                    
                    c.execute("DELETE FROM historial_solicitudes WHERE fecha_gestion < %s", (cutoff_date,))
                    deleted_history = c.rowcount
                    
                    c.execute("DELETE FROM cache WHERE expires_at <= %s", (datetime.now(SPAIN_TZ),))
                    deleted_cache = c.rowcount
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE timestamp < %s", (cutoff_date,))
                    deleted_incorrect = c.rowcount
                    
                    c.execute("DELETE FROM abuso_botones WHERE last_attempt < %s", (cutoff_date,))
                    deleted_abuse = c.rowcount
                    
                    c.execute("DELETE FROM system_logs WHERE timestamp < %s", (cutoff_date,))
                    deleted_logs = c.rowcount
                    
                    # Actualizar estad√≠sticas de tablas
                    c.execute("ANALYZE peticiones_registradas")
                    c.execute("ANALYZE historial_solicitudes")
                    c.execute("ANALYZE usuarios")
                    
                    conn.commit()
            
            texto = (
                f"üîÑ *Optimizaci√≥n de Base de Datos Completada* üîÑ\n\n"
                f"‚úÖ Base de datos optimizada exitosamente\n"
                f"üóëÔ∏è *Historial limpiado:* {deleted_history} registros\n"
                f"üóëÔ∏è *Cach√© limpiado:* {deleted_cache} entradas\n"
                f"üóëÔ∏è *Peticiones incorrectas:* {deleted_incorrect}\n"
                f"üóëÔ∏è *Registros de abuso:* {deleted_abuse}\n"
                f"üóëÔ∏è *Logs antiguos:* {deleted_logs}\n"
                f"üíæ Espacio optimizado\n"
                f"‚ö° Rendimiento mejorado\n\n"
                f"‚è∞ **Completado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        except Exception as e:
            texto = (
                f"üîÑ *Error en Optimizaci√≥n* üîÑ\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Optimizar de Nuevo", callback_data="reorganize_db")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpieza manual de solicitudes antiguas (BOT√ìN A√ëADIDO)
    if data == "manual_old_cleanup":
        try:
            old_requests = get_old_requests()
            
            if not old_requests:
                texto = (
                    f"üßπ *Autocierre Manual de Solicitudes Antiguas* üßπ\n\n"
                    f"‚úÖ No hay solicitudes con m√°s de 20 d√≠as\n"
                    f"üìä Todas las solicitudes est√°n dentro del per√≠odo permitido\n"
                    f"‚è∞ **Verificado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}\n\n"
                    f"üí° *Nota:* Esta funci√≥n cierra autom√°ticamente solicitudes con m√°s de 20 d√≠as de antig√ºedad.\n"
                    f"üîÑ *Autom√°tico:* Se ejecuta diariamente a las 03:00"
                )
            else:
                # Ejecutar limpieza
                await automatic_cleanup(context)
                
                texto = (
                    f"üßπ *Autocierre Manual Ejecutado* üßπ\n\n"
                    f"üìä **Solicitudes procesadas:** {len(old_requests)}\n"
                    f"üîî Usuarios y administradores notificados\n"
                    f"üìù Solicitudes movidas al historial\n"
                    f"‚è∞ **Completado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}\n\n"
                    f"üí° *Nota:* Esta limpieza se ejecuta autom√°ticamente cada d√≠a a las 03:00\n"
                    f"üìã *Criterio:* Solicitudes con m√°s de 20 d√≠as sin gestionar"
                )
        except Exception as e:
            texto = (
                f"üßπ *Error en Autocierre Manual* üßπ\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Ejecutar de Nuevo", callback_data="manual_old_cleanup")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_mantenimiento"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Callbacks de logs - Exportar logs completos
    if data == "export_logs":
        try:
            logger.info(f"üì§ Admin {user_id} solicit√≥ exportaci√≥n de logs")

            with get_db_connection() as conn:
                with conn.cursor(cursor_factory=RealDictCursor) as c:
                    c.execute("""
                        SELECT timestamp, level, message, user_id, chat_id, action, metadata
                        FROM system_logs
                        ORDER BY timestamp DESC
                        LIMIT 1000
                    """)
                    logs = c.fetchall()

            if not logs:
                texto = (
                    f"üì§ *Exportar Logs* üì§\n\n"
                    f"‚ö†Ô∏è No hay logs disponibles para exportar\n"
                    f"üìä El sistema est√° funcionando sin registros\n"
                    f"‚è∞ Consulta: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )

                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="system_logs"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)

                await safe_bot_method(
                    query.edit_message_text,
                    text=texto,
                    reply_markup=reply_markup,
                    parse_mode="Markdown"
                )
                return ConversationHandler.END

            # Crear archivo de texto con los logs
            logs_content = f"LOGS DEL SISTEMA - ENTRESHIJOS BOT\n"
            logs_content += f"Generado: {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n"
            logs_content += f"Total de registros: {len(logs)}\n"
            logs_content += "=" * 80 + "\n\n"

            for log in logs:
                timestamp = log["timestamp"].strftime("%d/%m/%Y %H:%M:%S")
                level = log["level"]
                message = log["message"]
                user_id_log = log.get("user_id", "N/A")
                chat_id_log = log.get("chat_id", "N/A")
                action = log.get("action", "N/A")

                logs_content += f"[{timestamp}] [{level}]\n"
                logs_content += f"Mensaje: {message}\n"
                logs_content += f"Usuario: {user_id_log} | Chat: {chat_id_log} | Acci√≥n: {action}\n"
                logs_content += "-" * 80 + "\n\n"

            # Guardar en archivo temporal
            import tempfile
            with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.txt', encoding='utf-8') as f:
                f.write(logs_content)
                temp_file_path = f.name

            # Enviar archivo al administrador
            await safe_bot_method(
                context.bot.send_document,
                chat_id=chat_id,
                document=open(temp_file_path, 'rb'),
                filename=f"logs_sistema_{datetime.now(SPAIN_TZ).strftime('%Y%m%d_%H%M%S')}.txt",
                caption=f"üì§ *Exportaci√≥n de Logs*\n\nüìä {len(logs)} registros exportados\n‚è∞ {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}",
                parse_mode="Markdown"
            )

            # Eliminar archivo temporal
            import os as os_module
            os_module.unlink(temp_file_path)

            texto = (
                f"üì§ *Logs Exportados* üì§\n\n"
                f"‚úÖ Archivo enviado exitosamente\n"
                f"üìä {len(logs)} registros exportados\n"
                f"üìÑ Formato: TXT\n"
                f"‚è∞ Exportado: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            logger.info(f"‚úÖ Logs exportados exitosamente para admin {user_id}")

        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error exportando logs: {str(e)}", exc_info=True)
            texto = (
                f"üì§ *Error al Exportar Logs* üì§\n\n"
                f"‚ùå Error: {str(e)[:100]}\n"
                f"‚è∞ Intento: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )

        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="system_logs"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "clear_logs":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("DELETE FROM system_logs")
                    deleted_count = c.rowcount
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Logs Limpiados* üóëÔ∏è\n\n"
                f"‚úÖ {deleted_count} logs eliminados\n"
                f"üìä Sistema de logs reiniciado\n"
                f"‚è∞ Limpiado: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        except Exception as e:
            texto = (
                f"üóëÔ∏è *Error al Limpiar Logs* üóëÔ∏è\n\n"
                f"‚ùå Error: {str(e)}\n"
                f"‚è∞ Intento: {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="system_logs"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    if data == "config_logs":
        texto = (
            f"‚öôÔ∏è *Configuraci√≥n de Logs* ‚öôÔ∏è\n\n"
            f"üìä **Estado actual:**\n"
            f"‚Ä¢ Nivel: INFO\n"
            f"‚Ä¢ Formato: Timestamp - Level - Message\n"
            f"‚Ä¢ Retenci√≥n: 30 d√≠as\n"
            f"‚Ä¢ Auto-limpieza: Habilitada\n\n"
            f"üí° *Nota:* La configuraci√≥n de logs es autom√°tica"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="system_logs"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Si llegamos aqu√≠ y no se proces√≥ ning√∫n callback, es realmente no reconocido
    if data == "no_action":
        await query.answer("‚ÑπÔ∏è Esta opci√≥n no est√° disponible", show_alert=False)
        return ConversationHandler.END
    
    # NUEVOS CALLBACKS PARA GESTI√ìN AVANZADA DE INFRACCIONES
    
    # Reiniciar todos los datos de infracciones
    if data == "reset_infraction_data":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Contar registros antes de eliminar
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    incorrect_count = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones")
                    abuse_count = c.fetchone()[0]
                    
                    # Eliminar todos los registros
                    c.execute("DELETE FROM peticiones_incorrectas")
                    c.execute("DELETE FROM abuso_botones")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Datos de Infracciones Reiniciados* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:**\n"
                f"‚Ä¢ ‚ö†Ô∏è Peticiones incorrectas: {incorrect_count}\n"
                f"‚Ä¢ üö® Abusos de botones: {abuse_count}\n\n"
                f"üîÑ **Efectos:**\n"
                f"‚Ä¢ Todos los usuarios pueden hacer solicitudes nuevamente\n"
                f"‚Ä¢ Contadores de infracciones reseteados a 0\n"
                f"‚Ä¢ Historial de abusos limpiado\n\n"
                f"‚è∞ **Reiniciado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Esta acci√≥n no se puede deshacer."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reiniciando datos de infracciones: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Reiniciar Datos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"üîß El sistema contin√∫a operativo\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="suspicious_activity")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver infractores de peticiones incorrectas
    if data == "view_incorrect_offenders":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT pi.user_id, u.username, COUNT(*) as total_attempts, 
                               MAX(pi.timestamp) as last_attempt,
                               COUNT(CASE WHEN pi.timestamp > %s THEN 1 END) as attempts_today
                        FROM peticiones_incorrectas pi
                        LEFT JOIN usuarios u ON pi.user_id = u.user_id
                        GROUP BY pi.user_id, u.username
                        HAVING COUNT(*) > 0
                        ORDER BY total_attempts DESC, last_attempt DESC
                        LIMIT 15
                    """, (datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0),))
                    offenders = c.fetchall()
            
            if not offenders:
                texto = (
                    f"‚ö†Ô∏è *Infractores de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                    f"‚úÖ **Estado:** No hay infractores registrados\n"
                    f"üõ°Ô∏è **Sistema:** Funcionando sin infracciones\n"
                    f"üìä **Registros:** 0 usuarios con peticiones incorrectas\n"
                    f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"‚ö†Ô∏è *Infractores de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                    f"üìä **Total de infractores:** {len(offenders)}\n"
                    f"üîç **Mostrando:** Primeros 15 usuarios\n"
                    f"üìÖ **Per√≠odo:** Hist√≥rico completo\n\n"
                    f"Selecciona un usuario para gestionar sus infracciones:"
                )
                
                keyboard = []
                
                for offender in offenders:
                    username_display = offender['username'] if offender['username'] else f"ID: {offender['user_id']}"
                    username_clean = username_display.replace('@', '') if username_display.startswith('@') else username_display
                    attempts_today = offender['attempts_today']
                    total_attempts = offender['total_attempts']
                    last_attempt = offender['last_attempt'].strftime('%d/%m')
                    
                    # Indicador de estado
                    status_emoji = "üî¥" if attempts_today >= MAX_INCORRECT_ATTEMPTS else "üü°" if attempts_today > 0 else "üü¢"
                    
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{status_emoji} {username_clean} ({total_attempts} total, {attempts_today} hoy) - {last_attempt}",
                            callback_data=f"manage_incorrect_{offender['user_id']}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos", callback_data="clear_all_incorrect"),
                    InlineKeyboardButton("üîÑ Actualizar", callback_data="view_incorrect_offenders")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo infractores incorrectas: {str(e)}")
            texto = (
                f"‚ö†Ô∏è *Error en Infractores* ‚ö†Ô∏è\n\n"
                f"‚ùå Error al cargar infractores: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver infractores de abuso de botones
    if data == "view_abuse_offenders":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("""
                        SELECT ab.user_id, u.username, SUM(ab.attempt_count) as total_abuse,
                               MAX(ab.last_attempt) as last_attempt,
                               COUNT(DISTINCT ab.ticket_number) as tickets_affected
                        FROM abuso_botones ab
                        LEFT JOIN usuarios u ON ab.user_id = u.user_id
                        GROUP BY ab.user_id, u.username
                        HAVING SUM(ab.attempt_count) > 0
                        ORDER BY total_abuse DESC, last_attempt DESC
                        LIMIT 15
                    """)
                    offenders = c.fetchall()
            
            if not offenders:
                texto = (
                    f"üö® *Infractores de Abuso de Botones* üö®\n\n"
                    f"‚úÖ **Estado:** No hay infractores registrados\n"
                    f"üõ°Ô∏è **Sistema:** Funcionando sin abusos\n"
                    f"üìä **Registros:** 0 usuarios con abusos de botones\n"
                    f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
                keyboard = [
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            else:
                texto = (
                    f"üö® *Infractores de Abuso de Botones* üö®\n\n"
                    f"üìä **Total de infractores:** {len(offenders)}\n"
                    f"üîç **Mostrando:** Primeros 15 usuarios\n"
                    f"üìÖ **Per√≠odo:** Hist√≥rico completo\n\n"
                    f"Selecciona un usuario para gestionar sus infracciones:"
                )
                
                keyboard = []
                
                for offender in offenders:
                    username_display = offender['username'] if offender['username'] else f"ID: {offender['user_id']}"
                    username_clean = username_display.replace('@', '') if username_display.startswith('@') else username_display
                    total_abuse = offender['total_abuse']
                    tickets_affected = offender['tickets_affected']
                    last_attempt = offender['last_attempt'].strftime('%d/%m')
                    
                    # Indicador de gravedad
                    if total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS * 3:
                        status_emoji = "üî¥"  # Cr√≠tico
                    elif total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS:
                        status_emoji = "üü†"  # Alto
                    else:
                        status_emoji = "üü°"  # Moderado
                    
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{status_emoji} {username_clean} ({total_abuse} abusos, {tickets_affected} tickets) - {last_attempt}",
                            callback_data=f"manage_abuse_{offender['user_id']}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos", callback_data="clear_all_abuse"),
                    InlineKeyboardButton("üîÑ Actualizar", callback_data="view_abuse_offenders")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo infractores de abuso: {str(e)}")
            texto = (
                f"üö® *Error en Infractores de Abuso* üö®\n\n"
                f"‚ùå Error al cargar infractores: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Seleccionar usuario para gesti√≥n de infracciones
    if data == "select_infraction_user":
        texto = (
            f"üîç *Seleccionar Usuario para Gesti√≥n de Infracciones* üîç\n\n"
            f"Busca un usuario espec√≠fico para gestionar sus infracciones.\n"
            f"Puedes buscar por:\n\n"
            f"üë§ **Username** (ej: @usuario)\n"
            f"üÜî **User ID** (ej: 123456789)\n\n"
            f"üìù **Funcionalidades disponibles:**\n"
            f"‚Ä¢ Ver historial completo de infracciones\n"
            f"‚Ä¢ Reducir contadores espec√≠ficos\n"
            f"‚Ä¢ Limpiar registros individuales\n"
            f"‚Ä¢ Estad√≠sticas detalladas del usuario\n\n"
            f"Escribe tu consulta de b√∫squeda:"
        )
        
        pending_searches[f"{user_id}_{chat_id}"] = {
            "timestamp": datetime.now(SPAIN_TZ),
            "message_id": message_id,
            "admin_id": user_id,
            "search_type": "infraction_management"
        }
        
        keyboard = [
            [InlineKeyboardButton("‚ùå Cancelar B√∫squeda", callback_data="cancel_infraction_search")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        instruction_msg = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="üîç *Escribe el username (@usuario) o user_id del usuario:*",
            parse_mode="Markdown"
        )
        
        if instruction_msg:
            context.user_data["infraction_search_instruction_msg"] = instruction_msg.message_id
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        return ASKING_USER_SEARCH

    # Cancelar b√∫squeda de infracciones
    if data == "cancel_infraction_search":
        search_key = f"{user_id}_{chat_id}"
        if search_key in pending_searches:
            del pending_searches[search_key]
        
        instruction_msg_id = context.user_data.get("infraction_search_instruction_msg")
        if instruction_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=instruction_msg_id
            )
            if "infraction_search_instruction_msg" in context.user_data:
                del context.user_data["infraction_search_instruction_msg"]
        
        texto = (
            f"‚ùå *B√∫squeda de Infracciones Cancelada* ‚ùå\n\n"
            f"La b√∫squeda de usuario para gesti√≥n de infracciones ha sido cancelada.\n"
            f"‚è∞ *Cancelado:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ B√∫squeda de infracciones cancelada por user_id={user_id}")
        return ConversationHandler.END

    # Gestionar infracciones de peticiones incorrectas de usuario espec√≠fico
    if data.startswith("manage_incorrect_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener estad√≠sticas detalladas
                    c.execute("""
                        SELECT COUNT(*) as total_attempts,
                               MAX(timestamp) as last_attempt,
                               MIN(timestamp) as first_attempt,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as attempts_today,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as attempts_week
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s
                    """, (
                        datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0),
                        datetime.now(SPAIN_TZ) - timedelta(days=7),
                        target_user_id
                    ))
                    stats = c.fetchone()
                    
                    # Obtener √∫ltimos intentos
                    c.execute("""
                        SELECT timestamp, chat_id, attempt_count
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s 
                        ORDER BY timestamp DESC 
                        LIMIT 5
                    """, (target_user_id,))
                    recent_attempts = c.fetchall()
            
            username = user_info['username'] or f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Determinar estado del usuario
            is_blocked = stats['attempts_today'] >= MAX_INCORRECT_ATTEMPTS
            status_text = "üî¥ Bloqueado" if is_blocked else "üü¢ Activo"
            
            texto = (
                f"‚ö†Ô∏è *Gesti√≥n de Peticiones Incorrectas* ‚ö†Ô∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Estado:** {status_text}\n\n"
                f"üìà **Estad√≠sticas:**\n"
                f"‚Ä¢ Total hist√≥rico: {stats['total_attempts']}\n"
                f"‚Ä¢ Intentos hoy: {stats['attempts_today']}/{MAX_INCORRECT_ATTEMPTS}\n"
                f"‚Ä¢ Intentos esta semana: {stats['attempts_week']}\n"
                f"‚Ä¢ Primer intento: {stats['first_attempt'].strftime('%d/%m/%Y') if stats['first_attempt'] else 'N/A'}\n"
                f"‚Ä¢ √öltimo intento: {stats['last_attempt'].strftime('%d/%m/%Y %H:%M') if stats['last_attempt'] else 'N/A'}\n\n"
                f"üîß **Acciones disponibles:**"
            )
            
            keyboard = []
            
            # Botones seg√∫n el estado
            if stats['total_attempts'] > 0:
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos los Registros", callback_data=f"clear_user_incorrect_{target_user_id}"),
                    InlineKeyboardButton("‚ûñ Reducir Contador", callback_data=f"reduce_incorrect_{target_user_id}")
                ])
                
                if stats['attempts_today'] > 0:
                    keyboard.append([
                        InlineKeyboardButton("üîÑ Resetear Solo Hoy", callback_data=f"reset_today_incorrect_{target_user_id}")
                    ])
            
            # Informaci√≥n y navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üìä Ver Detalles", callback_data=f"view_incorrect_details_{target_user_id}"),
                InlineKeyboardButton("üë§ Perfil Usuario", callback_data=f"user_details_{target_user_id}")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_incorrect_offenders"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error gestionando infracciones incorrectas: {str(e)}")
            texto = (
                f"‚ö†Ô∏è *Error en Gesti√≥n* ‚ö†Ô∏è\n\n"
                f"‚ùå Error al cargar datos: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_incorrect_offenders"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Gestionar infracciones de abuso de botones de usuario espec√≠fico
    if data.startswith("manage_abuse_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener estad√≠sticas detalladas de abuso
                    c.execute("""
                        SELECT SUM(attempt_count) as total_abuse,
                               MAX(last_attempt) as last_attempt,
                               MIN(last_attempt) as first_attempt,
                               COUNT(DISTINCT ticket_number) as tickets_affected,
                               COUNT(DISTINCT chat_id) as chats_affected
                        FROM abuso_botones 
                        WHERE user_id = %s
                    """, (target_user_id,))
                    stats = c.fetchone()
                    
                    # Obtener √∫ltimos abusos
                    c.execute("""
                        SELECT ticket_number, attempt_count, last_attempt, chat_id
                        FROM abuso_botones 
                        WHERE user_id = %s 
                        ORDER BY last_attempt DESC 
                        LIMIT 5
                    """, (target_user_id,))
                    recent_abuse = c.fetchall()
            
            username = user_info['username'] or f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Determinar nivel de gravedad
            total_abuse = stats['total_abuse'] or 0
            if total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS * 3:
                severity = "üî¥ Cr√≠tico"
            elif total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS:
                severity = "üü† Alto"
            else:
                severity = "üü° Moderado"
            
            texto = (
                f"üö® *Gesti√≥n de Abuso de Botones* üö®\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Nivel de Gravedad:** {severity}\n\n"
                f"üìà **Estad√≠sticas:**\n"
                f"‚Ä¢ Total de abusos: {total_abuse}\n"
                f"‚Ä¢ Tickets afectados: {stats['tickets_affected'] or 0}\n"
                f"‚Ä¢ Grupos afectados: {stats['chats_affected'] or 0}\n"
                f"‚Ä¢ Primer abuso: {stats['first_attempt'].strftime('%d/%m/%Y') if stats['first_attempt'] else 'N/A'}\n"
                f"‚Ä¢ √öltimo abuso: {stats['last_attempt'].strftime('%d/%m/%Y %H:%M') if stats['last_attempt'] else 'N/A'}\n\n"
                f"üîß **Acciones disponibles:**"
            )
            
            keyboard = []
            
            # Botones seg√∫n la gravedad
            if total_abuse > 0:
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todos los Abusos", callback_data=f"clear_user_abuse_{target_user_id}"),
                    InlineKeyboardButton("‚ûñ Reducir Contador", callback_data=f"reduce_abuse_{target_user_id}")
                ])
                
                keyboard.append([
                    InlineKeyboardButton("üìã Ver Detalles", callback_data=f"view_abuse_details_{target_user_id}"),
                    InlineKeyboardButton("‚ö†Ô∏è Advertir Usuario", callback_data=f"warn_user_{target_user_id}")
                ])
            
            # Informaci√≥n y navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üë§ Perfil Usuario", callback_data=f"user_details_{target_user_id}"),
                InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_abuse_offenders"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error gestionando abusos: {str(e)}")
            texto = (
                f"üö® *Error en Gesti√≥n de Abusos* üö®\n\n"
                f"‚ùå Error al cargar datos: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_abuse_offenders"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Estad√≠sticas detalladas de infracciones
    if data == "infraction_detailed_stats":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Estad√≠sticas generales
                    c.execute("SELECT COUNT(DISTINCT user_id) FROM peticiones_incorrectas")
                    total_incorrect_users = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    total_incorrect_attempts = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(DISTINCT user_id) FROM abuso_botones")
                    total_abuse_users = c.fetchone()[0]
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones")
                    total_abuse_attempts = c.fetchone()[0] or 0
                    
                    # Estad√≠sticas por per√≠odo
                    today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
                    week_start = datetime.now(SPAIN_TZ) - timedelta(days=7)
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE timestamp > %s", (today_start,))
                    incorrect_today = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE timestamp > %s", (week_start,))
                    incorrect_week = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones WHERE last_attempt > %s", (today_start,))
                    abuse_today = c.fetchone()[0]
                    
                    c.execute("SELECT COUNT(*) FROM abuso_botones WHERE last_attempt > %s", (week_start,))
                    abuse_week = c.fetchone()[0]
                    
                    # Top infractores
                    c.execute("""
                        SELECT u.username, COUNT(*) as attempts
                        FROM peticiones_incorrectas pi
                        LEFT JOIN usuarios u ON pi.user_id = u.user_id
                        GROUP BY u.username
                        ORDER BY attempts DESC
                        LIMIT 3
                    """)
                    top_incorrect = c.fetchall()
                    
                    c.execute("""
                        SELECT u.username, SUM(ab.attempt_count) as total_abuse
                        FROM abuso_botones ab
                        LEFT JOIN usuarios u ON ab.user_id = u.user_id
                        GROUP BY u.username
                        ORDER BY total_abuse DESC
                        LIMIT 3
                    """)
                    top_abuse = c.fetchall()
            
            # Calcular tasas
            avg_incorrect_per_user = round(total_incorrect_attempts / total_incorrect_users, 1) if total_incorrect_users > 0 else 0
            avg_abuse_per_user = round(total_abuse_attempts / total_abuse_users, 1) if total_abuse_users > 0 else 0
            
            texto = (
                f"üìä *Estad√≠sticas Detalladas de Infracciones* üìä\n\n"
                f"‚ö†Ô∏è **Peticiones Incorrectas:**\n"
                f"‚Ä¢ Usuarios afectados: {total_incorrect_users}\n"
                f"‚Ä¢ Total de intentos: {total_incorrect_attempts}\n"
                f"‚Ä¢ Promedio por usuario: {avg_incorrect_per_user}\n"
                f"‚Ä¢ Hoy: {incorrect_today} | Semana: {incorrect_week}\n\n"
                f"üö® **Abuso de Botones:**\n"
                f"‚Ä¢ Usuarios infractores: {total_abuse_users}\n"
                f"‚Ä¢ Total de abusos: {total_abuse_attempts}\n"
                f"‚Ä¢ Promedio por usuario: {avg_abuse_per_user}\n"
                f"‚Ä¢ Hoy: {abuse_today} | Semana: {abuse_week}\n\n"
                f"üèÜ **Top Infractores (Incorrectas):**\n"
            )
            
            if top_incorrect:
                for i, user in enumerate(top_incorrect, 1):
                    username_safe = escape_markdown(user['username'] or "Usuario", preserve_username=True)
                    texto += f"{i}. {username_safe}: {user['attempts']}\n"
            else:
                texto += "Sin datos\n"
            
            texto += f"\nüèÜ **Top Infractores (Abusos):**\n"
            
            if top_abuse:
                for i, user in enumerate(top_abuse, 1):
                    username_safe = escape_markdown(user['username'] or "Usuario", preserve_username=True)
                    texto += f"{i}. {username_safe}: {user['total_abuse']}\n"
            else:
                texto += "Sin datos\n"
            
            texto += f"\n‚è∞ **Actualizado:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas detalladas: {str(e)}")
            texto = (
                f"üìä *Error en Estad√≠sticas* üìä\n\n"
                f"‚ùå Error al cargar estad√≠sticas: {escape_markdown(str(e))}\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Actualizar", callback_data="infraction_detailed_stats")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar todas las peticiones incorrectas
    if data == "clear_all_incorrect":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas")
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Peticiones Incorrectas Limpiadas* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Efecto:** Todos los usuarios pueden hacer solicitudes\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Los contadores de todos los usuarios han sido reseteados."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando peticiones incorrectas: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="view_incorrect_offenders")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_incorrect_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar todos los abusos de botones
    if data == "clear_all_abuse":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM abuso_botones")
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM abuso_botones")
                    conn.commit()
            
            texto = (
                f"üóëÔ∏è *Abusos de Botones Limpiados* üóëÔ∏è\n\n"
                f"‚úÖ **Operaci√≥n completada exitosamente**\n\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Efecto:** Todos los contadores de abuso reseteados\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"üí° **Nota:** Los usuarios ya no tienen restricciones por abuso."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando abusos de botones: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Abusos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Verificar Estado", callback_data="view_abuse_offenders")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="view_abuse_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Acciones espec√≠ficas para usuarios infractores
    if data.startswith("clear_user_incorrect_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    count_before = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üóëÔ∏è *Registros de Usuario Limpiados* üóëÔ∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Registros eliminados:** {count_before}\n"
                f"üîÑ **Estado:** Usuario desbloqueado\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede hacer solicitudes normalmente."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando registros de usuario: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Usuario* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_incorrect_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar abusos de usuario espec√≠fico
    if data.startswith("clear_user_abuse_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    count_before = c.fetchone()[0] or 0
                    
                    c.execute("DELETE FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üóëÔ∏è *Abusos de Usuario Limpiados* üóëÔ∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Abusos eliminados:** {count_before}\n"
                f"üîÑ **Estado:** Sin restricciones por abuso\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede usar botones normalmente."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando abusos de usuario: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Abusos* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Lista", callback_data="view_abuse_offenders"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reducir contador de peticiones incorrectas
    if data.startswith("reduce_incorrect_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    # Eliminar el registro m√°s reciente
                    c.execute("""
                        DELETE FROM peticiones_incorrectas 
                        WHERE user_id = %s AND timestamp = (
                            SELECT MAX(timestamp) FROM peticiones_incorrectas WHERE user_id = %s
                        )
                    """, (target_user_id, target_user_id))
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    remaining_count = c.fetchone()[0]
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"‚ûñ *Contador Reducido* ‚ûñ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Registros restantes:** {remaining_count}\n"
                f"üîÑ **Acci√≥n:** √öltimo intento eliminado\n"
                f"‚è∞ **Reducido:** {get_spain_time()}\n\n"
                f"‚úÖ Contador de peticiones incorrectas reducido."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reduciendo contador: {str(e)}")
            texto = (
                f"‚ûñ *Error al Reducir* ‚ûñ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_incorrect_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Reducir contador de abusos
    if data.startswith("reduce_abuse_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    # Reducir el contador del registro con m√°s abusos
                    c.execute("""
                        UPDATE abuso_botones 
                        SET attempt_count = GREATEST(attempt_count - 1, 0)
                        WHERE user_id = %s AND attempt_count = (
                            SELECT MAX(attempt_count) FROM abuso_botones WHERE user_id = %s
                        )
                    """, (target_user_id, target_user_id))
                    
                    # Eliminar registros con 0 intentos
                    c.execute("DELETE FROM abuso_botones WHERE user_id = %s AND attempt_count = 0", (target_user_id,))
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    remaining_abuse = c.fetchone()[0] or 0
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"‚ûñ *Contador de Abusos Reducido* ‚ûñ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Abusos restantes:** {remaining_abuse}\n"
                f"üîÑ **Acci√≥n:** Contador reducido en 1\n"
                f"‚è∞ **Reducido:** {get_spain_time()}\n\n"
                f"‚úÖ Contador de abusos de botones reducido."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reduciendo abusos: {str(e)}")
            texto = (
                f"‚ûñ *Error al Reducir Abusos* ‚ûñ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_abuse_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Resetear solo intentos de hoy
    if data.startswith("reset_today_incorrect_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    today_start = datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0)
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s AND timestamp >= %s", 
                             (target_user_id, today_start))
                    count_today = c.fetchone()[0]
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE user_id = %s AND timestamp >= %s", 
                             (target_user_id, today_start))
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    remaining_total = c.fetchone()[0]
                    
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üîÑ *Intentos de Hoy Reseteados* üîÑ\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Eliminados hoy:** {count_today}\n"
                f"üìä **Total restante:** {remaining_total}\n"
                f"üîÑ **Estado:** Desbloqueado para hoy\n"
                f"‚è∞ **Reseteado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede hacer solicitudes hoy."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error reseteando intentos de hoy: {str(e)}")
            texto = (
                f"üîÑ *Error al Resetear* üîÑ\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_incorrect_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver detalles de infracciones incorrectas
    if data.startswith("view_incorrect_details_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("""
                        SELECT timestamp, chat_id, attempt_count
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s 
                        ORDER BY timestamp DESC 
                        LIMIT 10
                    """, (target_user_id,))
                    details = c.fetchall()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üìã *Detalles de Peticiones Incorrectas* üìã\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n\n"
                f"üìÖ **√öltimos 10 intentos incorrectos:**\n\n"
            )
            
            if details:
                for i, detail in enumerate(details, 1):
                    fecha = detail['timestamp'].strftime('%d/%m/%Y %H:%M')
                    grupo_name = GRUPOS_PREDEFINIDOS.get(detail['chat_id'], f"Grupo {detail['chat_id']}")
                    texto += f"**{i}.** {fecha} - {escape_markdown(grupo_name)} (Intento #{detail['attempt_count']})\n"
            else:
                texto += "Sin registros de intentos incorrectos.\n"
            
            texto += f"\n‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo detalles incorrectas: {str(e)}")
            texto = (
                f"üìã *Error en Detalles* üìã\n\n"
                f"‚ùå Error al cargar detalles: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_incorrect_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Ver detalles de abusos de botones
    if data.startswith("view_abuse_details_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("""
                        SELECT ticket_number, attempt_count, last_attempt, chat_id
                        FROM abuso_botones 
                        WHERE user_id = %s 
                        ORDER BY last_attempt DESC 
                        LIMIT 10
                    """, (target_user_id,))
                    details = c.fetchall()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üìã *Detalles de Abusos de Botones* üìã\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n\n"
                f"üìÖ **√öltimos 10 abusos registrados:**\n\n"
            )
            
            if details:
                for i, detail in enumerate(details, 1):
                    fecha = detail['last_attempt'].strftime('%d/%m/%Y %H:%M')
                    grupo_name = GRUPOS_PREDEFINIDOS.get(detail['chat_id'], f"Grupo {detail['chat_id']}")
                    texto += f"**{i}.** Ticket #{detail['ticket_number']} - {fecha} - {escape_markdown(grupo_name)} ({detail['attempt_count']} abusos)\n"
            else:
                texto += "Sin registros de abusos de botones.\n"
            
            texto += f"\n‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo detalles de abusos: {str(e)}")
            texto = (
                f"üìã *Error en Detalles de Abusos* üìã\n\n"
                f"‚ùå Error al cargar detalles: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_abuse_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Advertir usuario
    if data.startswith("warn_user_"):
        target_user_id = int(data.split("_")[2])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Enviar advertencia al usuario
            warning_message = (
                f"‚ö†Ô∏è *Advertencia Oficial* ‚ö†Ô∏è\n\n"
                f"Estimado/a {username_escaped},\n\n"
                f"Hemos detectado un uso inadecuado de las funcionalidades del bot por tu parte. "
                f"Te recordamos que es importante respetar las normas de la comunidad.\n\n"
                f"üìã **Normas importantes:**\n"
                f"‚Ä¢ Usa solo los botones de tus propias solicitudes\n"
                f"‚Ä¢ Respeta las peticiones de otros usuarios\n"
                f"‚Ä¢ Sigue el formato correcto para las solicitudes\n\n"
                f"‚ö†Ô∏è **Advertencia:** El uso indebido continuado puede resultar en restricciones o expulsi√≥n.\n\n"
                f"Gracias por tu comprensi√≥n y colaboraci√≥n.\n\n"
                f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
            )
            
            warning_sent = await safe_bot_method(
                context.bot.send_message,
                chat_id=target_user_id,
                text=warning_message,
                parse_mode="Markdown"
            )
            
            if warning_sent:
                texto = (
                    f"‚ö†Ô∏è *Advertencia Enviada* ‚ö†Ô∏è\n\n"
                    f"üë§ **Usuario:** {username_escaped}\n"
                    f"üÜî **ID:** {target_user_id}\n"
                    f"üì§ **Estado:** Advertencia enviada por mensaje privado\n"
                    f"‚è∞ **Enviado:** {get_spain_time()}\n\n"
                    f"‚úÖ El usuario ha sido notificado oficialmente."
                )
            else:
                texto = (
                    f"‚ö†Ô∏è *Error al Enviar Advertencia* ‚ö†Ô∏è\n\n"
                    f"üë§ **Usuario:** {username_escaped}\n"
                    f"üÜî **ID:** {target_user_id}\n"
                    f"‚ùå **Error:** No se pudo enviar mensaje privado\n"
                    f"üí° **Sugerencia:** El usuario debe iniciar conversaci√≥n con el bot primero\n"
                    f"‚è∞ **Intento:** {get_spain_time()}"
                )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error enviando advertencia: {str(e)}")
            texto = (
                f"‚ö†Ô∏è *Error al Advertir* ‚ö†Ô∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver a Gesti√≥n", callback_data=f"manage_abuse_{target_user_id}")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Gestionar infracciones de usuario desde b√∫squeda
    if data.startswith("manage_user_infractions_"):
        target_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Obtener estad√≠sticas de peticiones incorrectas
                    c.execute("""
                        SELECT COUNT(*) as total_incorrect,
                               MAX(timestamp) as last_incorrect,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as incorrect_today
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s
                    """, (datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0), target_user_id))
                    incorrect_stats = c.fetchone()
                    
                    # Obtener estad√≠sticas de abusos
                    c.execute("""
                        SELECT SUM(attempt_count) as total_abuse,
                               MAX(last_attempt) as last_abuse,
                               COUNT(DISTINCT ticket_number) as tickets_affected
                        FROM abuso_botones 
                        WHERE user_id = %s
                    """, (target_user_id,))
                    abuse_stats = c.fetchone()
            
            username = user_info['username'] or f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            total_incorrect = incorrect_stats['total_incorrect'] or 0
            total_abuse = abuse_stats['total_abuse'] or 0
            
            # Determinar estado general
            if total_incorrect >= MAX_INCORRECT_ATTEMPTS or total_abuse >= MAX_BUTTON_ABUSE_ATTEMPTS:
                status = "üî¥ Cr√≠tico"
            elif total_incorrect > 0 or total_abuse > 0:
                status = "üü° Con infracciones"
            else:
                status = "üü¢ Sin infracciones"
            
            texto = (
                f"üîç *Gesti√≥n Completa de Infracciones* üîç\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Estado General:** {status}\n\n"
                f"‚ö†Ô∏è **Peticiones Incorrectas:**\n"
                f"‚Ä¢ Total: {total_incorrect}\n"
                f"‚Ä¢ Hoy: {incorrect_stats['incorrect_today'] or 0}/{MAX_INCORRECT_ATTEMPTS}\n"
                f"‚Ä¢ √öltimo: {incorrect_stats['last_incorrect'].strftime('%d/%m/%Y %H:%M') if incorrect_stats['last_incorrect'] else 'N/A'}\n\n"
                f"üö® **Abuso de Botones:**\n"
                f"‚Ä¢ Total: {total_abuse}\n"
                f"‚Ä¢ Tickets afectados: {abuse_stats['tickets_affected'] or 0}\n"
                f"‚Ä¢ √öltimo: {abuse_stats['last_abuse'].strftime('%d/%m/%Y %H:%M') if abuse_stats['last_abuse'] else 'N/A'}\n\n"
                f"üîß **Gesti√≥n r√°pida:**"
            )
            
            keyboard = []
            
            # Botones de gesti√≥n r√°pida
            if total_incorrect > 0:
                keyboard.append([
                    InlineKeyboardButton("‚ö†Ô∏è Gestionar Incorrectas", callback_data=f"manage_incorrect_{target_user_id}")
                ])
            
            if total_abuse > 0:
                keyboard.append([
                    InlineKeyboardButton("üö® Gestionar Abusos", callback_data=f"manage_abuse_{target_user_id}")
                ])
            
            if total_incorrect > 0 or total_abuse > 0:
                keyboard.append([
                    InlineKeyboardButton("üóëÔ∏è Limpiar Todo", callback_data=f"clear_all_user_infractions_{target_user_id}"),
                    InlineKeyboardButton("‚ö†Ô∏è Advertir", callback_data=f"warn_user_{target_user_id}")
                ])
            
            # Navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}"),
                InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error gestionando infracciones completas: {str(e)}")
            texto = (
                f"üîç *Error en Gesti√≥n Completa* üîç\n\n"
                f"‚ùå Error al cargar datos: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Limpiar todas las infracciones de un usuario
    if data.startswith("clear_all_user_infractions_"):
        target_user_id = int(data.split("_")[4])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (target_user_id,))
                    user_info = c.fetchone()
                    
                    c.execute("SELECT COUNT(*) FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    incorrect_count = c.fetchone()[0]
                    
                    c.execute("SELECT SUM(attempt_count) FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    abuse_count = c.fetchone()[0] or 0
                    
                    c.execute("DELETE FROM peticiones_incorrectas WHERE user_id = %s", (target_user_id,))
                    c.execute("DELETE FROM abuso_botones WHERE user_id = %s", (target_user_id,))
                    conn.commit()
            
            username = user_info['username'] if user_info else f"User {target_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            texto = (
                f"üóëÔ∏è *Todas las Infracciones Limpiadas* üóëÔ∏è\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {target_user_id}\n"
                f"üìä **Incorrectas eliminadas:** {incorrect_count}\n"
                f"üìä **Abusos eliminados:** {abuse_count}\n"
                f"üîÑ **Estado:** Completamente limpio\n"
                f"‚è∞ **Limpiado:** {get_spain_time()}\n\n"
                f"‚úÖ El usuario puede usar el bot sin restricciones."
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error limpiando todas las infracciones: {str(e)}")
            texto = (
                f"üóëÔ∏è *Error al Limpiar Todo* üóëÔ∏è\n\n"
                f"‚ùå **Error:** {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {get_spain_time()}"
            )
        
        keyboard = [
            [InlineKeyboardButton("üë§ Ver Perfil", callback_data=f"user_details_{target_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user"),
             InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    # Estad√≠sticas detalladas de usuario espec√≠fico
    if data.startswith("user_detailed_stats_"):
        searched_user_id = int(data.split("_")[3])
        
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    # Obtener informaci√≥n b√°sica del usuario
                    c.execute("SELECT username FROM usuarios WHERE user_id = %s", (searched_user_id,))
                    user_info = c.fetchone()
                    
                    if not user_info:
                        await query.answer("‚ùå Usuario no encontrado", show_alert=True)
                        return ConversationHandler.END
                    
                    # Estad√≠sticas de solicitudes
                    c.execute("""
                        SELECT COUNT(*) as total_pending
                        FROM peticiones_registradas 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    pending_stats = c.fetchone()
                    
                    c.execute("""
                        SELECT estado, COUNT(*) as count
                        FROM historial_solicitudes 
                        WHERE user_id = %s
                        GROUP BY estado
                    """, (searched_user_id,))
                    history_by_status = {row['estado']: row['count'] for row in c.fetchall()}
                    
                    # Estad√≠sticas de encuestas
                    c.execute("""
                        SELECT satisfaccion, COUNT(*) as count
                        FROM encuestas_satisfaccion 
                        WHERE user_id = %s
                        GROUP BY satisfaccion
                    """, (searched_user_id,))
                    surveys = {row['satisfaccion']: row['count'] for row in c.fetchall()}
                    
                    # Estad√≠sticas de infracciones
                    c.execute("""
                        SELECT COUNT(*) as total_incorrect,
                               COUNT(CASE WHEN timestamp > %s THEN 1 END) as incorrect_today
                        FROM peticiones_incorrectas 
                        WHERE user_id = %s
                    """, (datetime.now(SPAIN_TZ).replace(hour=0, minute=0, second=0, microsecond=0), searched_user_id))
                    incorrect_stats = c.fetchone()
                    
                    c.execute("""
                        SELECT SUM(attempt_count) as total_abuse,
                               COUNT(DISTINCT ticket_number) as tickets_affected
                        FROM abuso_botones 
                        WHERE user_id = %s
                    """, (searched_user_id,))
                    abuse_stats = c.fetchone()
                    
                    # Obtener contador actual de solicitudes
                    c.execute("SELECT count, last_reset FROM peticiones_por_usuario WHERE user_id = %s", (searched_user_id,))
                    current_requests = c.fetchone()
            
            username = user_info['username'] or f"User {searched_user_id}"
            username_display = f"@{username}" if not username.startswith("@") else username
            username_escaped = escape_markdown(username_display, preserve_username=True)
            
            # Calcular estad√≠sticas
            total_history = sum(history_by_status.values())
            success_rate = (history_by_status.get('subido', 0) / total_history * 100) if total_history > 0 else 0
            total_surveys = sum(surveys.values())
            satisfaction_rate = ((surveys.get('excelente', 0) + surveys.get('bueno', 0)) / total_surveys * 100) if total_surveys > 0 else 0
            
            current_count = current_requests['count'] if current_requests else 0
            last_reset = current_requests['last_reset'].strftime('%d/%m/%Y') if current_requests and current_requests['last_reset'] else "No registrado"
            
            texto = (
                f"üìà *Estad√≠sticas Detalladas de Usuario* üìà\n\n"
                f"üë§ **Usuario:** {username_escaped}\n"
                f"üÜî **ID:** {searched_user_id}\n\n"
                f"üìä **Solicitudes:**\n"
                f"‚Ä¢ Pendientes: {pending_stats['total_pending'] or 0}\n"
                f"‚Ä¢ Aprobadas: {history_by_status.get('subido', 0)}\n"
                f"‚Ä¢ Denegadas: {history_by_status.get('denegado', 0)}\n"
                f"‚Ä¢ Eliminadas: {history_by_status.get('eliminado', 0)}\n"
                f"‚Ä¢ Canceladas: {history_by_status.get('cancelado', 0)}\n"
                f"‚Ä¢ Tasa de √©xito: {success_rate:.1f}%\n\n"
                f"üòä **Satisfacci√≥n:**\n"
                f"‚Ä¢ Excelente: {surveys.get('excelente', 0)}\n"
                f"‚Ä¢ Bueno: {surveys.get('bueno', 0)}\n"
                f"‚Ä¢ Regular: {surveys.get('regular', 0)}\n"
                f"‚Ä¢ Malo: {surveys.get('malo', 0)}\n"
                f"‚Ä¢ Tasa satisfacci√≥n: {satisfaction_rate:.1f}%\n\n"
                f"‚ö†Ô∏è **Infracciones:**\n"
                f"‚Ä¢ Peticiones incorrectas: {incorrect_stats['total_incorrect'] or 0} (hoy: {incorrect_stats['incorrect_today'] or 0})\n"
                f"‚Ä¢ Abusos de botones: {abuse_stats['total_abuse'] or 0} (tickets: {abuse_stats['tickets_affected'] or 0})\n\n"
                f"üìÖ **Estado Actual:**\n"
                f"‚Ä¢ Solicitudes hoy: {current_count}/2\n"
                f"‚Ä¢ √öltimo reinicio: {last_reset}\n\n"
                f"‚è∞ **Consulta:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error obteniendo estad√≠sticas detalladas del usuario: {str(e)}")
            texto = (
                f"üìà *Error en Estad√≠sticas Detalladas* üìà\n\n"
                f"‚ùå Error al cargar estad√≠sticas: {escape_markdown(str(e))}\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Perfil", callback_data=f"user_details_{searched_user_id}")],
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END

    logger.warning(f"‚ö†Ô∏è Callback data no reconocido: {data} por @{query.from_user.username}")
    return ConversationHandler.END

async def handle_user_menu_estado(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                ticket_number: int, view_type: str,
                                original_chat_id: int = None, original_message_id: int = None) -> None:
    """Maneja los men√∫s interactivos para usuarios."""
    query = update.callback_query
    chat_id = original_chat_id or query.message.chat_id
    message_id = original_message_id or query.message.message_id
    user_id = query.from_user.id
    
    peticion = get_peticion_registrada(ticket_number)
    historial = get_historial_solicitud(ticket_number)
    
    if not peticion and not historial:
        await safe_bot_method(
            query.answer,
            text=f"‚ùå La solicitud #{ticket_number} no existe.",
            show_alert=True
        )
        return None
    
    if not original_message_id:
        context.bot_data[f"estado_{ticket_number}"] = message_id
        context.bot_data[f"estado_{ticket_number}_chat_id"] = chat_id
    
    if view_type == "main":
        if historial:
            estado = historial["estado"].capitalize()
            fecha_gestion = historial["fecha_gestion"].strftime("%d/%m/%Y %H:%M:%S")
            url = historial["url"] or "No proporcionado"
            reason = historial["reason"] or "No especificado"
            
            texto = (
                f"üìå *Estado de Solicitud #{ticket_number}* üìå\n"
                f"üìä *Estado:* {estado}\n"
                f"‚è∞ *Fecha de Gesti√≥n:* {fecha_gestion}\n"
                f"üîó *Enlace:* {url}\n"
                f"üìù *Motivo:* {reason}"
            )
            
            keyboard = [
                [InlineKeyboardButton("üìã Ver Detalles", callback_data=f"ticket_{ticket_number}_estado")],
                [InlineKeyboardButton("üìû Contactar Admin", callback_data=f"contactar_admin_{ticket_number}")]
            ]
            
            if estado.lower() == "subido":
                keyboard.insert(0, [InlineKeyboardButton("üòä Encuesta de Satisfacci√≥n", callback_data=f"encuesta_{ticket_number}")])
        else:
            timestamp_str = peticion["timestamp"].strftime("%d/%m/%Y %H:%M:%S")
            votes = get_votes_summary(ticket_number)
            vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else ""
            
            texto = (
                f"üìå *Estado de Solicitud #{ticket_number}* üìå\n"
                f"üìä *Estado:* Pendiente\n"
                f"‚è∞ *Fecha de Registro:* {timestamp_str}{vote_text}\n"
                f"‚åõ Tu solicitud est√° siendo procesada."
            )
            keyboard = [
                [InlineKeyboardButton("üëç Votar +", callback_data=f"vote_{ticket_number}_1"),
                 InlineKeyboardButton("üëé Votar -", callback_data=f"vote_{ticket_number}_-1")],
                [InlineKeyboardButton("üìã Ver Detalles", callback_data=f"ticket_{ticket_number}_estado")],
                [InlineKeyboardButton("üìû Contactar Admin", callback_data=f"contactar_admin_{ticket_number}")]
            ]
    
    elif view_type == "details":
        if historial:
            username_escaped = escape_markdown(historial["username"], preserve_username=True)
            message_text_escaped = escape_markdown(historial["message_text"])
            chat_title_escaped = escape_markdown(historial["chat_title"])
            estado = historial["estado"].capitalize()
            fecha_gestion = historial["fecha_gestion"].strftime("%d/%m/%Y %H:%M:%S")
            url = historial["url"] or "No proporcionado"
            reason = historial["reason"] or "No especificado"
            
            texto = (
                f"üìå *Detalles de Solicitud #{ticket_number}* üìå\n"
                f"üë§ *Usuario:* {username_escaped}\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {chat_title_escaped}\n"
                f"üìé *Adjunto:* {'S√≠' if historial['has_attachment'] else 'No'}\n"
                f"üìä *Estado:* {estado}\n"
                f"‚è∞ *Fecha de Gesti√≥n:* {fecha_gestion}\n"
                f"üîó *Enlace:* {url}\n"
                f"üìù *Motivo:* {reason}"
            )
        else:
            username_escaped = escape_markdown(peticion["username"], preserve_username=True)
            message_text_escaped = escape_markdown(peticion["message_text"])
            chat_title_escaped = escape_markdown(peticion["chat_title"])
            timestamp_str = peticion["timestamp"].strftime("%d/%m/%Y %H:%M:%S")
            votes = get_votes_summary(ticket_number)
            vote_text = f"\nüó≥Ô∏è *Votos:* +{votes['positive']} / -{votes['negative']}" if votes['total'] > 0 else ""
            
            texto = (
                f"üìå *Detalles de Solicitud #{ticket_number}* üìå\n"
                f"üë§ *Usuario:* {username_escaped}\n"
                f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                f"üìç *Grupo:* {chat_title_escaped}\n"
                f"üìé *Adjunto:* {'S√≠' if peticion['has_attachment'] else 'No'}\n"
                f"üìä *Estado:* Pendiente\n"
                f"‚è∞ *Fecha de Registro:* {timestamp_str}{vote_text}"
            )
        
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data=f"estado_{ticket_number}")]
        ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if original_message_id:
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
    else:
        try:
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo editar el mensaje: {str(e)}")
            estado_message = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            
            if estado_message:
                context.bot_data[f"estado_{ticket_number}"] = estado_message.message_id
                context.bot_data[f"estado_{ticket_number}_chat_id"] = chat_id
    
    return None

async def handle_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la recepci√≥n de un enlace para una solicitud."""
    return ConversationHandler.END

async def handle_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la recepci√≥n de motivos para solicitudes denegadas."""
    return ConversationHandler.END

async def confirm_link(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Confirma el enlace proporcionado para una solicitud."""
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")
    
    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id
    data = query.data
    
    logger.debug(f"üìù Procesando confirmaci√≥n de enlace: {data} por user_id={user_id}")
    
    if data == "cancel_link":
        clear_admin_waiting_response(user_id, chat_id)
        
        texto = (
            f"‚ùå *Subida Cancelada* ‚ùå\n"
            f"La acci√≥n de subir enlace ha sido cancelada."
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Subida de enlace cancelada por user_id={user_id}")
        context.user_data.clear()
        return ConversationHandler.END
    
    return ConversationHandler.END

async def confirm_reason(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la confirmaci√≥n de motivos de denegaci√≥n."""
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")
    
    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id
    data = query.data
    
    logger.debug(f"üìù Procesando confirmaci√≥n de motivo: {data} por user_id={user_id}")
    
    if data == "cancel_reason":
        clear_admin_waiting_response(user_id, chat_id)
        
        texto = (
            f"‚ùå *Denegaci√≥n Cancelada* ‚ùå\n"
            f"La acci√≥n de denegar la solicitud ha sido cancelada."
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Denegaci√≥n cancelada por user_id={user_id}")
        context.user_data.clear()
        return ConversationHandler.END
    
    return ConversationHandler.END

async def handle_user_search(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Maneja la b√∫squeda de usuarios."""
    message = update.message
    if not message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_user_search")
        return ConversationHandler.END
    
    chat_id = message.chat_id
    user_id = message.from_user.id
    search_query = message.text.strip()
    
    logger.debug(f"üîç Procesando b√∫squeda de user_id={user_id}: {search_query}")
    
    search_key = f"{user_id}_{chat_id}"
    if search_key not in pending_searches:
        logger.warning(f"‚ö†Ô∏è No se encontr√≥ b√∫squeda pendiente para {search_key}")
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Error* ‚ùå\nNo hay ninguna b√∫squeda pendiente. Usa /menu para abrir el panel de administraci√≥n.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 60)
            )
        return ConversationHandler.END
    
    search_data = pending_searches[search_key]
    menu_message_id = search_data["message_id"]
    search_type = search_data.get("search_type", "normal")
    
    # Determinar qu√© mensaje de instrucci√≥n eliminar seg√∫n el tipo de b√∫squeda
    if search_type == "infraction_management":
        instruction_msg_id = context.user_data.get("infraction_search_instruction_msg")
        if instruction_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=instruction_msg_id
            )
            if "infraction_search_instruction_msg" in context.user_data:
                del context.user_data["infraction_search_instruction_msg"]
    else:
        instruction_msg_id = context.user_data.get("search_instruction_msg")
        if instruction_msg_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=instruction_msg_id
            )
            if "search_instruction_msg" in context.user_data:
                del context.user_data["search_instruction_msg"]
    
    await safe_bot_method(
        context.bot.delete_message,
        chat_id=chat_id,
        message_id=message.message_id
    )
    
    # Manejar b√∫squeda de infracciones
    if search_type == "infraction_management":
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    results = []
                    
                    if search_query.startswith("@"):
                        username_search = search_query.replace("@", "")
                        c.execute("""
                            SELECT DISTINCT u.user_id, u.username,
                                   COALESCE(pi_stats.incorrect_count, 0) as incorrect_count,
                                   COALESCE(ab_stats.abuse_count, 0) as abuse_count
                            FROM usuarios u
                            LEFT JOIN (
                                SELECT user_id, COUNT(*) as incorrect_count
                                FROM peticiones_incorrectas
                                GROUP BY user_id
                            ) pi_stats ON u.user_id = pi_stats.user_id
                            LEFT JOIN (
                                SELECT user_id, SUM(attempt_count) as abuse_count
                                FROM abuso_botones
                                GROUP BY user_id
                            ) ab_stats ON u.user_id = ab_stats.user_id
                            WHERE u.username ILIKE %s
                            AND (pi_stats.incorrect_count > 0 OR ab_stats.abuse_count > 0)
                            LIMIT 5
                        """, (f"%{username_search}%",))
                        results.extend(c.fetchall())
                    
                    elif search_query.isdigit():
                        user_id_search = int(search_query)
                        c.execute("""
                            SELECT DISTINCT u.user_id, u.username,
                                   COALESCE(pi_stats.incorrect_count, 0) as incorrect_count,
                                   COALESCE(ab_stats.abuse_count, 0) as abuse_count
                            FROM usuarios u
                            LEFT JOIN (
                                SELECT user_id, COUNT(*) as incorrect_count
                                FROM peticiones_incorrectas
                                GROUP BY user_id
                            ) pi_stats ON u.user_id = pi_stats.user_id
                            LEFT JOIN (
                                SELECT user_id, SUM(attempt_count) as abuse_count
                                FROM abuso_botones
                                GROUP BY user_id
                            ) ab_stats ON u.user_id = ab_stats.user_id
                            WHERE u.user_id = %s
                            AND (pi_stats.incorrect_count > 0 OR ab_stats.abuse_count > 0)
                        """, (user_id_search,))
                        results.extend(c.fetchall())
            
            if results:
                texto = (
                    f"üîç *Resultados de B√∫squeda de Infracciones* üîç\n\n"
                    f"üìù **Consulta:** {escape_markdown(search_query)}\n"
                    f"üìä **Infractores encontrados:** {len(results)}\n\n"
                    f"Selecciona un usuario para gestionar:"
                )
                
                keyboard = []
                
                for i, result in enumerate(results, 1):
                    username_display = result['username'] if result['username'] else f"ID: {result['user_id']}"
                    username_clean = username_display.replace('@', '') if username_display.startswith('@') else username_display
                    incorrect_count = result['incorrect_count']
                    abuse_count = result['abuse_count']
                    
                    # Determinar tipo de infracci√≥n principal
                    if incorrect_count > 0 and abuse_count > 0:
                        infraction_type = "‚ö†Ô∏èüö®"
                    elif incorrect_count > 0:
                        infraction_type = "‚ö†Ô∏è"
                    else:
                        infraction_type = "üö®"
                    
                    # Bot√≥n para gestionar
                    keyboard.append([
                        InlineKeyboardButton(
                            f"{infraction_type} {username_clean} (I:{incorrect_count} A:{abuse_count})",
                            callback_data=f"manage_user_infractions_{result['user_id']}"
                        )
                    ])
                
                keyboard.append([
                    InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user"),
                    InlineKeyboardButton("üìä Estad√≠sticas", callback_data="infraction_detailed_stats")
                ])
                keyboard.append([
                    InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                    InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
                ])
            else:
                texto = (
                    f"üîç *B√∫squeda Sin Resultados* üîç\n\n"
                    f"üìù **Consulta:** {escape_markdown(search_query)}\n"
                    f"‚ùå No se encontraron usuarios con infracciones que coincidan.\n\n"
                    f"üí° **Sugerencias:**\n"
                    f"‚Ä¢ Verifica la ortograf√≠a\n"
                    f"‚Ä¢ Usa @ para usernames\n"
                    f"‚Ä¢ Usa n√∫meros para user_id\n"
                    f"‚Ä¢ Solo se muestran usuarios con infracciones\n\n"
                    f"‚è∞ **B√∫squeda realizada:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
                )
                
                keyboard = [
                    [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")],
                    [InlineKeyboardButton("‚ö†Ô∏è Ver Incorrectas", callback_data="view_incorrect_offenders"),
                     InlineKeyboardButton("üö® Ver Abusos", callback_data="view_abuse_offenders")],
                    [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                     InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
                ]
            
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error en b√∫squeda de infracciones: {str(e)}")
            texto = (
                f"üîç *Error en B√∫squeda* üîç\n\n"
                f"‚ùå Error al realizar la b√∫squeda: {escape_markdown(str(e))}\n"
                f"üîß Por favor, intenta de nuevo m√°s tarde.\n\n"
                f"‚è∞ **Intento:** {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="select_infraction_user")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="suspicious_activity"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            context.bot.edit_message_text,
            chat_id=chat_id,
            message_id=menu_message_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, menu_message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        if search_key in pending_searches:
            del pending_searches[search_key]
        
        logger.info(f"‚úÖ B√∫squeda de infracciones completada por user_id={user_id}: {search_query}")
        return ConversationHandler.END
    
    # B√∫squeda normal de usuarios (c√≥digo existente)
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                results = []
                
                if search_query.startswith("@"):
                    username_search = search_query.replace("@", "")
                    c.execute("""
                        SELECT DISTINCT u.user_id, u.username, 
                               COUNT(DISTINCT pr.ticket_number) as pending_requests,
                               COUNT(DISTINCT hs.ticket_number) as processed_requests
                        FROM usuarios u
                        LEFT JOIN peticiones_registradas pr ON u.user_id = pr.user_id
                        LEFT JOIN historial_solicitudes hs ON u.user_id = hs.user_id
                        WHERE u.username ILIKE %s
                        GROUP BY u.user_id, u.username
                        LIMIT 5
                    """, (f"%{username_search}%",))
                    results.extend(c.fetchall())
                
                elif search_query.isdigit():
                    user_id_search = int(search_query)
                    c.execute("""
                        SELECT DISTINCT u.user_id, u.username,
                               COUNT(DISTINCT pr.ticket_number) as pending_requests,
                               COUNT(DISTINCT hs.ticket_number) as processed_requests
                        FROM usuarios u
                        LEFT JOIN peticiones_registradas pr ON u.user_id = pr.user_id
                        LEFT JOIN historial_solicitudes hs ON u.user_id = hs.user_id
                        WHERE u.user_id = %s
                        GROUP BY u.user_id, u.username
                    """, (user_id_search,))
                    results.extend(c.fetchall())
                
                else:
                    c.execute("""
                        SELECT DISTINCT u.user_id, u.username,
                               COUNT(DISTINCT pr.ticket_number) as pending_requests,
                               COUNT(DISTINCT hs.ticket_number) as processed_requests
                        FROM usuarios u
                        LEFT JOIN peticiones_registradas pr ON u.user_id = pr.user_id AND pr.message_text ILIKE %s
                        LEFT JOIN historial_solicitudes hs ON u.user_id = hs.user_id AND hs.message_text ILIKE %s
                        WHERE pr.user_id IS NOT NULL OR hs.user_id IS NOT NULL
                        GROUP BY u.user_id, u.username
                        LIMIT 5
                    """, (f"%{search_query}%", f"%{search_query}%"))
                    results.extend(c.fetchall())
        
        if results:
            texto = f"üîç *Resultados de B√∫squeda* üîç\n\n"
            texto += f"üìù *Consulta:* {escape_markdown(search_query)}\n"
            texto += f"üìä *Usuarios encontrados:* {len(results)}\n\n"
            texto += f"Selecciona un usuario para ver sus solicitudes:"
            
            keyboard = []
            
            for result in results[:5]:
                username = result['username'] or f"User {result['user_id']}"
                username_display = f"@{username}" if not username.startswith("@") else username
                username_clean = username_display.replace("@", "")
                
                # Crear bot√≥n para cada usuario encontrado
                user_button_text = f"üë§ {username_clean} (üìã{result['pending_requests']} ‚úÖ{result['processed_requests']})"
                keyboard.append([
                    InlineKeyboardButton(
                        user_button_text,
                        callback_data=f"user_details_{result['user_id']}"
                    )
                ])
            
            # Botones de navegaci√≥n
            keyboard.append([
                InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                InlineKeyboardButton("üìä Estad√≠sticas", callback_data="detailed_stats")
            ])
            keyboard.append([
                InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
                InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")
            ])
        else:
            texto = (
                f"üîç *B√∫squeda Sin Resultados* üîç\n\n"
                f"üìù *Consulta:* {escape_markdown(search_query)}\n"
                f"‚ùå No se encontraron usuarios que coincidan con la b√∫squeda.\n\n"
                f"üí° *Sugerencias:*\n"
                f"‚Ä¢ Verifica la ortograf√≠a\n"
                f"‚Ä¢ Usa @ para usernames\n"
                f"‚Ä¢ Usa n√∫meros para user_id\n"
                f"‚Ä¢ Usa palabras clave del contenido\n\n"
                f"‚è∞ *B√∫squeda realizada:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
            )
            
            keyboard = [
                [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
                 InlineKeyboardButton("üìä Estad√≠sticas", callback_data="detailed_stats")],
                [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en b√∫squeda de usuarios: {str(e)}")
        texto = (
            f"üîç *Error en B√∫squeda* üîç\n\n"
            f"‚ùå Error al realizar la b√∫squeda: {str(e)}\n"
            f"üîß Por favor, intenta de nuevo m√°s tarde.\n\n"
            f"‚è∞ *Intento:* {datetime.now(SPAIN_TZ).strftime('%H:%M:%S')}"
        )
        
        keyboard = [
            [InlineKeyboardButton("üîç Nueva B√∫squeda", callback_data="search_user"),
             InlineKeyboardButton("üìä Estad√≠sticas", callback_data="detailed_stats")],
            [InlineKeyboardButton("‚Ü©Ô∏è Volver", callback_data="menu_herramientas"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await safe_bot_method(
        context.bot.edit_message_text,
        chat_id=chat_id,
        message_id=menu_message_id,
        text=texto,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    
    menu_activos[(chat_id, menu_message_id)] = {
        "last_activity": datetime.now(SPAIN_TZ),
        "admin_id": user_id,
        "message_content": texto,
        "message_markup": reply_markup,
        "last_page": 1
    }
    
    if search_key in pending_searches:
        del pending_searches[search_key]
    
    logger.info(f"‚úÖ B√∫squeda de usuario completada por user_id={user_id}: {search_query}")
    return ConversationHandler.END

async def select_days(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Permite seleccionar los d√≠as para el horario del bot."""
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")
    
    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id
    
    if user_id not in ADMINISTRATORS:
        texto = "‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores."
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        return ConversationHandler.END
    
    days = context.user_data.get("days", [])
    
    if query.data.startswith("day_"):
        day = query.data.replace("day_", "")
        if day in days:
            days.remove(day)
        else:
            days.append(day)
        context.user_data["days"] = days
    
    keyboard = []
    for day in ["Lunes", "Martes", "Mi√©rcoles", "Jueves", "Viernes", "S√°bado", "Domingo"]:
        marker = "‚úÖ" if day in days else "‚¨ú"
        keyboard.append([InlineKeyboardButton(f"{marker} {day}", callback_data=f"day_{day}")])
    
    keyboard.append([InlineKeyboardButton("‚úÖ Confirmar D√≠as", callback_data="confirm_days")])
    keyboard.append([InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    days_selected = ", ".join(days) if days else "Ninguno"
    texto = (
        f"üìÖ *Seleccionar D√≠as para el Horario* üìÖ\n"
        f"Selecciona los d√≠as en los que el bot aceptar√° solicitudes:\n\n"
        f"üóìÔ∏è *D√≠as seleccionados:* {days_selected}"
    )
    
    await safe_bot_method(
        query.edit_message_text,
        text=texto,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    
    menu_activos[(chat_id, message_id)] = {
        "last_activity": datetime.now(SPAIN_TZ),
        "admin_id": user_id,
        "message_content": texto,
        "message_markup": reply_markup,
        "last_page": 1
    }
    return SELECT_DAYS

async def confirm_days(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Confirma los d√≠as seleccionados y solicita la hora de inicio."""
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")

    chat_id = query.message.chat_id
    message_id = query.message.message_id
    user_id = query.from_user.id

    if user_id not in ADMINISTRATORS:
        texto = "‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores."
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        return ConversationHandler.END

    days = context.user_data.get("days", [])
    if not days:
        await query.answer("‚ö†Ô∏è Debes seleccionar al menos un d√≠a", show_alert=True)
        return SELECT_DAYS

    days_str = ", ".join(days)
    texto = (
        f"üìÖ *D√≠as Seleccionados* üìÖ\n"
        f"üìÜ *D√≠as:* {days_str}\n\n"
        f"üïî *Ahora escribe la hora de inicio*\n"
        f"Formato: HH:MM (ejemplo: 09:00)"
    )
    keyboard = [
        [InlineKeyboardButton("‚Ü©Ô∏è Volver a D√≠as", callback_data="edit_days"),
         InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await safe_bot_method(
        query.edit_message_text,
        text=texto,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )
    
    menu_activos[(chat_id, message_id)] = {
        "last_activity": datetime.now(SPAIN_TZ),
        "admin_id": user_id,
        "message_content": texto,
        "message_markup": reply_markup,
        "last_page": 1
    }
    
    context.user_data["question_message_id"] = message_id

    logger.info(f"‚úÖ D√≠as confirmados por user_id={user_id}: {days}")
    return INPUT_START_HOUR

async def input_start_hour(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Procesa la hora de inicio ingresada."""
    message = update.message
    if not message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en input_start_hour")
        return ConversationHandler.END
        
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        logger.warning(f"‚ö†Ô∏è Usuario no autorizado {user_id} intentando configurar horario")
        return ConversationHandler.END
    
    logger.info(f"üìù Procesando hora de inicio de user_id={user_id}: '{message.text}'")
    
    try:
        start_hour = datetime.strptime(message.text.strip(), "%H:%M").hour
        context.user_data["start_hour"] = start_hour
        logger.info(f"‚úÖ Hora de inicio parseada correctamente: {start_hour}")
        
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message.message_id
        )
        
        question_message_id = context.user_data.get("question_message_id")
        if question_message_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=question_message_id
            )
            del context.user_data["question_message_id"]
        
        days_str = ", ".join(context.user_data.get("days", []))
        texto = (
            f"üìÖ *Configuraci√≥n de Horario* üìÖ\n"
            f"üìÜ *D√≠as:* {days_str}\n"
            f"üïê *Hora de inicio:* {start_hour:02d}:00\n\n"
            f"üïî *Ahora escribe la hora de fin*\n"
            f"Formato: HH:MM (ejemplo: 17:00)"
        )
        
        sent_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=texto,
            parse_mode="Markdown"
        )
        
        if sent_message:
            context.user_data["config_message_id"] = sent_message.message_id
        
        logger.info(f"‚úÖ Hora de inicio {start_hour:02d}:00 configurada por user_id={user_id}")
        return INPUT_END_HOUR
        
    except ValueError:
        logger.warning(f"‚ö†Ô∏è Formato de hora inv√°lido de user_id={user_id}: '{message.text}'")
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ö†Ô∏è *Formato inv√°lido* ‚ö†Ô∏è\nUsa el formato HH:MM (ejemplo: 09:00).",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 10)
            )
        
        # Eliminar el mensaje del usuario con formato incorrecto
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message.message_id
        )
        
        return INPUT_START_HOUR

async def input_end_hour(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Procesa la hora de fin ingresada y muestra confirmaci√≥n final."""
    message = update.message
    if not message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en input_end_hour")
        return ConversationHandler.END
        
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        logger.warning(f"‚ö†Ô∏è Usuario no autorizado {user_id} intentando configurar horario")
        return ConversationHandler.END
    
    logger.info(f"üìù Procesando hora de fin de user_id={user_id}: '{message.text}'")
    
    try:
        end_hour = datetime.strptime(message.text.strip(), "%H:%M").hour
        context.user_data["end_hour"] = end_hour
        logger.info(f"‚úÖ Hora de fin parseada correctamente: {end_hour}")
        
        config_message_id = context.user_data.get("config_message_id")
        if config_message_id:
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=config_message_id
            )
            del context.user_data["config_message_id"]
        
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message.message_id
        )
        
        days = ", ".join(context.user_data.get("days", []))
        start_hour = context.user_data.get("start_hour")
        
        texto = (
            f"üìÖ *Confirmar Horario* üìÖ\n"
            f"üìÜ *D√≠as:* {days}\n"
            f"üïí *Horario:* de {start_hour:02d}:00 a {end_hour:02d}:00\n\n"
            f"¬øConfirmas este horario?"
        )
        
        keyboard = [
            [InlineKeyboardButton("‚úÖ Guardar", callback_data="save_schedule"),
             InlineKeyboardButton("‚úèÔ∏è Corregir", callback_data="edit_days")],
            [InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_schedule")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        sent_message = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        if sent_message:
            menu_activos[(chat_id, sent_message.message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
        
        logger.info(f"‚úÖ Hora de fin {end_hour:02d}:00 configurada por user_id={user_id}")
        return FINAL_CONFIRMATION
        
    except ValueError:
        logger.warning(f"‚ö†Ô∏è Formato de hora inv√°lido de user_id={user_id}: '{message.text}'")
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ö†Ô∏è *Formato inv√°lido* ‚ö†Ô∏è\nUsa el formato HH:MM (ejemplo: 17:00).",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 10)
            )
        
        # Eliminar el mensaje del usuario con formato incorrecto
        await safe_bot_method(
            context.bot.delete_message,
            chat_id=chat_id,
            message_id=message.message_id
        )
        
        return INPUT_END_HOUR

async def final_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Confirma el horario configurado."""
    query = update.callback_query
    try:
        await query.answer()
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo responder al callback query: {str(e)}")
    
    chat_id = query.message.chat_id
    message_id = query.message.message_id
    data = query.data
    
    if data == "edit_days":
        return await select_days(update, context)
    
    if data == "save_schedule":
        days = context.user_data.get("days", [])
        start_hour = context.user_data.get("start_hour")
        end_hour = context.user_data.get("end_hour")
        
        try:
            set_bot_schedule(days, start_hour, end_hour)
            
            if automatic_notifications_enabled:
                schedule_notifications(context.application)
            
            texto = (
                f"‚úÖ *Horario Guardado* ‚úÖ\n"
                f"üìÜ *D√≠as:* {', '.join(days)}\n"
                f"üïí *Horario:* de {start_hour:02d}:00 a {end_hour:02d}:00\n"
                f"üîî *Notificaciones:* {'Programadas' if automatic_notifications_enabled else 'Deshabilitadas'}"
            )
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": query.from_user.id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            
            context.user_data.clear()
            logger.info(f"‚úÖ Horario guardado por user_id={query.from_user.id}")
            return ConversationHandler.END
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error al guardar horario: {str(e)}")
            texto = "‚ùå *Error* ‚ùå\nNo se pudo guardar el horario. Intenta de nuevo."
            keyboard = [
                [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
                 InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await safe_bot_method(
                query.edit_message_text,
                text=texto,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            
            menu_activos[(chat_id, message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": query.from_user.id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            return ConversationHandler.END
    
    if data == "cancel_schedule":
        context.user_data.clear()
        texto = (
            f"‚ùå *Configuraci√≥n Cancelada* ‚ùå\n"
            f"La configuraci√≥n del horario ha sido cancelada."
        )
        keyboard = [
            [InlineKeyboardButton("‚Ü©Ô∏è Volver al Men√∫", callback_data="menu_principal"),
             InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await safe_bot_method(
            query.edit_message_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        menu_activos[(chat_id, message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": query.from_user.id,
            "message_content": texto,
            "message_markup": reply_markup,
            "last_page": 1
        }
        
        logger.info(f"‚úÖ Configuraci√≥n de horario cancelada por user_id={query.from_user.id}")
        return ConversationHandler.END
    
    return ConversationHandler.END

async def handle_maintenance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /maintenance para activar/desactivar el modo de mantenimiento."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_maintenance")
        return
    
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return
    
    args = context.args
    if not args:
        maintenance = get_maintenance_mode()
        status = "üî¥ Activo" if maintenance and maintenance.get("is_active") else "üü¢ Inactivo"
        message_text = maintenance.get("message", "No configurado") if maintenance else "No configurado"
        scheduled_until = maintenance.get("scheduled_until", "No programado") if maintenance else "No programado"
        
        # Mostrar panel con botones
        keyboard = [
            [InlineKeyboardButton("üî¥ Activar Ahora", callback_data="activate_maintenance"),
             InlineKeyboardButton("üü¢ Desactivar", callback_data="deactivate_maintenance")],
            [InlineKeyboardButton("üìÖ Programar Mantenimiento", callback_data="schedule_maintenance"),
             InlineKeyboardButton("‚è∞ Ver Programaci√≥n", callback_data="view_maintenance_schedule")],
            [InlineKeyboardButton("‚úèÔ∏è Ver Mensaje", callback_data="view_maintenance_msg"),
             InlineKeyboardButton("üóëÔ∏è Cancelar Programado", callback_data="cancel_scheduled_maintenance")],
            [InlineKeyboardButton("‚ùå Cerrar Panel", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        texto = (
            f"üöß *Panel de Mantenimiento* üöß\n\n"
            f"üìä *Estado:* {status}\n"
            f"üìù *Mensaje:* {escape_markdown(message_text[:50] + '...' if len(message_text) > 50 else message_text)}\n"
            f"‚è∞ *Programado hasta:* {scheduled_until}\n\n"
            f"üéõÔ∏è **Opciones disponibles:**\n"
            f"‚Ä¢ Control inmediato (activar/desactivar)\n"
            f"‚Ä¢ Programaci√≥n con fechas espec√≠ficas\n"
            f"‚Ä¢ Mensajes personalizados\n"
            f"‚Ä¢ Auto-eliminaci√≥n al finalizar\n\n"
            f"üí° **Comandos alternativos:**\n"
            f"`/mantenimiento on [mensaje]` - Activar\n"
            f"`/mantenimiento off` - Desactivar"
        )
        
        sent_message = await safe_bot_method(
            message.reply_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        if sent_message:
            menu_activos[(chat_id, sent_message.message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 900)
            )
        return
    
    action = args[0].lower()
    custom_message = " ".join(args[1:]) if len(args) > 1 else None
    
    if action == "on":
        message_text = custom_message or (
            "‚ö†Ô∏è El bot est√° en mantenimiento. "
            "Intenta de nuevo m√°s tarde. *Equipo de Administraci√≥n EntresHijos*, "
            "disculpen las molestias, estaremos de vuelta lo antes posible."
        )
        set_maintenance_mode(True, message_text)
        
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=True,
            message=message_text
        )
        
        texto = f"üî¥ *Modo de Mantenimiento Activado* üî¥\n\nNotificaci√≥n enviada a todos los canales."
        
    elif action == "off":
        set_maintenance_mode(False)
        
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=False
        )
        
        texto = f"üü¢ *Modo de Mantenimiento Desactivado* üü¢\n\nNotificaci√≥n enviada a todos los canales."

    else:
        texto = "‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\nUsa: /maintenance [on|off] [mensaje opcional]"

    sent_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        parse_mode="Markdown"
    )

    if sent_message:
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )

    logger.info(f"‚úÖ Comando /maintenance ejecutado por user_id={user_id}: {action}")

async def handle_mantenimiento(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /mantenimiento (versi√≥n mejorada con botones)."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_mantenimiento")
        return
    
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return
    
    args = context.args
    if not args:
        # Mostrar panel completo con botones
        maintenance = get_maintenance_mode()
        status = "üî¥ Activo" if maintenance and maintenance.get("is_active") else "üü¢ Inactivo"
        message_text = maintenance.get("message", "No configurado") if maintenance else "No configurado"
        
        keyboard = [
            [InlineKeyboardButton("üî¥ Activar Ahora", callback_data="activate_maintenance"),
             InlineKeyboardButton("üü¢ Desactivar", callback_data="deactivate_maintenance")],
            [InlineKeyboardButton("üìÖ Programar Mantenimiento", callback_data="schedule_maintenance"),
             InlineKeyboardButton("‚è∞ Ver Programaci√≥n", callback_data="view_maintenance_schedule")],
            [InlineKeyboardButton("‚úèÔ∏è Cambiar Mensaje", callback_data="view_maintenance_msg"),
             InlineKeyboardButton("üóëÔ∏è Cancelar Programado", callback_data="cancel_scheduled_maintenance")],
            [InlineKeyboardButton("‚ùå Cerrar Panel", callback_data="menu_close")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        texto = (
            f"üöß *Panel de Mantenimiento EntresHijos* üöß\n\n"
            f"üìä *Estado Actual:* {status}\n"
            f"üìù *Mensaje:* {escape_markdown(message_text[:50] + '...' if len(message_text) > 50 else message_text)}\n\n"
            f"üéõÔ∏è **Funcionalidades:**\n"
            f"‚Ä¢ ‚ö° Control inmediato (activar/desactivar)\n"
            f"‚Ä¢ üìÖ Programaci√≥n con fechas y horas espec√≠ficas\n"
            f"‚Ä¢ üìù Mensajes personalizados para usuarios\n"
            f"‚Ä¢ üóëÔ∏è Auto-eliminaci√≥n de mensajes al finalizar\n"
            f"‚Ä¢ üì¢ Notificaci√≥n profesional de fin (5 min)\n\n"
            f"üí° **Comandos r√°pidos:**\n"
            f"`/mantenimiento on [mensaje]` - Activar con mensaje\n"
            f"`/mantenimiento off` - Desactivar y limpiar\n\n"
            f"Selecciona una opci√≥n:"
        )
        
        sent_message = await safe_bot_method(
            message.reply_text,
            text=texto,
            reply_markup=reply_markup,
            parse_mode="Markdown"
        )
        
        if sent_message:
            menu_activos[(chat_id, sent_message.message_id)] = {
                "last_activity": datetime.now(SPAIN_TZ),
                "admin_id": user_id,
                "message_content": texto,
                "message_markup": reply_markup,
                "last_page": 1
            }
            context.application.create_task(
                auto_delete_message(context, chat_id, sent_message.message_id, 900)
            )
        return
    
    action = args[0].lower()
    custom_message = " ".join(args[1:]) if len(args) > 1 else None
    
    if action == "on":
        message_text = custom_message or (
            "‚ö†Ô∏è El bot est√° en mantenimiento. "
            "Intenta de nuevo m√°s tarde. *Equipo de Administraci√≥n EntresHijos*, "
            "disculpen las molestias, estaremos de vuelta lo antes posible."
        )
        set_maintenance_mode(True, message_text)
        
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=True,
            message=message_text
        )
        
        texto = (
            f"üî¥ *Modo de Mantenimiento Activado* üî¥\n\n"
            f"‚úÖ Notificaci√≥n enviada a todos los canales\n"
            f"üóëÔ∏è Los mensajes se eliminar√°n autom√°ticamente al finalizar\n"
            f"üìù Mensaje: {escape_markdown(message_text[:100] + '...' if len(message_text) > 100 else message_text)}\n"
            f"‚è∞ *Activado:* {get_spain_time()}"
        )
        
    elif action == "off":
        set_maintenance_mode(False)
        
        await send_notification_to_all_channels(
            context,
            "maintenance",
            is_active=False
        )
        
        texto = (
            f"üü¢ *Modo de Mantenimiento Desactivado* üü¢\n\n"
            f"‚úÖ Notificaci√≥n de fin enviada a todos los canales\n"
            f"üóëÔ∏è Mensajes de mantenimiento eliminados autom√°ticamente\n"
            f"üì¢ Mensaje de fin se auto-elimina en 5 minutos\n"
            f"‚è∞ *Desactivado:* {get_spain_time()}"
        )

    else:
        texto = "‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\nUsa: /mantenimiento [on|off] [mensaje opcional]"

    sent_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        parse_mode="Markdown"
    )

    if sent_message:
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )

    logger.info(f"‚úÖ Comando /mantenimiento ejecutado por user_id={user_id}: {action}")

async def handle_restar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /restar para reducir solicitudes de un usuario."""
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id

    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    args = context.args
    if len(args) != 2:
        error_message = await safe_bot_method(
            message.reply_text,
            text=(
                f"‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\n"
                f"Formato: /restar @username [n√∫mero]\n"
                f"Ejemplo: /restar @usuario 1"
            ),
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    username = args[0].lstrip('@')
    try:
        amount = int(args[1])
        if amount <= 0:
            raise ValueError
    except ValueError:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ö†Ô∏è *Error* ‚ö†Ô∏è\nEl n√∫mero debe ser un entero positivo.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    user_id_to_reduce = get_user_id_by_username(username)        # ‚úÖ sin @
    if not user_id_to_reduce:
        error_message = await safe_bot_method(
            message.reply_text,
            text=f"‚ö†Ô∏è *Error* ‚ö†Ô∏è\nNo se encontr√≥ al usuario @{username}.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    user_data = get_peticiones_por_usuario(user_id_to_reduce)
    if not user_data:
        error_message = await safe_bot_method(
            message.reply_text,
            text=f"‚ö†Ô∏è *Error* ‚ö†Ô∏è\nEl usuario @{username} no tiene solicitudes registradas.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    new_count = max(0, user_data["count"] - amount)
    set_peticiones_por_usuario(user_id_to_reduce, new_count, user_data["chat_id"], user_data["username"], user_data["last_reset"])

    username_escaped = escape_markdown(f"@{username}", preserve_username=True)
    texto = (
        f"‚úÖ *Solicitudes Reducidas* ‚úÖ\n"
        f"Usuario: {username_escaped}\n"
        f"Solicitudes restantes: {new_count}/2"
    )

    sent_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        parse_mode="Markdown"
    )

    if sent_message:
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )

    logger.info(f"‚úÖ Solicitudes reducidas para @{username} por {amount}. Nuevo conteo: {new_count}")

async def handle_dar_puntos_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    message = update.message
    chat_id = message.chat_id
    admin_id = message.from_user.id

    if admin_id not in ADMINISTRATORS:
        err = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
        return

    args = context.args
    if len(args) < 3:
        err = await safe_bot_method(
            message.reply_text,
            text=("‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\n\n"
                  "**Formato:**\n"
                  "`/dar_puntos @username cantidad motivo`\n\n"
                  "**Ejemplo:**\n"
                  "`/dar_puntos @usuario 100 Buen aporte a la comunidad`"),
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
        return

    username_input = args[0]
    username_norm = normalize_username(username_input)
    username_display = f"@{username_norm}"

    try:
        cantidad = int(args[1])
        if cantidad <= 0:
            raise ValueError("Cantidad debe ser positiva")
    except ValueError:
        err = await safe_bot_method(
            message.reply_text,
            text="‚ö†Ô∏è *Error* ‚ö†Ô∏è\nLa cantidad debe ser un n√∫mero entero positivo.",
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
        return

    motivo = " ".join(args[2:]).strip() or "sin motivo"

    try:
        with get_db_connection() as conn:
            target_user_id = find_user_id_by_username_db(conn, username_norm)

        # Fallback opcional a Telegram si no est√° en BD
        if not target_user_id:
            target_user_id = await try_resolve_user_id_via_telegram(context, username_norm)

        if not target_user_id:
            err = await safe_bot_method(
                message.reply_text,
                text=(f"‚ö†Ô∏è *Usuario no encontrado* ‚ö†Ô∏è\n"
                      f"No se encontr√≥ {username_display}.\n\n"
                      "üëâ P√≠dele que env√≠e un mensaje en el grupo o escribe `/sincronizar @usuario` "
                      "para registrarlo primero."),
                parse_mode="Markdown"
            )
            if err:
                context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
            return

        # Otorgar puntos
        otorgar_puntos(target_user_id, username_display, cantidad, "manual", motivo, admin_id=admin_id)

        puntos_info = obtener_puntos_usuario(target_user_id)
        nivel_emoji = NIVELES.get(puntos_info["nivel"], NIVELES["bronce"])["emoji"]

        ok = await safe_bot_method(
            message.reply_text,
            text=("‚úÖ *Puntos Otorgados Exitosamente* ‚úÖ\n\n"
                  f"üë§ **Usuario:** {username_display}\n"
                  f"üí∞ **Puntos otorgados:** +{cantidad:,} pts\n"
                  f"üìù **Motivo:** {motivo}\n\n"
                  "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                  "üìä **Estado Actual:**\n"
                  f"{nivel_emoji} **Nivel:** {puntos_info['nivel'].capitalize()}\n"
                  f"üíé **Total de puntos:** {puntos_info['puntos']:,} pts\n\n"
                  "‚ú® *Transacci√≥n registrada correctamente*"),
            parse_mode="Markdown"
        )
        if ok:
            context.application.create_task(auto_delete_message(context, chat_id, ok.message_id, 300))

        logger.info(f"‚úÖ Admin {admin_id} otorg√≥ {cantidad} puntos a {username_display} ({target_user_id})")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en /dar_puntos: {str(e)}")
        err = await safe_bot_method(
            message.reply_text,
            text=f"‚ùå *Error* ‚ùå\nOcurri√≥ un error al otorgar puntos: {str(e)}",
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))

async def handle_tiempo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /tiempo para mostrar el horario actual."""
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id

    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    schedule = get_bot_schedule()

    if not schedule:
        schedule_text = (
            f"‚ö†Ô∏è *Horario no configurado* ‚ö†Ô∏è\n"
            f"El bot actualmente funciona 24/7.\n"
            f"¬øDeseas configurar un horario espec√≠fico?"
        )
        keyboard = [
            [InlineKeyboardButton("‚öôÔ∏è Configurar Horario", callback_data="edit_days")],
            [InlineKeyboardButton("üîî Config. Notificaciones", callback_data="notification_config")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]
    else:
        days_str = ", ".join(schedule['days_of_week'])
        is_active = is_within_schedule()
        notifications_status = "üü¢ Habilitadas" if automatic_notifications_enabled else "üî¥ Deshabilitadas"
        schedule_text = (
            f"üïê *Horario Actual del Bot* üïê\n"
            f"üìÖ *D√≠as Activos:* {days_str}\n"
            f"üïí *Hora de Inicio:* {schedule['start_hour']:02d}:00\n"
            f"üïï *Hora de Fin:* {schedule['end_hour']:02d}:00\n"
            f"üåç *Zona Horaria:* Europe/Madrid\n"
            f"üìä *Estado Actual:* {'üü¢ Activo' if is_active else 'üî¥ Inactivo'}\n"
            f"üîî *Notificaciones:* {notifications_status}"
        )
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è Modificar", callback_data="edit_days"),
             InlineKeyboardButton("üóëÔ∏è Eliminar", callback_data="reset_schedule")],
            [InlineKeyboardButton("üîî Notificaciones", callback_data="notification_config")],
            [InlineKeyboardButton("‚ùå Cerrar", callback_data="menu_close")]
        ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    sent_message = await safe_bot_method(
        message.reply_text,
        text=schedule_text,
        reply_markup=reply_markup,
        parse_mode="Markdown"
    )

    if sent_message:
        menu_activos[(chat_id, sent_message.message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": schedule_text,
            "message_markup": reply_markup,
            "last_page": 1
        }
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )

    logger.info(f"‚úÖ Comando /tiempo ejecutado por user_id={user_id}")

async def cleanup_old_menus(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Limpia men√∫s inactivos despu√©s de un per√≠odo de tiempo."""
    current_time = datetime.now(SPAIN_TZ)
    inactive_menus = []
    for key, menu_data in list(menu_activos.items()):
        chat_id, message_id = key
        last_activity = menu_data["last_activity"]
        if (current_time - last_activity).total_seconds() >= 900:
            inactive_menus.append((chat_id, message_id))
            await safe_bot_method(
                context.bot.delete_message,
                chat_id=chat_id,
                message_id=message_id
            )
    for chat_id, message_id in inactive_menus:
        if (chat_id, message_id) in menu_activos:
            del menu_activos[(chat_id, message_id)]
    logger.info(f"‚úÖ Limpieza de men√∫s inactivos completada. Eliminados: {len(inactive_menus)} men√∫s")

async def clean_pending_data():
    """Limpia datos pendientes expirados (enlaces y motivos)."""
    while True:
        current_time = datetime.now(SPAIN_TZ)
        expired_keys = []
        for key, data in list(pending_links.items()):
            if (current_time - data["timestamp"]).total_seconds() >= 3600:
                expired_keys.append(key)
        for key in expired_keys:
            del pending_links[key]
            logger.info(f"üóëÔ∏è Eliminado enlace pendiente: {key}")

        expired_keys = []
        for key, data in list(pending_reasons.items()):
            if (current_time - data["timestamp"]).total_seconds() >= 3600:
                expired_keys.append(key)
        for key in expired_keys:
            del pending_reasons[key]
            logger.info(f"üóëÔ∏è Eliminado motivo pendiente: {key}")

        expired_keys = []
        for key, data in list(pending_deletions.items()):
            if (current_time - data["timestamp"]).total_seconds() >= 3600:
                expired_keys.append(key)
        for key in expired_keys:
            del pending_deletions[key]
            logger.info(f"üóëÔ∏è Eliminada eliminaci√≥n pendiente: {key}")

        expired_keys = []
        for key, data in list(pending_searches.items()):
            if (current_time - data["timestamp"]).total_seconds() >= 1800:
                expired_keys.append(key)
        for key in expired_keys:
            del pending_searches[key]
            logger.info(f"üóëÔ∏è Eliminada b√∫squeda pendiente: {key}")
            
        expired_keys = []
        for key, data in list(admin_waiting_responses.items()):
            if (current_time - data["timestamp"]).total_seconds() >= 1800:
                expired_keys.append(key)
        for key in expired_keys:
            del admin_waiting_responses[key]
            logger.info(f"üóëÔ∏è Eliminada respuesta de admin pendiente: {key}")

        await asyncio.sleep(3600)

def get_old_requests():
    """Obtiene solicitudes pendientes con m√°s de 20 d√≠as de antig√ºedad."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                cutoff_date = datetime.now(SPAIN_TZ) - timedelta(days=20)
                c.execute("""
                    SELECT ticket_number, chat_id, username, user_id, message_text, 
                           chat_title, timestamp, has_attachment, photo_file_id
                    FROM peticiones_registradas 
                    WHERE timestamp < %s
                    ORDER BY timestamp ASC
                """, (cutoff_date,))
                return [dict(row) for row in c.fetchall()]
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al obtener solicitudes antiguas: {str(e)}")
        return []

def parse_date_safely(date_input):
    """Parsea una fecha de forma segura."""
    try:
        if isinstance(date_input, datetime):
            # Manejar datetime naive y timezone-aware
            if date_input.tzinfo is None:
                return SPAIN_TZ.localize(date_input)
            else:
                return date_input.astimezone(SPAIN_TZ)
        elif isinstance(date_input, str):
            parsed_date = datetime.fromisoformat(date_input)
            if parsed_date.tzinfo is None:
                return SPAIN_TZ.localize(parsed_date)
            else:
                return parsed_date.astimezone(SPAIN_TZ)
        else:
            # Si no es datetime ni string, usar fecha actual
            logger.warning(f"‚ö†Ô∏è Tipo de fecha no reconocido: {type(date_input)}, usando fecha actual")
            return datetime.now(SPAIN_TZ)
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al parsear fecha: {str(e)}")
        return datetime.now(SPAIN_TZ)

def move_to_history(ticket_number, data):
    """Mueve una solicitud al historial."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("""
                    INSERT INTO historial_solicitudes
                    (ticket_number, chat_id, username, user_id, message_text, chat_title,
                     estado, fecha_gestion, admin_username, url, reason, has_attachment, photo_file_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON CONFLICT (ticket_number) DO UPDATE SET
                    estado = EXCLUDED.estado, fecha_gestion = EXCLUDED.fecha_gestion,
                    admin_username = EXCLUDED.admin_username, reason = EXCLUDED.reason
                """, (
                    ticket_number, data["chat_id"], data["username"], data.get("user_id"),
                    data["message_text"], data["chat_title"], data["estado"],
                    data["fecha_gestion"], data["admin_username"], data.get("url"),
                    data.get("reason"), data.get("has_attachment", False), data.get("photo_file_id")
                ))
                conn.commit()

        # Otorgar puntos autom√°ticamente si est√° habilitado
        if SISTEMA_PUNTOS_DISPONIBLE and data.get("user_id") and data.get("username"):
            estado = data["estado"].lower()
            user_id = data["user_id"]
            username = data["username"]

            if estado == "subido":
                # 50 puntos por solicitud aprobada
                puntos = 50
                descripcion = f"Solicitud #{ticket_number} aprobada"
                otorgar_puntos(user_id, username, puntos, "solicitud_aprobada", descripcion)
                logger.info(f"‚úÖ {puntos} puntos otorgados a @{username} por solicitud aprobada")

        logger.info(f"‚úÖ Ticket #{ticket_number} movido al historial")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al mover ticket #{ticket_number} al historial: {str(e)}")

def delete_pending_request(ticket_number):
    """Elimina una solicitud pendiente."""
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("DELETE FROM peticiones_registradas WHERE ticket_number = %s", (ticket_number,))
                c.execute("DELETE FROM cache WHERE key = %s", (f"peticion_{ticket_number}",))
                conn.commit()
        logger.info(f"‚úÖ Ticket #{ticket_number} eliminado de pendientes")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error al eliminar ticket #{ticket_number} de pendientes: {str(e)}")

async def automatic_cleanup(context: ContextTypes.DEFAULT_TYPE):
    """Ejecuta la limpieza autom√°tica de solicitudes antiguas."""
    logger.info("üßπ Iniciando limpieza autom√°tica de solicitudes antiguas...")
    
    try:
        old_requests = get_old_requests()
        
        if not old_requests:
            logger.info("‚ÑπÔ∏è No hay solicitudes antiguas para limpiar")
            return
        
        processed = 0
        errors = 0
        
        for request in old_requests:
            try:
                ticket_number = request["ticket_number"]
                chat_id = request["chat_id"]
                username = request["username"]
                user_id = request.get("user_id")
                message_text = request["message_text"]
                chat_title = request["chat_title"]
                timestamp = request["timestamp"]
                has_attachment = request.get("has_attachment", False)
                photo_file_id = request.get("photo_file_id")
                
                # Calcular d√≠as de antig√ºedad
                if isinstance(timestamp, datetime):
                    # Asegurar que el timestamp tenga timezone
                    if timestamp.tzinfo is None:
                        request_date = SPAIN_TZ.localize(timestamp)
                    else:
                        request_date = timestamp.astimezone(SPAIN_TZ)
                else:
                    request_date = parse_date_safely(timestamp)
                
                # Calcular d√≠as de forma segura
                try:
                    days_old = (datetime.now(SPAIN_TZ) - request_date).days
                except TypeError:
                    # Si a√∫n hay problemas, usar timestamp_tz si est√° disponible
                    logger.warning(f"‚ö†Ô∏è Problema de timezone en ticket #{ticket_number}, usando timestamp_tz")
                    try:
                        with get_db_connection() as conn:
                            with conn.cursor() as c:
                                c.execute("SELECT timestamp_tz FROM peticiones_registradas WHERE ticket_number = %s", (ticket_number,))
                                result = c.fetchone()
                                if result and result[0]:
                                    request_date = result[0].astimezone(SPAIN_TZ)
                                    days_old = (datetime.now(SPAIN_TZ) - request_date).days
                                else:
                                    # Como √∫ltimo recurso, asumir que es muy antigua
                                    days_old = 25
                    except Exception as tz_error:
                        logger.error(f"‚ö†Ô∏è Error cr√≠tico con timezone en ticket #{ticket_number}: {str(tz_error)}")
                        # Saltar este ticket para evitar crash
                        continue
                
                logger.info(f"üîç Procesando ticket #{ticket_number} - {days_old} d√≠as de antig√ºedad")
                
                # Verificar que realmente sea antigua (doble verificaci√≥n)
                if days_old < 20:
                    logger.info(f"‚è≠Ô∏è Saltando ticket #{ticket_number} - solo {days_old} d√≠as de antig√ºedad")
                    continue
                
                # Preparar variables para evitar problemas con f-strings
                username_clean = username.replace("@", "") if username else "Usuario"
                attachment_text = "S√≠" if has_attachment else "No"
                fecha_original = request_date.strftime('%d/%m/%Y %H:%M:%S')
                
                # Mover al historial
                move_to_history(ticket_number, {
                    "chat_id": chat_id,
                    "username": username,
                    "user_id": user_id,
                    "message_text": message_text,
                    "chat_title": chat_title,
                    "estado": "eliminada_automaticamente",
                    "fecha_gestion": datetime.now(SPAIN_TZ),
                    "admin_username": "Sistema Autom√°tico",
                    "reason": f"Eliminado autom√°ticamente por antig√ºedad ({days_old} d√≠as). Fecha original: {fecha_original}",
                    "has_attachment": has_attachment,
                    "photo_file_id": photo_file_id
                })
                
                # Eliminar de pendientes
                delete_pending_request(ticket_number)
                
                # Eliminar mensaje de confirmaci√≥n si existe
                await delete_confirmation_message(context, ticket_number)
                
                # Notificar al usuario en el grupo original
                canal_info = CANALES_PETICIONES.get(chat_id)
                if canal_info:
                    username_escaped = escape_markdown(username, preserve_username=True)
                    message_text_escaped = escape_markdown(message_text)
                    chat_title_escaped = escape_markdown(chat_title)
                    
                    user_notification = (
                        f"üìå *Notificaci√≥n de Eliminaci√≥n de Solicitud* üìå\n\n"
                        f"Estimado/a {username_escaped},\n\n"
                        f"Lamentamos informarte que tu solicitud con el ticket #{ticket_number} ha sido eliminada autom√°ticamente, "
                        f"ya que ha superado los 20 d√≠as sin resoluci√≥n. üòî\n\n"
                        f"¬°No te preocupes! Puedes volver a enviar tu solicitud en unos d√≠as o meses si lo deseas. "
                        f"Esto nos ayuda a optimizar la gesti√≥n del bot y brindar m√°s oportunidades a todos los usuarios. üåü\n\n"
                        f"**Detalles de la solicitud:**\n"
                        f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
                        f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                        f"üìç *Grupo:* {chat_title_escaped}\n"
                        f"‚è∞ *Fecha original:* {fecha_original}\n"
                        f"üìé *Adjunto:* {attachment_text}\n"
                        f"üìù *Motivo:* Eliminado autom√°ticamente por antig√ºedad ({days_old} d√≠as). "
                        f"Puedes volver a solicitarlo cuando desees.\n\n"
                        f"Gracias por tu comprensi√≥n y por ser parte de nuestra comunidad. üíô\n\n"
                        f"Atentamente,\n"
                        f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
                    )
                    
                    await safe_bot_method(
                        context.bot.send_message,
                        chat_id=canal_info["chat_id"],
                        text=user_notification,
                        message_thread_id=canal_info["thread_id"],
                        parse_mode="Markdown"
                    )
                
                # Notificar a administradores
                username_escaped = escape_markdown(username, preserve_username=True)
                message_text_escaped = escape_markdown(message_text)
                chat_title_escaped = escape_markdown(chat_title)
                
                admin_notification = (
                    f"üîî *Eliminaci√≥n Autom√°tica - Reporte* üîî\n\n"
                    f"üìä **Detalles de la solicitud procesada:**\n"
                    f"üéüÔ∏è *Ticket:* #{ticket_number}\n"
                    f"üë§ *Usuario:* {username_escaped}\n"
                    f"‚úâÔ∏è *Mensaje:* {message_text_escaped}\n"
                    f"üìç *Grupo:* {chat_title_escaped}\n"
                    f"‚è∞ *Fecha original:* {fecha_original}\n"
                    f"üìé *Adjunto:* {attachment_text}\n"
                    f"üìù *Motivo:* Eliminado autom√°ticamente por antig√ºedad ({days_old} d√≠as)\n\n"
                    f"‚úÖ Usuario y grupo notificados correctamente.\n\n"
                    f"Atentamente,\n"
                    f"*Equipo de Administraci√≥n EntresHijos* üëÆ‚Äç‚ôÄÔ∏è"
                )
                
                await safe_bot_method(
                    context.bot.send_message,
                    chat_id=GROUP_DESTINO,
                    text=admin_notification,
                    parse_mode="Markdown"
                )
                
                processed += 1
                await asyncio.sleep(1)
                
            except Exception as e:
                errors += 1
                logger.error(f"‚ùå Error procesando ticket #{ticket_number}: {str(e)}")
                continue
        
        # Enviar resumen final a administradores si se procesaron solicitudes
        if processed > 0:
            summary_message = (
                f"üßπ *Resumen de Limpieza Autom√°tica* üßπ\n\n"
                f"üìä **Resultados:**\n"
                f"‚úÖ *Procesadas:* {processed}\n"
                f"‚ùå *Errores:* {errors}\n"
                f"‚è∞ *Completado:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                f"üìù *Criterio:* Solicitudes con m√°s de 20 d√≠as sin gestionar\n"
                f"üîÑ *Pr√≥xima limpieza:* En 24 horas\n\n"
                f"*Sistema Autom√°tico EntresHijos* ü§ñ"
            )
            
            await safe_bot_method(
                application.bot.send_message,
                chat_id=DEVELOPER_CHAT_ID,
                text=summary_message,
                parse_mode="Markdown"
            )
        
        logger.info(f"‚úÖ Limpieza autom√°tica completada - Procesadas: {processed}, Errores: {errors}")
        
    except Exception as e:
        logger.error(f"‚ùå Error en limpieza autom√°tica: {str(e)}")
        
        # Notificar error a administradores
        error_message = (
            f"‚ö†Ô∏è *Error en Limpieza Autom√°tica* ‚ö†Ô∏è\n\n"
            f"‚ùå *Error:* {str(e)}\n"
            f"‚è∞ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
            f"Por favor, revisa el sistema.\n"
            f"*Sistema Autom√°tico EntresHijos* ü§ñ"
        )
        
        await safe_bot_method(
            context.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=error_message,
            parse_mode="Markdown"
        )

async def reorganize_database():
    """Reorganiza la base de datos eliminando datos innecesarios y reorganizando tickets desde 1."""
    logger.info("üîÑ Iniciando reorganizaci√≥n de base de datos...")
    
    try:
        with get_db_connection() as conn:
            with conn.cursor() as c:
                # Configurar timeout m√°s largo para esta operaci√≥n espec√≠fica
                c.execute("SET LOCAL statement_timeout = '600s'")  # 10 minutos
                
                # 1. Obtener todas las peticiones registradas ordenadas por timestamp
                c.execute("""
                    SELECT ticket_number, chat_id, username, user_id, message_text, 
                           message_id, timestamp, chat_title, thread_id, has_attachment, photo_file_id
                    FROM peticiones_registradas 
                    ORDER BY timestamp ASC
                """)
                peticiones_actuales = c.fetchall()
                
                if not peticiones_actuales:
                    logger.info("‚ÑπÔ∏è No hay peticiones registradas para reorganizar")
                    return
                
                logger.info(f"üìä Encontradas {len(peticiones_actuales)} peticiones para reorganizar")
                
                # 2. Reorganizaci√≥n m√°s eficiente sin crear tabla temporal
                # Solo reorganizar si realmente es necesario (m√°s de 50 tickets o gaps grandes)
                if len(peticiones_actuales) < 50:
                    logger.info("‚ÑπÔ∏è Pocas peticiones, saltando reorganizaci√≥n completa")
                    conn.commit()
                    return
                
                # 3. Limpiar solo datos realmente antiguos para evitar timeout
                cutoff_date = datetime.now(SPAIN_TZ) - timedelta(days=180)
                c.execute("DELETE FROM historial_solicitudes WHERE fecha_gestion < %s", (cutoff_date,))
                deleted_history = c.rowcount
                logger.info(f"üóëÔ∏è Eliminadas {deleted_history} solicitudes del historial (>6 meses)")
                
                # 4. Limpiar cach√© expirado
                c.execute("DELETE FROM cache WHERE expires_at <= %s", (datetime.now(SPAIN_TZ),))
                deleted_cache = c.rowcount
                logger.info(f"üóëÔ∏è Eliminadas {deleted_cache} entradas de cach√© expiradas")
                
                # 5. Limpiar datos antiguos de otras tablas
                c.execute("DELETE FROM peticiones_incorrectas WHERE timestamp < %s", (cutoff_date,))
                deleted_incorrect = c.rowcount
                
                c.execute("DELETE FROM abuso_botones WHERE last_attempt < %s", (cutoff_date,))
                deleted_abuse = c.rowcount
                
                c.execute("DELETE FROM system_logs WHERE timestamp < %s", (cutoff_date,))
                deleted_logs = c.rowcount
                
                conn.commit()
                
                logger.info(f"‚úÖ Limpieza de base de datos completada")
                logger.info(f"üóëÔ∏è Eliminados: {deleted_history} historial, {deleted_cache} cach√©, {deleted_incorrect} incorrectas, {deleted_abuse} abusos, {deleted_logs} logs")
                
                # Notificar a administradores
                summary_message = (
                    f"üßπ *Limpieza de Base de Datos Completada* üßπ\n\n"
                    f"üìä **Resultados:**\n"
                    f"üóëÔ∏è *Historial limpiado:* {deleted_history} registros antiguos\n"
                    f"üóëÔ∏è *Cach√© limpiado:* {deleted_cache} entradas expiradas\n"
                    f"üóëÔ∏è *Peticiones incorrectas:* {deleted_incorrect}\n"
                    f"üóëÔ∏è *Registros de abuso:* {deleted_abuse}\n"
                    f"üóëÔ∏è *Logs antiguos:* {deleted_logs}\n"
                    f"‚è∞ *Completado:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
                    f"üíæ **Beneficios:**\n"
                    f"‚Ä¢ Base de datos m√°s r√°pida y eficiente\n"
                    f"‚Ä¢ Espacio optimizado\n"
                    f"‚Ä¢ Mejor rendimiento general\n\n"
                    f"*Sistema Autom√°tico EntresHijos* ü§ñ"
                )
                
                await safe_bot_method(
                    application.bot.send_message,
                    chat_id=GROUP_DESTINO,
                    text=summary_message,
                    parse_mode="Markdown"
                )
                
    except Exception as e:
        logger.error(f"‚ùå Error en limpieza de base de datos: {str(e)}")
        
        # Notificar error cr√≠tico a administradores
        error_message = (
            f"üö® *Error en Limpieza de Base de Datos* üö®\n\n"
            f"‚ùå *Error:* {str(e)}\n"
            f"‚è∞ *Fecha:* {datetime.now(SPAIN_TZ).strftime('%d/%m/%Y %H:%M:%S')}\n\n"
            f"‚ÑπÔ∏è **NOTA:** El sistema contin√∫a operativo normalmente\n"
            f"*Sistema Autom√°tico EntresHijos* ü§ñ"
        )
        
        await safe_bot_method(
            application.bot.send_message,
            chat_id=GROUP_DESTINO,
            text=error_message,
            parse_mode="Markdown"
        )

async def handle_ping(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /ping para verificar el estado del bot."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_ping")
        return
    
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    uptime_seconds = time_module.time() - BOT_START_TIME
    days = int(uptime_seconds // (24 * 3600))
    hours = int((uptime_seconds % (24 * 3600)) // 3600)
    minutes = int((uptime_seconds % 3600) // 60)
    seconds = int(uptime_seconds % 60)
    uptime_str = f"{days}d {hours}h {minutes}m {seconds}s"

    db_status = "‚úÖ Conectada" if test_db_connection() else "‚ùå Desconectada"

    memory_str = "No disponible"
    try:
        process = psutil.Process()
        memory_info = process.memory_info()
        memory_mb = memory_info.rss / (1024 * 1024)
        memory_str = f"{memory_mb:.2f} MB"
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è No se pudo obtener uso de memoria: {str(e)}")

    response = random.choice(PING_RESPONSES)
    texto = (
        f"{response}\n"
        f"‚è∞ *Tiempo activo:* {uptime_str}\n"
        f"üóÑÔ∏è *Base de datos:* {db_status}\n"
        f"üíæ *Uso de memoria:* {memory_str}\n"
        f"‚è≤Ô∏è *Hora actual:* {get_spain_time()}"
    )
    
    ping_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        parse_mode="Markdown"
    )
    
    if ping_message:
        context.application.create_task(
            auto_delete_message(context, chat_id, ping_message.message_id, 900)
        )
    
    logger.info(f"üì° Comando /ping ejecutado en chat_id={chat_id}")

async def handle_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Maneja el comando /stats para mostrar estad√≠sticas avanzadas."""
    if not update.message:
        logger.warning("‚ö†Ô∏è No se recibi√≥ mensaje en handle_stats")
        return
    
    message = update.message
    chat_id = message.chat_id
    user_id = message.from_user.id
    
    if user_id not in ADMINISTRATORS:
        error_message = await safe_bot_method(
            message.reply_text,
            text="‚ùå *Acceso denegado* ‚ùå\nEste comando es exclusivo para administradores.",
            parse_mode="Markdown"
        )
        if error_message:
            context.application.create_task(
                auto_delete_message(context, chat_id, error_message.message_id, 900)
            )
        return

    stats = get_advanced_stats()
    
    total_gestionadas = stats['gestionadas']
    approved_percent = (stats['estados']['subido'] / total_gestionadas * 100) if total_gestionadas > 0 else 0
    denied_percent = (stats['estados']['denegado'] / total_gestionadas * 100) if total_gestionadas > 0 else 0
    deleted_percent = (stats['estados']['eliminado'] / total_gestionadas * 100) if total_gestionadas > 0 else 0
    
    total_encuestas = sum(stats['encuestas'].values())
    satisfied = stats['encuestas'].get('excelente', 0) + stats['encuestas'].get('bueno', 0)
    unsatisfied = stats['encuestas'].get('regular', 0) + stats['encuestas'].get('malo', 0)
    satisfaction_rate = (satisfied / total_encuestas * 100) if total_encuestas > 0 else 0
    response_rate = (total_encuestas / total_gestionadas * 100) if total_gestionadas > 0 else 0
    
    avg_response_time = "2.3 horas"
    last_update = "Hace 5 minutos"
    
    texto = (
        f"ü§ñ **PANEL DE ESTAD√çSTICAS**\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        f"üìä **RESUMEN GENERAL**\n"
        f"‚îú üìã Solicitudes Pendientes: **{stats['pendientes']}**\n"
        f"‚îú ‚úÖ Solicitudes Gestionadas: **{stats['gestionadas']}**\n"
        f"‚îî üë• Usuarios Registrados: **{stats['usuarios']}**\n\n"
        f"üìà **GESTI√ìN DE SOLICITUDES**\n"
        f"‚îú ‚úÖ Aprobadas: **{stats['estados']['subido']}** ({approved_percent:.1f}%)\n"
        f"‚îú ‚ùå Denegadas: **{stats['estados']['denegado']}** ({denied_percent:.1f}%)\n"
        f"‚îî üóëÔ∏è Eliminadas: **{stats['estados']['eliminado']}** ({deleted_percent:.1f}%)\n\n"
        f"üòä **SATISFACCI√ìN DE USUARIOS**\n"
        f"‚îú üëç Satisfechos: **{satisfied}** ({satisfaction_rate:.1f}%)\n"
        f"‚îú üëé No Satisfechos: **{unsatisfied}**\n"
        f"‚îî üìä Tasa de Respuesta: **{response_rate:.1f}%**\n\n"
        f"‚è±Ô∏è **RENDIMIENTO**\n"
        f"‚îú üïê Tiempo Promedio de Respuesta: **{avg_response_time}**\n"
        f"‚îî üìÖ √öltima Actualizaci√≥n: **{last_update}**"
    )
    
    keyboard = [
        [InlineKeyboardButton("üîÑ Actualizar", callback_data="refresh_stats")],
        [InlineKeyboardButton("üìä Detalles", callback_data="detailed_stats")],
        [InlineKeyboardButton("üè† Men√∫ Principal", callback_data="menu_principal")]
    ]
    
    sent_message = await safe_bot_method(
        message.reply_text,
        text=texto,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    
    if sent_message:
        menu_activos[(chat_id, sent_message.message_id)] = {
            "last_activity": datetime.now(SPAIN_TZ),
            "admin_id": user_id,
            "message_content": texto,
            "message_markup": InlineKeyboardMarkup(keyboard),
            "last_page": 1
        }
        context.application.create_task(
            auto_delete_message(context, chat_id, sent_message.message_id, 900)
        )
    
    logger.info(f"‚úÖ Estad√≠sticas consultadas por user_id={user_id}")

def format_uptime(seconds):
    """Formatea el tiempo de actividad."""
    days = int(seconds // 86400)
    hours = int((seconds % 86400) // 3600)
    minutes = int((seconds % 3600) // 60)
    
    if days > 0:
        return f"{days}d {hours}h {minutes}m"
    elif hours > 0:
        return f"{hours}h {minutes}m"
    else:
        return f"{minutes}m"

def format_time_remaining(target_datetime):
    """Formatea el tiempo restante hasta una fecha objetivo."""
    if not target_datetime:
        return "No programado"
    
    now = datetime.now(SPAIN_TZ)
    if isinstance(target_datetime, str):
        target_datetime = datetime.fromisoformat(target_datetime)
    
    if target_datetime.tzinfo is None:
        target_datetime = SPAIN_TZ.localize(target_datetime)
    
    diff = target_datetime - now
    
    if diff.total_seconds() <= 0:
        return "Expirado"
    
    days = diff.days
    hours = diff.seconds // 3600
    minutes = (diff.seconds % 3600) // 60
    
    if days > 0:
        return f"{days}d {hours}h {minutes}m"
    elif hours > 0:
        return f"{hours}h {minutes}m"
    else:
        return f"{minutes}m"

async def setup_bot_commands():
    """Configura los comandos del bot que aparecer√°n en el men√∫ de Telegram."""
    try:
        commands = [
            telegram.BotCommand("start", "üöÄ Iniciar el bot y activar notificaciones"),
            telegram.BotCommand("ayuda", "üìñ Gu√≠a completa de uso del bot"),
            telegram.BotCommand("mispuntos", "üí∞ Ver mis puntos y estad√≠sticas"),
            telegram.BotCommand("missolicitudes", "üìã Ver mis solicitudes"),
            telegram.BotCommand("ranking", "üèÜ Ver ranking de usuarios"),
            telegram.BotCommand("recompensas", "üéÅ Ver recompensas disponibles"),
            telegram.BotCommand("horario", "üïê Ver horario del bot"),
            telegram.BotCommand("cancelar", "‚ùå Cancelar tu solicitud con n√∫mero de ticket"),
        ]

        await application.bot.set_my_commands(commands)
        logger.info("‚úÖ Comandos del bot configurados correctamente")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error configurando comandos del bot: {str(e)}")

async def update_bot_description():
    """Actualiza la descripci√≥n del bot con el contador de usuarios √∫nicos."""
    try:
        # Obtener n√∫mero de usuarios √∫nicos
        with get_db_connection() as conn:
            with conn.cursor() as c:
                c.execute("SELECT COUNT(DISTINCT user_id) FROM usuarios")
                total_usuarios = c.fetchone()[0]

        # Descripci√≥n corta (aparece en el perfil)
        short_description = (
            f"ü§ñ Bot oficial de EntresHijos para gesti√≥n de solicitudes\n"
            f"üë• {total_usuarios:,} usuarios activos"
        )

        # Descripci√≥n larga (aparece al hacer clic en "M√°s info")
        description = (
            f"ü§ñ **Bot de Gesti√≥n EntresHijos**\n\n"
            f"Bot oficial para gestionar solicitudes de contenido de forma organizada y eficiente.\n\n"
            f"üìä **Estad√≠sticas:**\n"
            f"üë• {total_usuarios:,} usuarios registrados\n\n"
            f"‚ú® **Funcionalidades:**\n"
            f"‚Ä¢ Sistema de solicitudes con tickets\n"
            f"‚Ä¢ Sistema de puntos y niveles (gamificaci√≥n)\n"
            f"‚Ä¢ Ranking de usuarios\n"
            f"‚Ä¢ Recompensas canjeables\n"
            f"‚Ä¢ Notificaciones personalizadas\n"
            f"‚Ä¢ L√≠mite de 2 solicitudes diarias\n"
            f"‚Ä¢ Votaci√≥n comunitaria\n"
            f"‚Ä¢ Horarios configurables\n\n"
            f"üí° Usa /ayuda para comenzar"
        )

        # Actualizar descripciones
        await application.bot.set_my_short_description(short_description)
        await application.bot.set_my_description(description)

        logger.info(f"‚úÖ Descripci√≥n del bot actualizada ({total_usuarios:,} usuarios)")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error actualizando descripci√≥n del bot: {str(e)}")

async def setup_webhook():
    """Configura el webhook para el bot de Telegram."""
    try:
        webhook_info = await application.bot.get_webhook_info()
        current_webhook_url = webhook_info.url

        if current_webhook_url == WEBHOOK_URL:
            logger.info("‚úÖ Webhook ya configurado correctamente.")
            return

        await application.bot.set_webhook(url=WEBHOOK_URL)
        logger.info(f"‚úÖ Webhook configurado en {WEBHOOK_URL}")
    except telegram.error.TelegramError as e:
        logger.error(f"‚ö†Ô∏è Error al configurar el webhook: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error inesperado al configurar el webhook: {str(e)}")
        raise

async def start_bot():
    """Inicia el bot y configura los manejadores."""
    global application
    
    await application.initialize()
    logger.info("‚úÖ Aplicaci√≥n de Telegram inicializada correctamente.")
    
    # Handlers de comandos PRIMERO
    # Comandos para usuarios
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("ayuda", handle_ayuda))
    application.add_handler(CommandHandler("mispuntos", handle_mispuntos))
    application.add_handler(CommandHandler("missolicitudes", handle_missolicitudes))
    application.add_handler(CommandHandler("ranking", handle_ranking))
    application.add_handler(CommandHandler("recompensas", handle_recompensas))
    application.add_handler(CommandHandler("horario", handle_horario))
    application.add_handler(CommandHandler("cancelar", handle_cancelar_command))

    # Comandos para administradores
    application.add_handler(CommandHandler("menu", handle_menu))
    application.add_handler(CommandHandler("restar", handle_restar_command))
    application.add_handler(CommandHandler("dar_puntos", handle_dar_puntos_command))
    application.add_handler(CommandHandler("ping", handle_ping))
    application.add_handler(CommandHandler("stats", handle_stats))
    application.add_handler(CommandHandler("tiempo", handle_tiempo))
    application.add_handler(CommandHandler("maintenance", handle_maintenance))
    application.add_handler(CommandHandler("mantenimiento", handle_mantenimiento))

    # Registrar handlers del sistema de puntos
    # Los handlers ya est√°n integrados en el handle_button principal
    if SISTEMA_PUNTOS_DISPONIBLE:
        logger.info("‚úÖ Sistema de puntos integrado y listo")

    # ConversationHandler para horarios
    schedule_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(select_days, pattern="^edit_days$"),
            CallbackQueryHandler(confirm_days, pattern="^confirm_days$")
        ],
        states={
            SELECT_DAYS: [
                CallbackQueryHandler(select_days, pattern="^day_"),
                CallbackQueryHandler(confirm_days, pattern="^confirm_days$"),
                CallbackQueryHandler(cancel_schedule, pattern="^cancel_schedule$")
            ],
            INPUT_START_HOUR: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_start_hour)
            ],
            INPUT_END_HOUR: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, input_end_hour)
            ],
            FINAL_CONFIRMATION: [
                CallbackQueryHandler(final_confirmation, pattern="^save_schedule$"),
                CallbackQueryHandler(select_days, pattern="^edit_days$"),
                CallbackQueryHandler(cancel_schedule, pattern="^cancel_schedule$")
            ]
        },
        fallbacks=[
            CallbackQueryHandler(cancel_schedule, pattern="^cancel_schedule$"),
            CommandHandler("menu", handle_menu)
        ],
        per_chat=True,
        per_user=True,
        per_message=False
    )
    
    # ConversationHandler para b√∫squedas
    search_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(handle_button, pattern="^search_user$")
        ],
        states={
            ASKING_USER_SEARCH: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_user_search)
            ]
        },
        fallbacks=[
            CallbackQueryHandler(handle_button, pattern="^cancel_search$"),
            CommandHandler("menu", handle_menu)
        ],
        per_chat=True,
        per_user=True,
        per_message=False
    )
    
    application.add_handler(schedule_handler)
    application.add_handler(search_handler)
    
    application.add_handler(CallbackQueryHandler(handle_button))

    # Handler para confirmaci√≥n de bienvenida al grupo de respaldo (DESACTIVADO - ya no se usa bot√≥n)
    # application.add_handler(CallbackQueryHandler(handle_backup_confirmation, pattern="^backup_confirmed_"))

    # Handler para nuevos miembros en el grupo de respaldo
    application.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, handle_new_chat_member))

    # IMPORTANTE: Los MessageHandlers deben ir DESPU√âS de los ConversationHandlers
    # Manejador de mensajes de texto y multimedia (para peticiones y respuestas de admin)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_request))
    application.add_handler(MessageHandler(filters.PHOTO, handle_request))
    application.add_handler(MessageHandler(filters.VIDEO, handle_request))
    application.add_handler(MessageHandler(filters.ANIMATION, handle_request))  # GIFs
    application.add_handler(MessageHandler(filters.Document.ALL, handle_request))

    # Error handler (NO es un handler normal, se registra con add_error_handler)
    application.add_error_handler(error_handler)

    application.job_queue.run_repeating(
        cleanup_old_menus,
        interval=300,
        first=300
    )

    application.job_queue.run_repeating(
        check_suspicious_activity,
        interval=3600,
        first=3600
    )

    # Verificar y desmutear usuarios cada 5 minutos
    application.job_queue.run_repeating(
        check_and_unmute_users,
        interval=300,
        first=300
    )

    # Actualizar descripci√≥n del bot cada hora
    application.job_queue.run_repeating(
        update_bot_description,
        interval=3600,
        first=3600
    )

    # Programar limpieza autom√°tica diaria a las 03:00
    application.job_queue.run_daily(
        automatic_cleanup,
        time=time(3, 0, 0),  # 03:00 AM
        name="daily_cleanup"
    )

    # Programar reporte semanal cada domingo a las 22:05 hora de Espa√±a
    application.job_queue.run_daily(
        weekly_report_and_rewards,
        time=time(22, 5, 0),  # 22:05 (10:05 PM)
        days=(6,),  # 6 = Domingo (0=Lunes, 1=Martes, ..., 6=Domingo)
        name="weekly_report"
    )

    # Programar recordatorios de encuestas diariamente a las 10:00
    application.job_queue.run_daily(
        send_survey_reminders,
        time=time(10, 0, 0),  # 10:00 AM
        name="survey_reminders"
    )

    # Programar resumen diario a las 22:00 hora espa√±ola (Sistema de gamificaci√≥n)
    # Funcionalidad de resumen diario se implementar√° en futuras versiones
    if SISTEMA_PUNTOS_DISPONIBLE:
        logger.info("‚úÖ Sistema de puntos activo - Resumen diario pendiente de implementaci√≥n")

    logger.info("üßπ Limpieza autom√°tica programada para las 03:00 diariamente")
    logger.info("üìä Reporte semanal programado para domingos a las 22:05")
    logger.info("üìã Recordatorios de encuestas programados para las 10:00 diariamente")
    logger.info("üîá Verificaci√≥n de usuarios silenciados programada cada 5 minutos")
    logger.info("ü§ñ Actualizaci√≥n de descripci√≥n del bot programada cada hora")
    if SISTEMA_PUNTOS_DISPONIBLE:
        logger.info("üìä Resumen diario programado para las 22:00 diariamente")
        logger.info("üéÅ Limpieza de recompensas expiradas programada para las 04:00")

    # Configurar webhook, comandos y descripci√≥n del bot
    await setup_webhook()
    await setup_bot_commands()
    await update_bot_description()

    asyncio.create_task(clean_expired_admin_responses())
    asyncio.create_task(clean_expired_user_menu_states())
    asyncio.create_task(clean_pending_data())
    asyncio.create_task(clean_expired_backup_attempts())
    
    global automatic_notifications_enabled
    automatic_notifications_enabled = get_notification_settings()
    
    if automatic_notifications_enabled:
        schedule_notifications(application)
        logger.info("üîî Notificaciones autom√°ticas programadas")
    
    await application.start()
    logger.info("‚úÖ Bot iniciado correctamente")

async def admin_reply_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Gestiona respuestas de administradores seg√∫n el estado guardado."""
    uid = update.effective_user.id
    if admin_waiting_responses.get(uid) == "dar_puntos":
        await process_dar_puntos_response(update, context)
        # Limpia el estado tras procesar
        admin_waiting_responses.pop(uid, None)

async def initialize_and_set_webhook():
    """Inicializa y configura el webhook."""
    logger.info("üöÄ Inicializando la aplicaci√≥n de Telegram...")
    await start_bot()
    logger.info("‚úÖ Aplicaci√≥n de Telegram inicializada y arrancada correctamente.")

@app.post("/webhook")
async def webhook_update(request: Request) -> PlainTextResponse:
    """Maneja las actualizaciones del webhook."""
    try:
        update_data = await request.json()
        update = Update.de_json(update_data, application.bot)
        await application.process_update(update)
        return PlainTextResponse("OK")
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en webhook: {str(e)}")
        return PlainTextResponse("Error", status_code=500)

@app.on_event("startup")
async def startup_event():
    """Evento de inicio de la aplicaci√≥n."""
    logger.info("üöÄ Iniciando el evento de startup...")
    try:
        # Inicializar Sentry si est√° disponible
        sentry_dsn = os.getenv("SENTRY_DSN")
        if sentry_dsn:
            sentry_sdk.init(
                dsn=sentry_dsn,
                integrations=[StarletteIntegration(), FastApiIntegration()],
                traces_sample_rate=1.0,
                environment="production"
            )
            logger.info("‚úÖ Sentry inicializado correctamente.")
        else:
            logger.info("‚ÑπÔ∏è Sentry DSN no configurado, continuando sin monitoreo.")
        
        logger.info(f"üîë TOKEN={TOKEN[:10]}..., GROUP_DESTINO={GROUP_DESTINO}, WEBHOOK_URL={WEBHOOK_URL}")

        # Inicializar tablas de Supabase primero
        logger.info("üöÄ Inicializando tablas de Supabase...")
        auto_initialize_supabase_tables()

        # Inicializar todas las tablas necesarias
        initialize_database_tables()

        # Verificar y crear tablas necesarias
        conn = get_db_connection()
        try:
            conn.autocommit = True
            with conn.cursor() as c:
                # Verificar que las tablas principales existen
                c.execute("""
                    SELECT table_name FROM information_schema.tables 
                    WHERE table_schema = 'public' AND table_name IN (
                        'peticiones_registradas', 'historial_solicitudes', 'usuarios',
                        'grupos_estados', 'peticiones_por_usuario', 'encuestas_satisfaccion',
                        'bot_schedule', 'cache', 'maintenance_mode', 'request_votes',
                        'system_logs', 'notification_settings', 'peticiones_incorrectas',
                        'abuso_botones', 'confirmation_messages', 'scheduled_maintenance',
                        'maintenance_messages'
                    )
                """)
                existing_tables = [row[0] for row in c.fetchall()]
                
                # Crear tablas faltantes si es necesario
                required_tables = [
                    'peticiones_registradas', 'historial_solicitudes', 'usuarios',
                    'grupos_estados', 'peticiones_por_usuario', 'encuestas_satisfaccion',
                    'bot_schedule', 'cache', 'maintenance_mode', 'request_votes',
                    'system_logs', 'notification_settings', 'peticiones_incorrectas',
                    'abuso_botones', 'confirmation_messages', 'scheduled_maintenance',
                    'maintenance_messages'
                ]
                
                missing_tables = [table for table in required_tables if table not in existing_tables]
                
                if missing_tables:
                    logger.warning(f"‚ö†Ô∏è Tablas faltantes detectadas: {missing_tables}")
                    logger.info("‚ÑπÔ∏è Las tablas faltantes se crear√°n autom√°ticamente cuando sean necesarias.")
                else:
                    logger.info("‚úÖ Todas las tablas requeridas est√°n presentes en la base de datos.")
                
                # Verificar √≠ndices cr√≠ticos
                c.execute("""
                    SELECT indexname FROM pg_indexes 
                    WHERE tablename IN ('peticiones_registradas', 'historial_solicitudes', 'usuarios')
                """)
                existing_indexes = [row[0] for row in c.fetchall()]
                logger.info(f"‚úÖ √çndices existentes: {len(existing_indexes)}")
                
        finally:
            conn.autocommit = False
            release_db_connection(conn)

        logger.info("‚úÖ Verificaci√≥n de base de datos completada.")

        await initialize_and_set_webhook()
        
        # Inicializar estados de grupos
        grupos_estados = get_grupos_estados()
        logger.info(f"üìç Grupos en DB: {len(grupos_estados)}")
        for chat_id, title in GRUPOS_PREDEFINIDOS.items():
            if chat_id not in grupos_estados:
                set_grupo_estado(chat_id, title)
                logger.info(f"‚úÖ Grupo {title} inicializado en DB")
        
        # Limpiar cach√© expirado
        clear_expired_cache()
        logger.info("‚úÖ Cach√© expirado limpiado.")

        # Verificar sistema de puntos
        try:
            conn_test = get_db_connection()
            with conn_test.cursor() as c:
                c.execute("SELECT COUNT(*) FROM puntos_usuarios")
                puntos_count = c.fetchone()[0]
                c.execute("SELECT COUNT(*) FROM transacciones_puntos")
                transacciones_count = c.fetchone()[0]
                logger.info(f"üí∞ Sistema de Puntos: {puntos_count} usuarios, {transacciones_count} transacciones")
                logger.info(f"‚úÖ Sistema de Puntos: {'HABILITADO' if SISTEMA_PUNTOS_DISPONIBLE else 'DESHABILITADO'}")
            release_db_connection(conn_test)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No se pudo verificar sistema de puntos: {str(e)}")
        
        # Ejecutar reorganizaci√≥n inicial si es necesario
        try:
            with get_db_connection() as conn:
                with conn.cursor() as c:
                    c.execute("SELECT COUNT(*) FROM peticiones_registradas")
                    pending_count = c.fetchone()[0]
                    
                    # Solo ejecutar limpieza b√°sica en startup para evitar timeouts
                    if pending_count > 0:
                        c.execute("SELECT MIN(ticket_number), MAX(ticket_number) FROM peticiones_registradas")
                        result = c.fetchone()
                        if result and result[0] is not None and result[1] is not None:
                            min_ticket, max_ticket = result
                            logger.info(f"‚úÖ Numeraci√≥n de tickets: min={min_ticket}, max={max_ticket}, total={pending_count}")
                        else:
                            logger.info(f"‚úÖ {pending_count} solicitudes pendientes encontradas")
                    else:
                        logger.info("‚ÑπÔ∏è No hay solicitudes pendientes")
                    
                    # Solo limpiar cach√© expirado en startup
                    c.execute("DELETE FROM cache WHERE expires_at <= %s", (datetime.now(SPAIN_TZ),))
                    deleted_cache = c.rowcount
                    if deleted_cache > 0:
                        logger.info(f"üóëÔ∏è Eliminadas {deleted_cache} entradas de cach√© expiradas en startup")
                    
                    conn.commit()
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error en verificaci√≥n inicial de BD: {str(e)}")
        
        # Verificar configuraci√≥n de notificaciones
        global automatic_notifications_enabled
        automatic_notifications_enabled = get_notification_settings()
        logger.info(f"üîî Notificaciones autom√°ticas: {'Habilitadas' if automatic_notifications_enabled else 'Deshabilitadas'}")
        
        # Verificar configuraci√≥n de detecci√≥n de duplicados
        global duplicate_detection_enabled
        duplicate_detection_enabled = True  # Forzar habilitaci√≥n
        set_duplicate_detection_settings(True)  # Asegurar que est√© habilitado en BD
        logger.info(f"üîç Detecci√≥n de duplicados: {'Habilitada' if duplicate_detection_enabled else 'Deshabilitada'}")
        
        # Forzar habilitaci√≥n de detecci√≥n de duplicados si no est√° configurada
        if not duplicate_detection_enabled:
            logger.info("üîç Forzando habilitaci√≥n de detecci√≥n de duplicados")
            set_duplicate_detection_settings(True)
            duplicate_detection_enabled = True
            logger.info("‚úÖ Detecci√≥n de duplicados forzada a habilitada")

        # Crear tablas de puntos si no existen y sincronizar
        if SISTEMA_PUNTOS_DISPONIBLE:
            try:
                # Primero crear las tablas
                if crear_tablas_puntos():
                    # Luego sincronizar puntos de usuarios
                    usuarios_sync, puntos_sync = sincronizar_puntos_usuarios()
                    if usuarios_sync > 0:
                        logger.info(f"‚úÖ Sistema de puntos sincronizado: {usuarios_sync} usuarios, {puntos_sync} puntos totales")
                    else:
                        logger.info("‚ÑπÔ∏è No hay nuevos usuarios para sincronizar puntos")
                else:
                    logger.warning("‚ö†Ô∏è No se pudieron crear las tablas de puntos")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error inicializando sistema de puntos: {str(e)}")

        logger.info("üöÄ Evento de startup completado exitosamente.")
        
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error durante el startup: {str(e)}", exc_info=True)
        if 'sentry_sdk' in globals():
            sentry_sdk.capture_exception(e)
        raise

from fastapi.responses import PlainTextResponse

@app.get("/")
async def root():
    """Endpoint ra√≠z."""
    return {
        "message": "Bot de Telegram EntresHijos funcionando correctamente",
        "status": "active",
        "version": "2.0.0",
        "uptime": format_uptime(time_module.time() - BOT_START_TIME),
        "timestamp": datetime.now(SPAIN_TZ).isoformat()
    }

# ‚úÖ Soporte HEAD para monitores que no usan GET
@app.head("/", include_in_schema=False)
async def root_head():
    return PlainTextResponse("ok", status_code=200)

@app.get("/health")
async def health_check():
    """Endpoint de verificaci√≥n de salud para UptimeRobot."""
    try:
        db_connected = test_db_connection()
        maintenance_active = is_maintenance_active()
        
        # Verificar estado del webhook
        webhook_status = "unknown"
        try:
            webhook_info = await application.bot.get_webhook_info()
            webhook_status = "configured" if webhook_info.url == WEBHOOK_URL else "misconfigured"
        except Exception:
            webhook_status = "error"
        
        return {
            "status": "healthy" if db_connected and not maintenance_active else "degraded",
            "db_connected": db_connected,
            "maintenance_mode": maintenance_active,
            "webhook_status": webhook_status,
            "uptime_seconds": int(time_module.time() - BOT_START_TIME),
            "memory_usage_mb": get_memory_usage(),
            "timestamp": datetime.now(SPAIN_TZ).isoformat(),
            "version": "2.0.0"
        }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en health check: {str(e)}")
        return {
            "status": "error",
            "error": str(e),
            "timestamp": datetime.now(SPAIN_TZ).isoformat()
        }

# ‚úÖ Soporte HEAD y POST para evitar 405 en monitores/sondeos
@app.head("/health", include_in_schema=False)
async def health_head():
    return PlainTextResponse("healthy", status_code=200)

@app.post("/health", include_in_schema=False)
async def health_post():
    # Algunos monitores o proxies podr√≠an hacer POST por error a /health
    return PlainTextResponse("Use GET/HEAD for /health", status_code=200)

def get_memory_usage():
    """Obtiene el uso de memoria actual."""
    try:
        if PSUTIL_AVAILABLE:
            process = psutil.Process()
            memory_info = process.memory_info()
            return round(memory_info.rss / (1024 * 1024), 2)
        return None
    except Exception:
        return None

@app.get("/status")
async def status_endpoint():
    """Endpoint de estado detallado para administradores."""
    try:
        stats = get_advanced_stats()
        schedule = get_bot_schedule()
        maintenance = get_maintenance_mode()
        
        return {
            "bot_status": "active",
            "database": {
                "connected": test_db_connection(),
                "pending_requests": stats["pendientes"],
                "processed_requests": stats["gestionadas"],
                "total_users": stats["usuarios"]
            },
            "schedule": {
                "configured": schedule is not None,
                "active": is_within_schedule() if schedule else True,
                "days": schedule["days_of_week"] if schedule else None,
                "hours": f"{schedule['start_hour']:02d}:00-{schedule['end_hour']:02d}:00" if schedule else None
            },
            "maintenance": {
                "active": maintenance["is_active"],
                "message": maintenance["message"],
                "scheduled_until": maintenance["scheduled_until"]
            },
            "notifications": {
                "enabled": automatic_notifications_enabled,
                "jobs_scheduled": len(notification_jobs)
            },
            "system": {
                "uptime": format_uptime(time_module.time() - BOT_START_TIME),
                "memory_mb": get_memory_usage(),
                "active_menus": len(menu_activos),
                "pending_admin_responses": len(admin_waiting_responses)
            },
            "timestamp": datetime.now(SPAIN_TZ).isoformat()
        }
    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en status endpoint: {str(e)}")
        return {"error": str(e), "timestamp": datetime.now(SPAIN_TZ).isoformat()}

async def process_dar_puntos_response(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs) -> None:
    """
    Procesa el texto que el admin escribe tras pulsar el bot√≥n 'puntos_dar_puntos'.
    Formato esperado: @username cantidad motivo...
    Acepta *args/**kwargs por si alg√∫n sitio la invoca con argumentos extra.
    """
    message = update.message
    if not message:
        return

    chat_id = message.chat_id
    admin_id = message.from_user.id

    text = (message.text or "").strip()
    logger.info(f"üìù Procesando respuesta de admin {admin_id}: {text}")

    parts = text.split()
    if len(parts) < 2:
        err = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=("‚ö†Ô∏è *Uso incorrecto* ‚ö†Ô∏è\n\n"
                  "Escribe: `@username cantidad motivo`\n"
                  "Ejemplo: `@usuario 50 Gran aporte`"),
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
        return

    username_input = parts[0]
    username_norm = normalize_username(username_input)
    username_display = f"@{username_norm}"

    # cantidad
    try:
        cantidad = int(parts[1])
        if cantidad <= 0:
            raise ValueError
    except Exception:
        err = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text="‚ö†Ô∏è *Error* ‚ö†Ô∏è\nLa cantidad debe ser un n√∫mero entero positivo.",
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))
        return

    motivo = " ".join(parts[2:]).strip() or "sin motivo"

    try:
        # 1) Buscar en BD
        with get_db_connection() as conn:
            target_user_id = find_user_id_by_username_db(conn, username_norm)

        # 2) Fallback opcional a Telegram
        if not target_user_id:
            logger.info(f"üîç Usuario {username_display} no encontrado en BD, intentando Telegram API...")
            target_user_id = await try_resolve_user_id_via_telegram(context, username_norm)

        # 3) Si a√∫n no se encuentra, generar user_id temporal basado en hash del username
        if not target_user_id:
            # Generar user_id √∫nico basado en hash del username
            import hashlib
            hash_obj = hashlib.md5(username_norm.encode())
            # Usar los primeros 8 bytes del hash para generar un n√∫mero de 10 d√≠gitos
            # Agregamos 9 al inicio para diferenciarlo de IDs reales de Telegram (que empiezan con 1-8)
            temp_id = int(hash_obj.hexdigest()[:8], 16)
            target_user_id = 9000000000 + (temp_id % 1000000000)  # ID en rango 9000000000-9999999999

            logger.info(f"‚ö†Ô∏è Usuario {username_display} no encontrado. Generando user_id temporal: {target_user_id}")

            # Informar al admin
            info_msg = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=(f"‚ÑπÔ∏è *Usuario Nuevo* ‚ÑπÔ∏è\n\n"
                      f"El usuario {username_display} no tiene interacciones previas con el bot.\n\n"
                      f"‚úÖ Se crear√° su perfil autom√°ticamente y se otorgar√°n los puntos.\n\n"
                      f"üí° *Nota:* Cuando {username_display} interact√∫e con el bot, "
                      f"su perfil se actualizar√° autom√°ticamente."),
                parse_mode="Markdown"
            )
            if info_msg:
                context.application.create_task(auto_delete_message(context, chat_id, info_msg.message_id, 10))

        # Otorgar puntos
        logger.info(f"üí∞ Otorgando {cantidad} puntos a {username_display} (user_id: {target_user_id})")
        resultado = otorgar_puntos(target_user_id, username_norm, cantidad, "manual", motivo, admin_id=admin_id)

        if not resultado:
            err_msg = await safe_bot_method(
                context.bot.send_message,
                chat_id=chat_id,
                text=f"‚ùå *Error* ‚ùå\n\nNo se pudieron otorgar los puntos. Por favor, revisa los logs.",
                parse_mode="Markdown"
            )
            if err_msg:
                context.application.create_task(auto_delete_message(context, chat_id, err_msg.message_id, 900))
            return

        puntos_info = obtener_puntos_usuario(target_user_id)

        if puntos_info:
            nivel_emoji = NIVELES.get(puntos_info["nivel"], NIVELES["bronce"])["emoji"]
            mensaje_estado = (
                f"üìä **Estado Actual:**\n"
                f"{nivel_emoji} **Nivel:** {puntos_info['nivel'].capitalize()}\n"
                f"üíé **Total de puntos:** {puntos_info['puntos']:,} pts"
            )
        else:
            mensaje_estado = "üìä **Estado:** Perfil creado correctamente"

        ok = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=("‚úÖ *Puntos Otorgados Exitosamente* ‚úÖ\n\n"
                  f"üë§ **Usuario:** {username_display}\n"
                  f"üí∞ **Puntos otorgados:** +{cantidad:,} pts\n"
                  f"üìù **Motivo:** {motivo}\n\n"
                  "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                  f"{mensaje_estado}\n\n"
                  "‚ú® *Transacci√≥n registrada correctamente*"),
            parse_mode="Markdown"
        )
        if ok:
            context.application.create_task(auto_delete_message(context, chat_id, ok.message_id, 300))

        logger.info(f"‚úÖ Respuesta de administrador procesada: +{cantidad} a {username_display} ({target_user_id})")

        # Limpia el estado si usas un diccionario de espera
        try:
            if admin_waiting_responses.get(admin_id) == "dar_puntos":
                admin_waiting_responses.pop(admin_id, None)
        except Exception:
            pass

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error procesando respuesta de admin: {str(e)}")
        err = await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=f"‚ùå *Error* ‚ùå\nOcurri√≥ un error al procesar: {str(e)}",
            parse_mode="Markdown"
        )
        if err:
            context.application.create_task(auto_delete_message(context, chat_id, err.message_id, 900))

async def process_contact_response(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                   text: str, waiting_dict: dict, admin_id: int, chat_id: int):
    """Procesa la respuesta del admin a una solicitud de contacto."""
    try:
        if not text or len(text.strip()) == 0:
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå *Error*\n\nDebes escribir una respuesta v√°lida.",
                parse_mode="Markdown"
            )
            return

        # Extraer request_id y message_id del waiting_dict
        data_dict = waiting_dict.get("data", {}) if isinstance(waiting_dict.get("data"), dict) else {}
        request_id = data_dict.get("request_id") or waiting_dict.get("request_id")
        menu_message_id = data_dict.get("message_id") or waiting_dict.get("message_id")

        if not request_id:
            logger.error(f"‚ö†Ô∏è No se encontr√≥ request_id en waiting_dict. Estructura: {waiting_dict}")
            return

        # Guardar el texto de respuesta en el estado (dentro de data para que sea accesible)
        data_dict["response_text"] = text.strip()
        waiting_dict["data"] = data_dict
        set_admin_waiting_response(admin_id, chat_id, "contact_response", request_id, data_dict)

        # Mostrar confirmaci√≥n con botones
        divider = "‚îÅ" * 32
        preview_text = (
            f"{divider}\n"
            f"‚úÖ *RESPUESTA RECIBIDA* ‚úÖ\n"
            f"{divider}\n\n"
            f"üìù *Tu respuesta:*\n"
            f"> {text}\n\n"
            f"{divider}\n\n"
            f"¬øDeseas enviar esta respuesta al usuario?"
        )

        keyboard = [
            [InlineKeyboardButton("‚úÖ Enviar Respuesta", callback_data=f"contact_confirm_response_{request_id}")],
            [InlineKeyboardButton("‚úèÔ∏è Corregir", callback_data=f"contact_edit_response_{request_id}")],
            [InlineKeyboardButton("‚ùå Cancelar", callback_data=f"contact_view_{request_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # IMPORTANTE: Editar el mensaje del men√∫ original, NO crear uno nuevo
        if menu_message_id:
            await safe_bot_method(
                context.bot.edit_message_text,
                chat_id=chat_id,
                message_id=menu_message_id,
                text=preview_text,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )
            logger.info(f"‚úÖ Men√∫ actualizado con preview de respuesta (message_id={menu_message_id})")
        else:
            # Fallback: enviar nuevo mensaje si no hay message_id
            logger.warning(f"‚ö†Ô∏è No se encontr√≥ message_id, enviando nuevo mensaje")
            await context.bot.send_message(
                chat_id=chat_id,
                text=preview_text,
                reply_markup=reply_markup,
                parse_mode="Markdown"
            )

        logger.info(f"‚úÖ Respuesta de contacto recibida de admin {admin_id} para solicitud #{request_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error procesando respuesta de contacto: {str(e)}", exc_info=True)
        await context.bot.send_message(
            chat_id=chat_id,
            text="‚ùå *Error*\n\nHubo un error procesando tu respuesta.",
            parse_mode="Markdown"
        )

async def process_alerta_response(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                   text: str, admin_id: int, chat_id: int, waiting_response: dict):
    """Procesa la respuesta del admin para confirmar y enviar alerta con soporte multimedia."""
    try:
        message = update.message

        if not message:
            logger.error("‚ö†Ô∏è No se recibi√≥ mensaje en process_alerta_response")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå *Error*\n\nNo se recibi√≥ el mensaje correctamente. Por favor, intenta nuevamente.",
                parse_mode="Markdown"
            )
            return

        # Log completo del mensaje recibido
        logger.info(f"üì® Mensaje recibido de admin {admin_id}:")
        logger.info(f"   ‚Ä¢ Text: {message.text[:100] if message.text else 'None'}")
        logger.info(f"   ‚Ä¢ Caption: {message.caption[:100] if message.caption else 'None'}")
        logger.info(f"   ‚Ä¢ Photo: {bool(message.photo)}")
        logger.info(f"   ‚Ä¢ Video: {bool(message.video)}")
        logger.info(f"   ‚Ä¢ Animation (GIF): {bool(message.animation)}")
        logger.info(f"   ‚Ä¢ Document: {bool(message.document)}")

        # Detectar tipo de contenido
        media_data = None
        media_type = None
        caption = ""

        if message.photo:
            media_type = "photo"
            media_data = message.photo[-1].file_id  # Obtener la imagen de mayor resoluci√≥n
            caption = message.caption or ""
            logger.info(f"üì∏ Foto detectada para alerta: {media_data}, caption: '{caption[:50]}'")
        elif message.video:
            media_type = "video"
            media_data = message.video.file_id
            caption = message.caption or ""
            logger.info(f"üé• Video detectado para alerta: {media_data}, caption: '{caption[:50]}'")
        elif message.animation:  # GIF
            media_type = "animation"
            media_data = message.animation.file_id
            caption = message.caption or ""
            logger.info(f"üéûÔ∏è GIF detectado para alerta: {media_data}, caption: '{caption[:50]}'")
        elif message.document:
            media_type = "document"
            media_data = message.document.file_id
            caption = message.caption or ""
            logger.info(f"üìé Documento detectado para alerta: {media_data}, caption: '{caption[:50]}'")
        elif message.text:
            # Solo texto
            caption = message.text.strip()
            logger.info(f"üìù Texto solo para alerta: {caption[:50]}...")
        else:
            # No hay contenido v√°lido
            logger.warning(f"‚ö†Ô∏è Mensaje sin contenido v√°lido de admin {admin_id}")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå *Error*\n\nDebes enviar un mensaje con texto o contenido multimedia v√°lido.",
                parse_mode="Markdown"
            )
            return

        # Validar que hay contenido
        if not caption and not media_data:
            logger.warning(f"‚ö†Ô∏è No hay caption ni media_data para la alerta")
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå *Error*\n\nDebes enviar un mensaje con texto o contenido multimedia.",
                parse_mode="Markdown"
            )
            return

        # Guardar informaci√≥n de la alerta
        context.bot_data[f"pending_alerta_{admin_id}"] = {
            "text": caption,
            "media_type": media_type,
            "media_data": media_data
        }

        logger.info(f"üíæ Alerta guardada para admin {admin_id}: tipo={media_type}, texto={caption[:50] if caption else 'Sin texto'}...")

        # Crear preview
        preview_text = (
            f"üì¢ *Preview de Alerta*\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        )

        if media_type:
            media_icons = {
                "photo": "üñºÔ∏è",
                "video": "üé•",
                "animation": "üéûÔ∏è",
                "document": "üìé"
            }
            preview_text += f"{media_icons.get(media_type, 'üìé')} *Contenido multimedia:* {media_type.upper()}\n\n"

        if caption:
            preview_text += f"*Mensaje:*\n{caption}\n\n"

        preview_text += (
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"üéØ *Destino:* Todos los grupos de peticiones\n\n"
            f"¬øConfirmas el env√≠o?"
        )

        keyboard = [
            [InlineKeyboardButton("‚úÖ Enviar", callback_data=f"confirm_alerta_{admin_id}"),
             InlineKeyboardButton("‚ùå Cancelar", callback_data="menu_herramientas")]
        ]

        await safe_bot_method(
            context.bot.send_message,
            chat_id=chat_id,
            text=preview_text,
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )

        logger.info(f"‚úÖ Preview de alerta enviado a admin {admin_id}")

    except Exception as e:
        logger.error(f"‚ö†Ô∏è Error en process_alerta_response: {str(e)}", exc_info=True)
        await send_error_to_developer(context, f"Error procesando alerta: {str(e)}", "Error Alerta")

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text="‚ùå *Error procesando alerta*\n\nOcurri√≥ un error al procesar tu mensaje. Por favor, intenta nuevamente.",
                parse_mode="Markdown"
            )
        except:
            pass

if __name__ == "__main__":
    import uvicorn
    logger.info(f"üöÄ Iniciando servidor en puerto {PORT}")
    uvicorn.run(app, host="0.0.0.0", port=PORT, log_level="info")
